// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class errorinfo;
class result_info;
class identity_card;
class location_info;
class school_info;
class relation_contact;
class family_info;
class property_info;
class work_info;
class card_info;
class user_info;
class user_basic_identification;
class common_ask_header;

enum degree {
  low = 1,
  major = 2,
  college = 3,
  master = 4,
  doctor = 5
};
bool degree_IsValid(int value);
const degree degree_MIN = low;
const degree degree_MAX = doctor;
const int degree_ARRAYSIZE = degree_MAX + 1;

const ::google::protobuf::EnumDescriptor* degree_descriptor();
inline const ::std::string& degree_Name(degree value) {
  return ::google::protobuf::internal::NameOfEnum(
    degree_descriptor(), value);
}
inline bool degree_Parse(
    const ::std::string& name, degree* value) {
  return ::google::protobuf::internal::ParseNamedEnum<degree>(
    degree_descriptor(), name, value);
}
enum platform_serial_number {
  niiwoo = 10,
  tuandai = 11
};
bool platform_serial_number_IsValid(int value);
const platform_serial_number platform_serial_number_MIN = niiwoo;
const platform_serial_number platform_serial_number_MAX = tuandai;
const int platform_serial_number_ARRAYSIZE = platform_serial_number_MAX + 1;

const ::google::protobuf::EnumDescriptor* platform_serial_number_descriptor();
inline const ::std::string& platform_serial_number_Name(platform_serial_number value) {
  return ::google::protobuf::internal::NameOfEnum(
    platform_serial_number_descriptor(), value);
}
inline bool platform_serial_number_Parse(
    const ::std::string& name, platform_serial_number* value) {
  return ::google::protobuf::internal::ParseNamedEnum<platform_serial_number>(
    platform_serial_number_descriptor(), name, value);
}
enum sex {
  male = 1,
  female = 2,
  unknow = 3
};
bool sex_IsValid(int value);
const sex sex_MIN = male;
const sex sex_MAX = unknow;
const int sex_ARRAYSIZE = sex_MAX + 1;

const ::google::protobuf::EnumDescriptor* sex_descriptor();
inline const ::std::string& sex_Name(sex value) {
  return ::google::protobuf::internal::NameOfEnum(
    sex_descriptor(), value);
}
inline bool sex_Parse(
    const ::std::string& name, sex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sex>(
    sex_descriptor(), name, value);
}
enum err_code {
  ASK_FAIL = 0,
  ASK_SUCCEED = 1
};
bool err_code_IsValid(int value);
const err_code err_code_MIN = ASK_FAIL;
const err_code err_code_MAX = ASK_SUCCEED;
const int err_code_ARRAYSIZE = err_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* err_code_descriptor();
inline const ::std::string& err_code_Name(err_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    err_code_descriptor(), value);
}
inline bool err_code_Parse(
    const ::std::string& name, err_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<err_code>(
    err_code_descriptor(), name, value);
}
enum result_code_type {
  FAILED = -1,
  SUCCESS = 0,
  TIMEOUT = 1,
  UNAUTHORIZED = 2
};
bool result_code_type_IsValid(int value);
const result_code_type result_code_type_MIN = FAILED;
const result_code_type result_code_type_MAX = UNAUTHORIZED;
const int result_code_type_ARRAYSIZE = result_code_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* result_code_type_descriptor();
inline const ::std::string& result_code_type_Name(result_code_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    result_code_type_descriptor(), value);
}
inline bool result_code_type_Parse(
    const ::std::string& name, result_code_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<result_code_type>(
    result_code_type_descriptor(), name, value);
}
enum user_id_type {
  other_id = 0,
  identity_card_type = 1,
  special_zone_permit = 2,
  return_home_permit = 3,
  officers_card = 4,
  extra_identity_card = 5,
  residence_booklet = 6,
  soldiers_card = 7
};
bool user_id_type_IsValid(int value);
const user_id_type user_id_type_MIN = other_id;
const user_id_type user_id_type_MAX = soldiers_card;
const int user_id_type_ARRAYSIZE = user_id_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* user_id_type_descriptor();
inline const ::std::string& user_id_type_Name(user_id_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    user_id_type_descriptor(), value);
}
inline bool user_id_type_Parse(
    const ::std::string& name, user_id_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<user_id_type>(
    user_id_type_descriptor(), name, value);
}
enum property_type {
  house_property = 1,
  car_property = 2,
  deposit_property = 3
};
bool property_type_IsValid(int value);
const property_type property_type_MIN = house_property;
const property_type property_type_MAX = deposit_property;
const int property_type_ARRAYSIZE = property_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* property_type_descriptor();
inline const ::std::string& property_type_Name(property_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    property_type_descriptor(), value);
}
inline bool property_type_Parse(
    const ::std::string& name, property_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<property_type>(
    property_type_descriptor(), name, value);
}
enum marriage_status {
  unmarried = 0,
  married = 1,
  divorced = 2,
  widowhood = 3,
  other_status = 4
};
bool marriage_status_IsValid(int value);
const marriage_status marriage_status_MIN = unmarried;
const marriage_status marriage_status_MAX = other_status;
const int marriage_status_ARRAYSIZE = marriage_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* marriage_status_descriptor();
inline const ::std::string& marriage_status_Name(marriage_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    marriage_status_descriptor(), value);
}
inline bool marriage_status_Parse(
    const ::std::string& name, marriage_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<marriage_status>(
    marriage_status_descriptor(), name, value);
}
enum relation_type {
  relative = 1,
  mate = 2,
  children = 3,
  parent = 4,
  brothers_or_sisters = 5,
  colleague = 10,
  friend = 11,
  other_relation = 99
};
bool relation_type_IsValid(int value);
const relation_type relation_type_MIN = relative;
const relation_type relation_type_MAX = other_relation;
const int relation_type_ARRAYSIZE = relation_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* relation_type_descriptor();
inline const ::std::string& relation_type_Name(relation_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    relation_type_descriptor(), value);
}
inline bool relation_type_Parse(
    const ::std::string& name, relation_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<relation_type>(
    relation_type_descriptor(), name, value);
}
enum tc_user_status {
  non_authentication = 0,
  realname_certification = 1,
  money_dabao = 2,
  money_xiaobao = 4,
  borrower = 8,
  partner = 16,
  in_work = 32,
  student = 64
};
bool tc_user_status_IsValid(int value);
const tc_user_status tc_user_status_MIN = non_authentication;
const tc_user_status tc_user_status_MAX = student;
const int tc_user_status_ARRAYSIZE = tc_user_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* tc_user_status_descriptor();
inline const ::std::string& tc_user_status_Name(tc_user_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    tc_user_status_descriptor(), value);
}
inline bool tc_user_status_Parse(
    const ::std::string& name, tc_user_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<tc_user_status>(
    tc_user_status_descriptor(), name, value);
}
// ===================================================================

class errorinfo : public ::google::protobuf::Message {
 public:
  errorinfo();
  virtual ~errorinfo();

  errorinfo(const errorinfo& from);

  inline errorinfo& operator=(const errorinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const errorinfo& default_instance();

  void Swap(errorinfo* other);

  // implements Message ----------------------------------------------

  errorinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const errorinfo& from);
  void MergeFrom(const errorinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.err_code error_code = 1 [default = ASK_FAIL];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::common::err_code error_code() const;
  inline void set_error_code(::common::err_code value);

  // optional bytes error_info = 2;
  inline bool has_error_info() const;
  inline void clear_error_info();
  static const int kErrorInfoFieldNumber = 2;
  inline const ::std::string& error_info() const;
  inline void set_error_info(const ::std::string& value);
  inline void set_error_info(const char* value);
  inline void set_error_info(const void* value, size_t size);
  inline ::std::string* mutable_error_info();
  inline ::std::string* release_error_info();
  inline void set_allocated_error_info(::std::string* error_info);

  // @@protoc_insertion_point(class_scope:common.errorinfo)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_info();
  inline void clear_has_error_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_info_;
  int error_code_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static errorinfo* default_instance_;
};
// -------------------------------------------------------------------

class result_info : public ::google::protobuf::Message {
 public:
  result_info();
  virtual ~result_info();

  result_info(const result_info& from);

  inline result_info& operator=(const result_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const result_info& default_instance();

  void Swap(result_info* other);

  // implements Message ----------------------------------------------

  result_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const result_info& from);
  void MergeFrom(const result_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.result_code_type result_code = 1 [default = FAILED];
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::common::result_code_type result_code() const;
  inline void set_result_code(::common::result_code_type value);

  // optional bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:common.result_info)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* result_msg_;
  int result_code_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static result_info* default_instance_;
};
// -------------------------------------------------------------------

class identity_card : public ::google::protobuf::Message {
 public:
  identity_card();
  virtual ~identity_card();

  identity_card(const identity_card& from);

  inline identity_card& operator=(const identity_card& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const identity_card& default_instance();

  void Swap(identity_card* other);

  // implements Message ----------------------------------------------

  identity_card* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const identity_card& from);
  void MergeFrom(const identity_card& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.user_id_type id_type = 1;
  inline bool has_id_type() const;
  inline void clear_id_type();
  static const int kIdTypeFieldNumber = 1;
  inline ::common::user_id_type id_type() const;
  inline void set_id_type(::common::user_id_type value);

  // optional bytes id_card = 2;
  inline bool has_id_card() const;
  inline void clear_id_card();
  static const int kIdCardFieldNumber = 2;
  inline const ::std::string& id_card() const;
  inline void set_id_card(const ::std::string& value);
  inline void set_id_card(const char* value);
  inline void set_id_card(const void* value, size_t size);
  inline ::std::string* mutable_id_card();
  inline ::std::string* release_id_card();
  inline void set_allocated_id_card(::std::string* id_card);

  // optional bytes card_address = 3;
  inline bool has_card_address() const;
  inline void clear_card_address();
  static const int kCardAddressFieldNumber = 3;
  inline const ::std::string& card_address() const;
  inline void set_card_address(const ::std::string& value);
  inline void set_card_address(const char* value);
  inline void set_card_address(const void* value, size_t size);
  inline ::std::string* mutable_card_address();
  inline ::std::string* release_card_address();
  inline void set_allocated_card_address(::std::string* card_address);

  // @@protoc_insertion_point(class_scope:common.identity_card)
 private:
  inline void set_has_id_type();
  inline void clear_has_id_type();
  inline void set_has_id_card();
  inline void clear_has_id_card();
  inline void set_has_card_address();
  inline void clear_has_card_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_card_;
  ::std::string* card_address_;
  int id_type_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static identity_card* default_instance_;
};
// -------------------------------------------------------------------

class location_info : public ::google::protobuf::Message {
 public:
  location_info();
  virtual ~location_info();

  location_info(const location_info& from);

  inline location_info& operator=(const location_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const location_info& default_instance();

  void Swap(location_info* other);

  // implements Message ----------------------------------------------

  location_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const location_info& from);
  void MergeFrom(const location_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes province = 1;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 1;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const void* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional bytes city = 2;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 2;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const void* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional bytes area = 3;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 3;
  inline const ::std::string& area() const;
  inline void set_area(const ::std::string& value);
  inline void set_area(const char* value);
  inline void set_area(const void* value, size_t size);
  inline ::std::string* mutable_area();
  inline ::std::string* release_area();
  inline void set_allocated_area(::std::string* area);

  // optional bytes longitude = 4;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  inline const ::std::string& longitude() const;
  inline void set_longitude(const ::std::string& value);
  inline void set_longitude(const char* value);
  inline void set_longitude(const void* value, size_t size);
  inline ::std::string* mutable_longitude();
  inline ::std::string* release_longitude();
  inline void set_allocated_longitude(::std::string* longitude);

  // optional bytes latitude = 5;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  inline const ::std::string& latitude() const;
  inline void set_latitude(const ::std::string& value);
  inline void set_latitude(const char* value);
  inline void set_latitude(const void* value, size_t size);
  inline ::std::string* mutable_latitude();
  inline ::std::string* release_latitude();
  inline void set_allocated_latitude(::std::string* latitude);

  // optional bytes event_time = 6;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 6;
  inline const ::std::string& event_time() const;
  inline void set_event_time(const ::std::string& value);
  inline void set_event_time(const char* value);
  inline void set_event_time(const void* value, size_t size);
  inline ::std::string* mutable_event_time();
  inline ::std::string* release_event_time();
  inline void set_allocated_event_time(::std::string* event_time);

  // optional bytes real_position = 7;
  inline bool has_real_position() const;
  inline void clear_real_position();
  static const int kRealPositionFieldNumber = 7;
  inline const ::std::string& real_position() const;
  inline void set_real_position(const ::std::string& value);
  inline void set_real_position(const char* value);
  inline void set_real_position(const void* value, size_t size);
  inline ::std::string* mutable_real_position();
  inline ::std::string* release_real_position();
  inline void set_allocated_real_position(::std::string* real_position);

  // @@protoc_insertion_point(class_scope:common.location_info)
 private:
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_real_position();
  inline void clear_has_real_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* area_;
  ::std::string* longitude_;
  ::std::string* latitude_;
  ::std::string* event_time_;
  ::std::string* real_position_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static location_info* default_instance_;
};
// -------------------------------------------------------------------

class school_info : public ::google::protobuf::Message {
 public:
  school_info();
  virtual ~school_info();

  school_info(const school_info& from);

  inline school_info& operator=(const school_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const school_info& default_instance();

  void Swap(school_info* other);

  // implements Message ----------------------------------------------

  school_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const school_info& from);
  void MergeFrom(const school_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes collegeName = 1;
  inline bool has_collegename() const;
  inline void clear_collegename();
  static const int kCollegeNameFieldNumber = 1;
  inline const ::std::string& collegename() const;
  inline void set_collegename(const ::std::string& value);
  inline void set_collegename(const char* value);
  inline void set_collegename(const void* value, size_t size);
  inline ::std::string* mutable_collegename();
  inline ::std::string* release_collegename();
  inline void set_allocated_collegename(::std::string* collegename);

  // optional .common.degree eductionDegree = 2;
  inline bool has_eductiondegree() const;
  inline void clear_eductiondegree();
  static const int kEductionDegreeFieldNumber = 2;
  inline ::common::degree eductiondegree() const;
  inline void set_eductiondegree(::common::degree value);

  // optional bytes educationCategory = 3;
  inline bool has_educationcategory() const;
  inline void clear_educationcategory();
  static const int kEducationCategoryFieldNumber = 3;
  inline const ::std::string& educationcategory() const;
  inline void set_educationcategory(const ::std::string& value);
  inline void set_educationcategory(const char* value);
  inline void set_educationcategory(const void* value, size_t size);
  inline ::std::string* mutable_educationcategory();
  inline ::std::string* release_educationcategory();
  inline void set_allocated_educationcategory(::std::string* educationcategory);

  // optional bytes graduateYear = 4;
  inline bool has_graduateyear() const;
  inline void clear_graduateyear();
  static const int kGraduateYearFieldNumber = 4;
  inline const ::std::string& graduateyear() const;
  inline void set_graduateyear(const ::std::string& value);
  inline void set_graduateyear(const char* value);
  inline void set_graduateyear(const void* value, size_t size);
  inline ::std::string* mutable_graduateyear();
  inline ::std::string* release_graduateyear();
  inline void set_allocated_graduateyear(::std::string* graduateyear);

  // optional bytes enrollmentYear = 5;
  inline bool has_enrollmentyear() const;
  inline void clear_enrollmentyear();
  static const int kEnrollmentYearFieldNumber = 5;
  inline const ::std::string& enrollmentyear() const;
  inline void set_enrollmentyear(const ::std::string& value);
  inline void set_enrollmentyear(const char* value);
  inline void set_enrollmentyear(const void* value, size_t size);
  inline ::std::string* mutable_enrollmentyear();
  inline ::std::string* release_enrollmentyear();
  inline void set_allocated_enrollmentyear(::std::string* enrollmentyear);

  // optional bytes major_subject = 6;
  inline bool has_major_subject() const;
  inline void clear_major_subject();
  static const int kMajorSubjectFieldNumber = 6;
  inline const ::std::string& major_subject() const;
  inline void set_major_subject(const ::std::string& value);
  inline void set_major_subject(const char* value);
  inline void set_major_subject(const void* value, size_t size);
  inline ::std::string* mutable_major_subject();
  inline ::std::string* release_major_subject();
  inline void set_allocated_major_subject(::std::string* major_subject);

  // optional bytes school_loc_privonce = 7;
  inline bool has_school_loc_privonce() const;
  inline void clear_school_loc_privonce();
  static const int kSchoolLocPrivonceFieldNumber = 7;
  inline const ::std::string& school_loc_privonce() const;
  inline void set_school_loc_privonce(const ::std::string& value);
  inline void set_school_loc_privonce(const char* value);
  inline void set_school_loc_privonce(const void* value, size_t size);
  inline ::std::string* mutable_school_loc_privonce();
  inline ::std::string* release_school_loc_privonce();
  inline void set_allocated_school_loc_privonce(::std::string* school_loc_privonce);

  // optional bytes school_loc_city = 8;
  inline bool has_school_loc_city() const;
  inline void clear_school_loc_city();
  static const int kSchoolLocCityFieldNumber = 8;
  inline const ::std::string& school_loc_city() const;
  inline void set_school_loc_city(const ::std::string& value);
  inline void set_school_loc_city(const char* value);
  inline void set_school_loc_city(const void* value, size_t size);
  inline ::std::string* mutable_school_loc_city();
  inline ::std::string* release_school_loc_city();
  inline void set_allocated_school_loc_city(::std::string* school_loc_city);

  // optional bytes school_loc_area = 9;
  inline bool has_school_loc_area() const;
  inline void clear_school_loc_area();
  static const int kSchoolLocAreaFieldNumber = 9;
  inline const ::std::string& school_loc_area() const;
  inline void set_school_loc_area(const ::std::string& value);
  inline void set_school_loc_area(const char* value);
  inline void set_school_loc_area(const void* value, size_t size);
  inline ::std::string* mutable_school_loc_area();
  inline ::std::string* release_school_loc_area();
  inline void set_allocated_school_loc_area(::std::string* school_loc_area);

  // optional bytes school_name = 10;
  inline bool has_school_name() const;
  inline void clear_school_name();
  static const int kSchoolNameFieldNumber = 10;
  inline const ::std::string& school_name() const;
  inline void set_school_name(const ::std::string& value);
  inline void set_school_name(const char* value);
  inline void set_school_name(const void* value, size_t size);
  inline ::std::string* mutable_school_name();
  inline ::std::string* release_school_name();
  inline void set_allocated_school_name(::std::string* school_name);

  // optional bytes school_address = 11;
  inline bool has_school_address() const;
  inline void clear_school_address();
  static const int kSchoolAddressFieldNumber = 11;
  inline const ::std::string& school_address() const;
  inline void set_school_address(const ::std::string& value);
  inline void set_school_address(const char* value);
  inline void set_school_address(const void* value, size_t size);
  inline ::std::string* mutable_school_address();
  inline ::std::string* release_school_address();
  inline void set_allocated_school_address(::std::string* school_address);

  // optional bytes educonclusion = 12;
  inline bool has_educonclusion() const;
  inline void clear_educonclusion();
  static const int kEduconclusionFieldNumber = 12;
  inline const ::std::string& educonclusion() const;
  inline void set_educonclusion(const ::std::string& value);
  inline void set_educonclusion(const char* value);
  inline void set_educonclusion(const void* value, size_t size);
  inline ::std::string* mutable_educonclusion();
  inline ::std::string* release_educonclusion();
  inline void set_allocated_educonclusion(::std::string* educonclusion);

  // optional bytes eduform = 13;
  inline bool has_eduform() const;
  inline void clear_eduform();
  static const int kEduformFieldNumber = 13;
  inline const ::std::string& eduform() const;
  inline void set_eduform(const ::std::string& value);
  inline void set_eduform(const char* value);
  inline void set_eduform(const void* value, size_t size);
  inline ::std::string* mutable_eduform();
  inline ::std::string* release_eduform();
  inline void set_allocated_eduform(::std::string* eduform);

  // optional bytes edurecord = 14;
  inline bool has_edurecord() const;
  inline void clear_edurecord();
  static const int kEdurecordFieldNumber = 14;
  inline const ::std::string& edurecord() const;
  inline void set_edurecord(const ::std::string& value);
  inline void set_edurecord(const char* value);
  inline void set_edurecord(const void* value, size_t size);
  inline ::std::string* mutable_edurecord();
  inline ::std::string* release_edurecord();
  inline void set_allocated_edurecord(::std::string* edurecord);

  // optional bytes eduschool = 15;
  inline bool has_eduschool() const;
  inline void clear_eduschool();
  static const int kEduschoolFieldNumber = 15;
  inline const ::std::string& eduschool() const;
  inline void set_eduschool(const ::std::string& value);
  inline void set_eduschool(const char* value);
  inline void set_eduschool(const void* value, size_t size);
  inline ::std::string* mutable_eduschool();
  inline ::std::string* release_eduschool();
  inline void set_allocated_eduschool(::std::string* eduschool);

  // optional bytes edutype = 16;
  inline bool has_edutype() const;
  inline void clear_edutype();
  static const int kEdutypeFieldNumber = 16;
  inline const ::std::string& edutype() const;
  inline void set_edutype(const ::std::string& value);
  inline void set_edutype(const char* value);
  inline void set_edutype(const void* value, size_t size);
  inline ::std::string* mutable_edutype();
  inline ::std::string* release_edutype();
  inline void set_allocated_edutype(::std::string* edutype);

  // optional bytes source = 18;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 18;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const void* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional bytes specialty = 19;
  inline bool has_specialty() const;
  inline void clear_specialty();
  static const int kSpecialtyFieldNumber = 19;
  inline const ::std::string& specialty() const;
  inline void set_specialty(const ::std::string& value);
  inline void set_specialty(const char* value);
  inline void set_specialty(const void* value, size_t size);
  inline ::std::string* mutable_specialty();
  inline ::std::string* release_specialty();
  inline void set_allocated_specialty(::std::string* specialty);

  // @@protoc_insertion_point(class_scope:common.school_info)
 private:
  inline void set_has_collegename();
  inline void clear_has_collegename();
  inline void set_has_eductiondegree();
  inline void clear_has_eductiondegree();
  inline void set_has_educationcategory();
  inline void clear_has_educationcategory();
  inline void set_has_graduateyear();
  inline void clear_has_graduateyear();
  inline void set_has_enrollmentyear();
  inline void clear_has_enrollmentyear();
  inline void set_has_major_subject();
  inline void clear_has_major_subject();
  inline void set_has_school_loc_privonce();
  inline void clear_has_school_loc_privonce();
  inline void set_has_school_loc_city();
  inline void clear_has_school_loc_city();
  inline void set_has_school_loc_area();
  inline void clear_has_school_loc_area();
  inline void set_has_school_name();
  inline void clear_has_school_name();
  inline void set_has_school_address();
  inline void clear_has_school_address();
  inline void set_has_educonclusion();
  inline void clear_has_educonclusion();
  inline void set_has_eduform();
  inline void clear_has_eduform();
  inline void set_has_edurecord();
  inline void clear_has_edurecord();
  inline void set_has_eduschool();
  inline void clear_has_eduschool();
  inline void set_has_edutype();
  inline void clear_has_edutype();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_specialty();
  inline void clear_has_specialty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* collegename_;
  ::std::string* educationcategory_;
  ::std::string* graduateyear_;
  ::std::string* enrollmentyear_;
  ::std::string* major_subject_;
  ::std::string* school_loc_privonce_;
  ::std::string* school_loc_city_;
  ::std::string* school_loc_area_;
  ::std::string* school_name_;
  ::std::string* school_address_;
  ::std::string* educonclusion_;
  ::std::string* eduform_;
  ::std::string* edurecord_;
  ::std::string* eduschool_;
  ::std::string* edutype_;
  ::std::string* source_;
  ::std::string* specialty_;
  int eductiondegree_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static school_info* default_instance_;
};
// -------------------------------------------------------------------

class relation_contact : public ::google::protobuf::Message {
 public:
  relation_contact();
  virtual ~relation_contact();

  relation_contact(const relation_contact& from);

  inline relation_contact& operator=(const relation_contact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const relation_contact& default_instance();

  void Swap(relation_contact* other);

  // implements Message ----------------------------------------------

  relation_contact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const relation_contact& from);
  void MergeFrom(const relation_contact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.relation_type relationship = 1;
  inline bool has_relationship() const;
  inline void clear_relationship();
  static const int kRelationshipFieldNumber = 1;
  inline ::common::relation_type relationship() const;
  inline void set_relationship(::common::relation_type value);

  // optional bytes contact_name = 2;
  inline bool has_contact_name() const;
  inline void clear_contact_name();
  static const int kContactNameFieldNumber = 2;
  inline const ::std::string& contact_name() const;
  inline void set_contact_name(const ::std::string& value);
  inline void set_contact_name(const char* value);
  inline void set_contact_name(const void* value, size_t size);
  inline ::std::string* mutable_contact_name();
  inline ::std::string* release_contact_name();
  inline void set_allocated_contact_name(::std::string* contact_name);

  // optional bytes mobilephone = 3;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 3;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const void* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // @@protoc_insertion_point(class_scope:common.relation_contact)
 private:
  inline void set_has_relationship();
  inline void clear_has_relationship();
  inline void set_has_contact_name();
  inline void clear_has_contact_name();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contact_name_;
  ::std::string* mobilephone_;
  int relationship_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static relation_contact* default_instance_;
};
// -------------------------------------------------------------------

class family_info : public ::google::protobuf::Message {
 public:
  family_info();
  virtual ~family_info();

  family_info(const family_info& from);

  inline family_info& operator=(const family_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_info& default_instance();

  void Swap(family_info* other);

  // implements Message ----------------------------------------------

  family_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_info& from);
  void MergeFrom(const family_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.marriage_status marriage = 1;
  inline bool has_marriage() const;
  inline void clear_marriage();
  static const int kMarriageFieldNumber = 1;
  inline ::common::marriage_status marriage() const;
  inline void set_marriage(::common::marriage_status value);

  // optional bool childred_status = 2;
  inline bool has_childred_status() const;
  inline void clear_childred_status();
  static const int kChildredStatusFieldNumber = 2;
  inline bool childred_status() const;
  inline void set_childred_status(bool value);

  // repeated .common.relation_contact contact_list = 3;
  inline int contact_list_size() const;
  inline void clear_contact_list();
  static const int kContactListFieldNumber = 3;
  inline const ::common::relation_contact& contact_list(int index) const;
  inline ::common::relation_contact* mutable_contact_list(int index);
  inline ::common::relation_contact* add_contact_list();
  inline const ::google::protobuf::RepeatedPtrField< ::common::relation_contact >&
      contact_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::relation_contact >*
      mutable_contact_list();

  // @@protoc_insertion_point(class_scope:common.family_info)
 private:
  inline void set_has_marriage();
  inline void clear_has_marriage();
  inline void set_has_childred_status();
  inline void clear_has_childred_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int marriage_;
  bool childred_status_;
  ::google::protobuf::RepeatedPtrField< ::common::relation_contact > contact_list_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_info* default_instance_;
};
// -------------------------------------------------------------------

class property_info : public ::google::protobuf::Message {
 public:
  property_info();
  virtual ~property_info();

  property_info(const property_info& from);

  inline property_info& operator=(const property_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const property_info& default_instance();

  void Swap(property_info* other);

  // implements Message ----------------------------------------------

  property_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const property_info& from);
  void MergeFrom(const property_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.property_type ptype = 1;
  inline bool has_ptype() const;
  inline void clear_ptype();
  static const int kPtypeFieldNumber = 1;
  inline ::common::property_type ptype() const;
  inline void set_ptype(::common::property_type value);

  // optional int32 valuation = 2;
  inline bool has_valuation() const;
  inline void clear_valuation();
  static const int kValuationFieldNumber = 2;
  inline ::google::protobuf::int32 valuation() const;
  inline void set_valuation(::google::protobuf::int32 value);

  // optional bool loan_status = 3;
  inline bool has_loan_status() const;
  inline void clear_loan_status();
  static const int kLoanStatusFieldNumber = 3;
  inline bool loan_status() const;
  inline void set_loan_status(bool value);

  // optional int32 debt_info = 4;
  inline bool has_debt_info() const;
  inline void clear_debt_info();
  static const int kDebtInfoFieldNumber = 4;
  inline ::google::protobuf::int32 debt_info() const;
  inline void set_debt_info(::google::protobuf::int32 value);

  // optional int32 age_limit = 5;
  inline bool has_age_limit() const;
  inline void clear_age_limit();
  static const int kAgeLimitFieldNumber = 5;
  inline ::google::protobuf::int32 age_limit() const;
  inline void set_age_limit(::google::protobuf::int32 value);

  // optional bytes loc_province = 6;
  inline bool has_loc_province() const;
  inline void clear_loc_province();
  static const int kLocProvinceFieldNumber = 6;
  inline const ::std::string& loc_province() const;
  inline void set_loc_province(const ::std::string& value);
  inline void set_loc_province(const char* value);
  inline void set_loc_province(const void* value, size_t size);
  inline ::std::string* mutable_loc_province();
  inline ::std::string* release_loc_province();
  inline void set_allocated_loc_province(::std::string* loc_province);

  // optional bytes loc_city = 7;
  inline bool has_loc_city() const;
  inline void clear_loc_city();
  static const int kLocCityFieldNumber = 7;
  inline const ::std::string& loc_city() const;
  inline void set_loc_city(const ::std::string& value);
  inline void set_loc_city(const char* value);
  inline void set_loc_city(const void* value, size_t size);
  inline ::std::string* mutable_loc_city();
  inline ::std::string* release_loc_city();
  inline void set_allocated_loc_city(::std::string* loc_city);

  // optional bytes loc_area = 8;
  inline bool has_loc_area() const;
  inline void clear_loc_area();
  static const int kLocAreaFieldNumber = 8;
  inline const ::std::string& loc_area() const;
  inline void set_loc_area(const ::std::string& value);
  inline void set_loc_area(const char* value);
  inline void set_loc_area(const void* value, size_t size);
  inline ::std::string* mutable_loc_area();
  inline ::std::string* release_loc_area();
  inline void set_allocated_loc_area(::std::string* loc_area);

  // optional int32 measurement = 9;
  inline bool has_measurement() const;
  inline void clear_measurement();
  static const int kMeasurementFieldNumber = 9;
  inline ::google::protobuf::int32 measurement() const;
  inline void set_measurement(::google::protobuf::int32 value);

  // optional bytes extend_info = 10;
  inline bool has_extend_info() const;
  inline void clear_extend_info();
  static const int kExtendInfoFieldNumber = 10;
  inline const ::std::string& extend_info() const;
  inline void set_extend_info(const ::std::string& value);
  inline void set_extend_info(const char* value);
  inline void set_extend_info(const void* value, size_t size);
  inline ::std::string* mutable_extend_info();
  inline ::std::string* release_extend_info();
  inline void set_allocated_extend_info(::std::string* extend_info);

  // @@protoc_insertion_point(class_scope:common.property_info)
 private:
  inline void set_has_ptype();
  inline void clear_has_ptype();
  inline void set_has_valuation();
  inline void clear_has_valuation();
  inline void set_has_loan_status();
  inline void clear_has_loan_status();
  inline void set_has_debt_info();
  inline void clear_has_debt_info();
  inline void set_has_age_limit();
  inline void clear_has_age_limit();
  inline void set_has_loc_province();
  inline void clear_has_loc_province();
  inline void set_has_loc_city();
  inline void clear_has_loc_city();
  inline void set_has_loc_area();
  inline void clear_has_loc_area();
  inline void set_has_measurement();
  inline void clear_has_measurement();
  inline void set_has_extend_info();
  inline void clear_has_extend_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int ptype_;
  ::google::protobuf::int32 valuation_;
  bool loan_status_;
  ::google::protobuf::int32 debt_info_;
  ::std::string* loc_province_;
  ::std::string* loc_city_;
  ::google::protobuf::int32 age_limit_;
  ::google::protobuf::int32 measurement_;
  ::std::string* loc_area_;
  ::std::string* extend_info_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static property_info* default_instance_;
};
// -------------------------------------------------------------------

class work_info : public ::google::protobuf::Message {
 public:
  work_info();
  virtual ~work_info();

  work_info(const work_info& from);

  inline work_info& operator=(const work_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const work_info& default_instance();

  void Swap(work_info* other);

  // implements Message ----------------------------------------------

  work_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const work_info& from);
  void MergeFrom(const work_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes company_name = 1;
  inline bool has_company_name() const;
  inline void clear_company_name();
  static const int kCompanyNameFieldNumber = 1;
  inline const ::std::string& company_name() const;
  inline void set_company_name(const ::std::string& value);
  inline void set_company_name(const char* value);
  inline void set_company_name(const void* value, size_t size);
  inline ::std::string* mutable_company_name();
  inline ::std::string* release_company_name();
  inline void set_allocated_company_name(::std::string* company_name);

  // optional bytes position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const void* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional bytes department = 3;
  inline bool has_department() const;
  inline void clear_department();
  static const int kDepartmentFieldNumber = 3;
  inline const ::std::string& department() const;
  inline void set_department(const ::std::string& value);
  inline void set_department(const char* value);
  inline void set_department(const void* value, size_t size);
  inline ::std::string* mutable_department();
  inline ::std::string* release_department();
  inline void set_allocated_department(::std::string* department);

  // optional .common.location_info company_loc = 4;
  inline bool has_company_loc() const;
  inline void clear_company_loc();
  static const int kCompanyLocFieldNumber = 4;
  inline const ::common::location_info& company_loc() const;
  inline ::common::location_info* mutable_company_loc();
  inline ::common::location_info* release_company_loc();
  inline void set_allocated_company_loc(::common::location_info* company_loc);

  // optional bytes industry = 5;
  inline bool has_industry() const;
  inline void clear_industry();
  static const int kIndustryFieldNumber = 5;
  inline const ::std::string& industry() const;
  inline void set_industry(const ::std::string& value);
  inline void set_industry(const char* value);
  inline void set_industry(const void* value, size_t size);
  inline ::std::string* mutable_industry();
  inline ::std::string* release_industry();
  inline void set_allocated_industry(::std::string* industry);

  // optional bytes years = 6;
  inline bool has_years() const;
  inline void clear_years();
  static const int kYearsFieldNumber = 6;
  inline const ::std::string& years() const;
  inline void set_years(const ::std::string& value);
  inline void set_years(const char* value);
  inline void set_years(const void* value, size_t size);
  inline ::std::string* mutable_years();
  inline ::std::string* release_years();
  inline void set_allocated_years(::std::string* years);

  // optional bytes income = 7;
  inline bool has_income() const;
  inline void clear_income();
  static const int kIncomeFieldNumber = 7;
  inline const ::std::string& income() const;
  inline void set_income(const ::std::string& value);
  inline void set_income(const char* value);
  inline void set_income(const void* value, size_t size);
  inline ::std::string* mutable_income();
  inline ::std::string* release_income();
  inline void set_allocated_income(::std::string* income);

  // optional .common.location_info work_loc = 8;
  inline bool has_work_loc() const;
  inline void clear_work_loc();
  static const int kWorkLocFieldNumber = 8;
  inline const ::common::location_info& work_loc() const;
  inline ::common::location_info* mutable_work_loc();
  inline ::common::location_info* release_work_loc();
  inline void set_allocated_work_loc(::common::location_info* work_loc);

  // @@protoc_insertion_point(class_scope:common.work_info)
 private:
  inline void set_has_company_name();
  inline void clear_has_company_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_department();
  inline void clear_has_department();
  inline void set_has_company_loc();
  inline void clear_has_company_loc();
  inline void set_has_industry();
  inline void clear_has_industry();
  inline void set_has_years();
  inline void clear_has_years();
  inline void set_has_income();
  inline void clear_has_income();
  inline void set_has_work_loc();
  inline void clear_has_work_loc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_name_;
  ::std::string* position_;
  ::std::string* department_;
  ::common::location_info* company_loc_;
  ::std::string* industry_;
  ::std::string* years_;
  ::std::string* income_;
  ::common::location_info* work_loc_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static work_info* default_instance_;
};
// -------------------------------------------------------------------

class card_info : public ::google::protobuf::Message {
 public:
  card_info();
  virtual ~card_info();

  card_info(const card_info& from);

  inline card_info& operator=(const card_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const card_info& default_instance();

  void Swap(card_info* other);

  // implements Message ----------------------------------------------

  card_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const card_info& from);
  void MergeFrom(const card_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes bankcode = 1;
  inline bool has_bankcode() const;
  inline void clear_bankcode();
  static const int kBankcodeFieldNumber = 1;
  inline const ::std::string& bankcode() const;
  inline void set_bankcode(const ::std::string& value);
  inline void set_bankcode(const char* value);
  inline void set_bankcode(const void* value, size_t size);
  inline ::std::string* mutable_bankcode();
  inline ::std::string* release_bankcode();
  inline void set_allocated_bankcode(::std::string* bankcode);

  // optional bytes cardno = 2;
  inline bool has_cardno() const;
  inline void clear_cardno();
  static const int kCardnoFieldNumber = 2;
  inline const ::std::string& cardno() const;
  inline void set_cardno(const ::std::string& value);
  inline void set_cardno(const char* value);
  inline void set_cardno(const void* value, size_t size);
  inline ::std::string* mutable_cardno();
  inline ::std::string* release_cardno();
  inline void set_allocated_cardno(::std::string* cardno);

  // optional bytes accountname = 3;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountnameFieldNumber = 3;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const void* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // optional bytes email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const void* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional double maxLineofcredit = 5;
  inline bool has_maxlineofcredit() const;
  inline void clear_maxlineofcredit();
  static const int kMaxLineofcreditFieldNumber = 5;
  inline double maxlineofcredit() const;
  inline void set_maxlineofcredit(double value);

  // optional double maxreturnamount = 6;
  inline bool has_maxreturnamount() const;
  inline void clear_maxreturnamount();
  static const int kMaxreturnamountFieldNumber = 6;
  inline double maxreturnamount() const;
  inline void set_maxreturnamount(double value);

  // optional bytes verifytime = 7;
  inline bool has_verifytime() const;
  inline void clear_verifytime();
  static const int kVerifytimeFieldNumber = 7;
  inline const ::std::string& verifytime() const;
  inline void set_verifytime(const ::std::string& value);
  inline void set_verifytime(const char* value);
  inline void set_verifytime(const void* value, size_t size);
  inline ::std::string* mutable_verifytime();
  inline ::std::string* release_verifytime();
  inline void set_allocated_verifytime(::std::string* verifytime);

  // optional bytes createtime = 8;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 8;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const void* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // optional bytes updatetime = 9;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdatetimeFieldNumber = 9;
  inline const ::std::string& updatetime() const;
  inline void set_updatetime(const ::std::string& value);
  inline void set_updatetime(const char* value);
  inline void set_updatetime(const void* value, size_t size);
  inline ::std::string* mutable_updatetime();
  inline ::std::string* release_updatetime();
  inline void set_allocated_updatetime(::std::string* updatetime);

  // @@protoc_insertion_point(class_scope:common.card_info)
 private:
  inline void set_has_bankcode();
  inline void clear_has_bankcode();
  inline void set_has_cardno();
  inline void clear_has_cardno();
  inline void set_has_accountname();
  inline void clear_has_accountname();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_maxlineofcredit();
  inline void clear_has_maxlineofcredit();
  inline void set_has_maxreturnamount();
  inline void clear_has_maxreturnamount();
  inline void set_has_verifytime();
  inline void clear_has_verifytime();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bankcode_;
  ::std::string* cardno_;
  ::std::string* accountname_;
  ::std::string* email_;
  double maxlineofcredit_;
  double maxreturnamount_;
  ::std::string* verifytime_;
  ::std::string* createtime_;
  ::std::string* updatetime_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static card_info* default_instance_;
};
// -------------------------------------------------------------------

class user_info : public ::google::protobuf::Message {
 public:
  user_info();
  virtual ~user_info();

  user_info(const user_info& from);

  inline user_info& operator=(const user_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_info& default_instance();

  void Swap(user_info* other);

  // implements Message ----------------------------------------------

  user_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_info& from);
  void MergeFrom(const user_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const void* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional .common.identity_card id_card = 2;
  inline bool has_id_card() const;
  inline void clear_id_card();
  static const int kIdCardFieldNumber = 2;
  inline const ::common::identity_card& id_card() const;
  inline ::common::identity_card* mutable_id_card();
  inline ::common::identity_card* release_id_card();
  inline void set_allocated_id_card(::common::identity_card* id_card);

  // optional bytes real_name = 3;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 3;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const void* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional bytes user_nickname = 4;
  inline bool has_user_nickname() const;
  inline void clear_user_nickname();
  static const int kUserNicknameFieldNumber = 4;
  inline const ::std::string& user_nickname() const;
  inline void set_user_nickname(const ::std::string& value);
  inline void set_user_nickname(const char* value);
  inline void set_user_nickname(const void* value, size_t size);
  inline ::std::string* mutable_user_nickname();
  inline ::std::string* release_user_nickname();
  inline void set_allocated_user_nickname(::std::string* user_nickname);

  // optional bytes mobile_phone = 5;
  inline bool has_mobile_phone() const;
  inline void clear_mobile_phone();
  static const int kMobilePhoneFieldNumber = 5;
  inline const ::std::string& mobile_phone() const;
  inline void set_mobile_phone(const ::std::string& value);
  inline void set_mobile_phone(const char* value);
  inline void set_mobile_phone(const void* value, size_t size);
  inline ::std::string* mutable_mobile_phone();
  inline ::std::string* release_mobile_phone();
  inline void set_allocated_mobile_phone(::std::string* mobile_phone);

  // optional bytes email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const void* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional bytes address = 7;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 7;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes bank_cart = 8;
  inline bool has_bank_cart() const;
  inline void clear_bank_cart();
  static const int kBankCartFieldNumber = 8;
  inline const ::std::string& bank_cart() const;
  inline void set_bank_cart(const ::std::string& value);
  inline void set_bank_cart(const char* value);
  inline void set_bank_cart(const void* value, size_t size);
  inline ::std::string* mutable_bank_cart();
  inline ::std::string* release_bank_cart();
  inline void set_allocated_bank_cart(::std::string* bank_cart);

  // optional bytes ip = 9;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 9;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional bytes mac = 10;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 10;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const void* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional bytes imei = 11;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 11;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const void* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional bytes blackBox = 12;
  inline bool has_blackbox() const;
  inline void clear_blackbox();
  static const int kBlackBoxFieldNumber = 12;
  inline const ::std::string& blackbox() const;
  inline void set_blackbox(const ::std::string& value);
  inline void set_blackbox(const char* value);
  inline void set_blackbox(const void* value, size_t size);
  inline ::std::string* mutable_blackbox();
  inline ::std::string* release_blackbox();
  inline void set_allocated_blackbox(::std::string* blackbox);

  // optional bool is_prove = 13;
  inline bool has_is_prove() const;
  inline void clear_is_prove();
  static const int kIsProveFieldNumber = 13;
  inline bool is_prove() const;
  inline void set_is_prove(bool value);

  // optional bytes avatar = 14;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 14;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const void* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional .common.school_info schoolinfo = 15;
  inline bool has_schoolinfo() const;
  inline void clear_schoolinfo();
  static const int kSchoolinfoFieldNumber = 15;
  inline const ::common::school_info& schoolinfo() const;
  inline ::common::school_info* mutable_schoolinfo();
  inline ::common::school_info* release_schoolinfo();
  inline void set_allocated_schoolinfo(::common::school_info* schoolinfo);

  // optional .common.family_info family = 16;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 16;
  inline const ::common::family_info& family() const;
  inline ::common::family_info* mutable_family();
  inline ::common::family_info* release_family();
  inline void set_allocated_family(::common::family_info* family);

  // repeated .common.property_info property = 17;
  inline int property_size() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 17;
  inline const ::common::property_info& property(int index) const;
  inline ::common::property_info* mutable_property(int index);
  inline ::common::property_info* add_property();
  inline const ::google::protobuf::RepeatedPtrField< ::common::property_info >&
      property() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::property_info >*
      mutable_property();

  // optional bytes login_from_others = 18;
  inline bool has_login_from_others() const;
  inline void clear_login_from_others();
  static const int kLoginFromOthersFieldNumber = 18;
  inline const ::std::string& login_from_others() const;
  inline void set_login_from_others(const ::std::string& value);
  inline void set_login_from_others(const char* value);
  inline void set_login_from_others(const void* value, size_t size);
  inline ::std::string* mutable_login_from_others();
  inline ::std::string* release_login_from_others();
  inline void set_allocated_login_from_others(::std::string* login_from_others);

  // optional bytes login_id = 19;
  inline bool has_login_id() const;
  inline void clear_login_id();
  static const int kLoginIdFieldNumber = 19;
  inline const ::std::string& login_id() const;
  inline void set_login_id(const ::std::string& value);
  inline void set_login_id(const char* value);
  inline void set_login_id(const void* value, size_t size);
  inline ::std::string* mutable_login_id();
  inline ::std::string* release_login_id();
  inline void set_allocated_login_id(::std::string* login_id);

  // optional bytes user_account = 20;
  inline bool has_user_account() const;
  inline void clear_user_account();
  static const int kUserAccountFieldNumber = 20;
  inline const ::std::string& user_account() const;
  inline void set_user_account(const ::std::string& value);
  inline void set_user_account(const char* value);
  inline void set_user_account(const void* value, size_t size);
  inline ::std::string* mutable_user_account();
  inline ::std::string* release_user_account();
  inline void set_allocated_user_account(::std::string* user_account);

  // optional .common.tc_user_status user_status = 21;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 21;
  inline ::common::tc_user_status user_status() const;
  inline void set_user_status(::common::tc_user_status value);

  // optional .common.sex sex_type = 22;
  inline bool has_sex_type() const;
  inline void clear_sex_type();
  static const int kSexTypeFieldNumber = 22;
  inline ::common::sex sex_type() const;
  inline void set_sex_type(::common::sex value);

  // optional bytes homtown = 23;
  inline bool has_homtown() const;
  inline void clear_homtown();
  static const int kHomtownFieldNumber = 23;
  inline const ::std::string& homtown() const;
  inline void set_homtown(const ::std::string& value);
  inline void set_homtown(const char* value);
  inline void set_homtown(const void* value, size_t size);
  inline ::std::string* mutable_homtown();
  inline ::std::string* release_homtown();
  inline void set_allocated_homtown(::std::string* homtown);

  // optional bytes birthday = 24;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 24;
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const void* value, size_t size);
  inline ::std::string* mutable_birthday();
  inline ::std::string* release_birthday();
  inline void set_allocated_birthday(::std::string* birthday);

  // optional .common.location_info living_loc_info = 25;
  inline bool has_living_loc_info() const;
  inline void clear_living_loc_info();
  static const int kLivingLocInfoFieldNumber = 25;
  inline const ::common::location_info& living_loc_info() const;
  inline ::common::location_info* mutable_living_loc_info();
  inline ::common::location_info* release_living_loc_info();
  inline void set_allocated_living_loc_info(::common::location_info* living_loc_info);

  // optional int32 age = 26;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 26;
  inline ::google::protobuf::int32 age() const;
  inline void set_age(::google::protobuf::int32 value);

  // optional .common.work_info work_info_ = 27;
  inline bool has_work_info_() const;
  inline void clear_work_info_();
  static const int kWorkInfoFieldNumber = 27;
  inline const ::common::work_info& work_info_() const;
  inline ::common::work_info* mutable_work_info_();
  inline ::common::work_info* release_work_info_();
  inline void set_allocated_work_info_(::common::work_info* work_info_);

  // optional int32 istuandai = 28;
  inline bool has_istuandai() const;
  inline void clear_istuandai();
  static const int kIstuandaiFieldNumber = 28;
  inline ::google::protobuf::int32 istuandai() const;
  inline void set_istuandai(::google::protobuf::int32 value);

  // optional int32 isjcredit = 29;
  inline bool has_isjcredit() const;
  inline void clear_isjcredit();
  static const int kIsjcreditFieldNumber = 29;
  inline ::google::protobuf::int32 isjcredit() const;
  inline void set_isjcredit(::google::protobuf::int32 value);

  // optional int32 isdcredit = 30;
  inline bool has_isdcredit() const;
  inline void clear_isdcredit();
  static const int kIsdcreditFieldNumber = 30;
  inline ::google::protobuf::int32 isdcredit() const;
  inline void set_isdcredit(::google::protobuf::int32 value);

  // optional int32 isverify = 31;
  inline bool has_isverify() const;
  inline void clear_isverify();
  static const int kIsverifyFieldNumber = 31;
  inline ::google::protobuf::int32 isverify() const;
  inline void set_isverify(::google::protobuf::int32 value);

  // optional int32 educationapplytype = 32;
  inline bool has_educationapplytype() const;
  inline void clear_educationapplytype();
  static const int kEducationapplytypeFieldNumber = 32;
  inline ::google::protobuf::int32 educationapplytype() const;
  inline void set_educationapplytype(::google::protobuf::int32 value);

  // optional bytes educationapplytime = 33;
  inline bool has_educationapplytime() const;
  inline void clear_educationapplytime();
  static const int kEducationapplytimeFieldNumber = 33;
  inline const ::std::string& educationapplytime() const;
  inline void set_educationapplytime(const ::std::string& value);
  inline void set_educationapplytime(const char* value);
  inline void set_educationapplytime(const void* value, size_t size);
  inline ::std::string* mutable_educationapplytime();
  inline ::std::string* release_educationapplytime();
  inline void set_allocated_educationapplytime(::std::string* educationapplytime);

  // repeated .common.card_info cardinfo = 34;
  inline int cardinfo_size() const;
  inline void clear_cardinfo();
  static const int kCardinfoFieldNumber = 34;
  inline const ::common::card_info& cardinfo(int index) const;
  inline ::common::card_info* mutable_cardinfo(int index);
  inline ::common::card_info* add_cardinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::common::card_info >&
      cardinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::common::card_info >*
      mutable_cardinfo();

  // @@protoc_insertion_point(class_scope:common.user_info)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_id_card();
  inline void clear_has_id_card();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_user_nickname();
  inline void clear_has_user_nickname();
  inline void set_has_mobile_phone();
  inline void clear_has_mobile_phone();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_bank_cart();
  inline void clear_has_bank_cart();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_blackbox();
  inline void clear_has_blackbox();
  inline void set_has_is_prove();
  inline void clear_has_is_prove();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_schoolinfo();
  inline void clear_has_schoolinfo();
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_login_from_others();
  inline void clear_has_login_from_others();
  inline void set_has_login_id();
  inline void clear_has_login_id();
  inline void set_has_user_account();
  inline void clear_has_user_account();
  inline void set_has_user_status();
  inline void clear_has_user_status();
  inline void set_has_sex_type();
  inline void clear_has_sex_type();
  inline void set_has_homtown();
  inline void clear_has_homtown();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_living_loc_info();
  inline void clear_has_living_loc_info();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_work_info_();
  inline void clear_has_work_info_();
  inline void set_has_istuandai();
  inline void clear_has_istuandai();
  inline void set_has_isjcredit();
  inline void clear_has_isjcredit();
  inline void set_has_isdcredit();
  inline void clear_has_isdcredit();
  inline void set_has_isverify();
  inline void clear_has_isverify();
  inline void set_has_educationapplytype();
  inline void clear_has_educationapplytype();
  inline void set_has_educationapplytime();
  inline void clear_has_educationapplytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::std::string* user_id_;
  ::common::identity_card* id_card_;
  ::std::string* real_name_;
  ::std::string* user_nickname_;
  ::std::string* mobile_phone_;
  ::std::string* email_;
  ::std::string* address_;
  ::std::string* bank_cart_;
  ::std::string* ip_;
  ::std::string* mac_;
  ::std::string* imei_;
  ::std::string* blackbox_;
  ::std::string* avatar_;
  ::common::school_info* schoolinfo_;
  ::common::family_info* family_;
  ::google::protobuf::RepeatedPtrField< ::common::property_info > property_;
  bool is_prove_;
  int user_status_;
  ::std::string* login_from_others_;
  ::std::string* login_id_;
  ::std::string* user_account_;
  ::std::string* homtown_;
  ::std::string* birthday_;
  int sex_type_;
  ::google::protobuf::int32 age_;
  ::common::location_info* living_loc_info_;
  ::common::work_info* work_info__;
  ::google::protobuf::int32 istuandai_;
  ::google::protobuf::int32 isjcredit_;
  ::google::protobuf::int32 isdcredit_;
  ::google::protobuf::int32 isverify_;
  ::std::string* educationapplytime_;
  ::google::protobuf::RepeatedPtrField< ::common::card_info > cardinfo_;
  ::google::protobuf::int32 educationapplytype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_info* default_instance_;
};
// -------------------------------------------------------------------

class user_basic_identification : public ::google::protobuf::Message {
 public:
  user_basic_identification();
  virtual ~user_basic_identification();

  user_basic_identification(const user_basic_identification& from);

  inline user_basic_identification& operator=(const user_basic_identification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_basic_identification& default_instance();

  void Swap(user_basic_identification* other);

  // implements Message ----------------------------------------------

  user_basic_identification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_basic_identification& from);
  void MergeFrom(const user_basic_identification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes identity_card = 1;
  inline bool has_identity_card() const;
  inline void clear_identity_card();
  static const int kIdentityCardFieldNumber = 1;
  inline const ::std::string& identity_card() const;
  inline void set_identity_card(const ::std::string& value);
  inline void set_identity_card(const char* value);
  inline void set_identity_card(const void* value, size_t size);
  inline ::std::string* mutable_identity_card();
  inline ::std::string* release_identity_card();
  inline void set_allocated_identity_card(::std::string* identity_card);

  // optional bytes mobile_phone = 2;
  inline bool has_mobile_phone() const;
  inline void clear_mobile_phone();
  static const int kMobilePhoneFieldNumber = 2;
  inline const ::std::string& mobile_phone() const;
  inline void set_mobile_phone(const ::std::string& value);
  inline void set_mobile_phone(const char* value);
  inline void set_mobile_phone(const void* value, size_t size);
  inline ::std::string* mutable_mobile_phone();
  inline ::std::string* release_mobile_phone();
  inline void set_allocated_mobile_phone(::std::string* mobile_phone);

  // optional bytes real_name = 3;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 3;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const void* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // @@protoc_insertion_point(class_scope:common.user_basic_identification)
 private:
  inline void set_has_identity_card();
  inline void clear_has_identity_card();
  inline void set_has_mobile_phone();
  inline void clear_has_mobile_phone();
  inline void set_has_real_name();
  inline void clear_has_real_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* identity_card_;
  ::std::string* mobile_phone_;
  ::std::string* real_name_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_basic_identification* default_instance_;
};
// -------------------------------------------------------------------

class common_ask_header : public ::google::protobuf::Message {
 public:
  common_ask_header();
  virtual ~common_ask_header();

  common_ask_header(const common_ask_header& from);

  inline common_ask_header& operator=(const common_ask_header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const common_ask_header& default_instance();

  void Swap(common_ask_header* other);

  // implements Message ----------------------------------------------

  common_ask_header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const common_ask_header& from);
  void MergeFrom(const common_ask_header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes response_topic = 1;
  inline bool has_response_topic() const;
  inline void clear_response_topic();
  static const int kResponseTopicFieldNumber = 1;
  inline const ::std::string& response_topic() const;
  inline void set_response_topic(const ::std::string& value);
  inline void set_response_topic(const char* value);
  inline void set_response_topic(const void* value, size_t size);
  inline ::std::string* mutable_response_topic();
  inline ::std::string* release_response_topic();
  inline void set_allocated_response_topic(::std::string* response_topic);

  // @@protoc_insertion_point(class_scope:common.common_ask_header)
 private:
  inline void set_has_response_topic();
  inline void clear_has_response_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* response_topic_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static common_ask_header* default_instance_;
};
// ===================================================================


// ===================================================================

// errorinfo

// optional .common.err_code error_code = 1 [default = ASK_FAIL];
inline bool errorinfo::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void errorinfo::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void errorinfo::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void errorinfo::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::common::err_code errorinfo::error_code() const {
  // @@protoc_insertion_point(field_get:common.errorinfo.error_code)
  return static_cast< ::common::err_code >(error_code_);
}
inline void errorinfo::set_error_code(::common::err_code value) {
  assert(::common::err_code_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:common.errorinfo.error_code)
}

// optional bytes error_info = 2;
inline bool errorinfo::has_error_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void errorinfo::set_has_error_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void errorinfo::clear_has_error_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void errorinfo::clear_error_info() {
  if (error_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_info_->clear();
  }
  clear_has_error_info();
}
inline const ::std::string& errorinfo::error_info() const {
  // @@protoc_insertion_point(field_get:common.errorinfo.error_info)
  return *error_info_;
}
inline void errorinfo::set_error_info(const ::std::string& value) {
  set_has_error_info();
  if (error_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_info_ = new ::std::string;
  }
  error_info_->assign(value);
  // @@protoc_insertion_point(field_set:common.errorinfo.error_info)
}
inline void errorinfo::set_error_info(const char* value) {
  set_has_error_info();
  if (error_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_info_ = new ::std::string;
  }
  error_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.errorinfo.error_info)
}
inline void errorinfo::set_error_info(const void* value, size_t size) {
  set_has_error_info();
  if (error_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_info_ = new ::std::string;
  }
  error_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.errorinfo.error_info)
}
inline ::std::string* errorinfo::mutable_error_info() {
  set_has_error_info();
  if (error_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.errorinfo.error_info)
  return error_info_;
}
inline ::std::string* errorinfo::release_error_info() {
  clear_has_error_info();
  if (error_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_info_;
    error_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void errorinfo::set_allocated_error_info(::std::string* error_info) {
  if (error_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_info_;
  }
  if (error_info) {
    set_has_error_info();
    error_info_ = error_info;
  } else {
    clear_has_error_info();
    error_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.errorinfo.error_info)
}

// -------------------------------------------------------------------

// result_info

// optional .common.result_code_type result_code = 1 [default = FAILED];
inline bool result_info::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void result_info::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void result_info::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void result_info::clear_result_code() {
  result_code_ = -1;
  clear_has_result_code();
}
inline ::common::result_code_type result_info::result_code() const {
  // @@protoc_insertion_point(field_get:common.result_info.result_code)
  return static_cast< ::common::result_code_type >(result_code_);
}
inline void result_info::set_result_code(::common::result_code_type value) {
  assert(::common::result_code_type_IsValid(value));
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:common.result_info.result_code)
}

// optional bytes result_msg = 2;
inline bool result_info::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void result_info::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void result_info::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void result_info::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& result_info::result_msg() const {
  // @@protoc_insertion_point(field_get:common.result_info.result_msg)
  return *result_msg_;
}
inline void result_info::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
  // @@protoc_insertion_point(field_set:common.result_info.result_msg)
}
inline void result_info::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.result_info.result_msg)
}
inline void result_info::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.result_info.result_msg)
}
inline ::std::string* result_info::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.result_info.result_msg)
  return result_msg_;
}
inline ::std::string* result_info::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void result_info::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.result_info.result_msg)
}

// -------------------------------------------------------------------

// identity_card

// optional .common.user_id_type id_type = 1;
inline bool identity_card::has_id_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void identity_card::set_has_id_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void identity_card::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void identity_card::clear_id_type() {
  id_type_ = 0;
  clear_has_id_type();
}
inline ::common::user_id_type identity_card::id_type() const {
  // @@protoc_insertion_point(field_get:common.identity_card.id_type)
  return static_cast< ::common::user_id_type >(id_type_);
}
inline void identity_card::set_id_type(::common::user_id_type value) {
  assert(::common::user_id_type_IsValid(value));
  set_has_id_type();
  id_type_ = value;
  // @@protoc_insertion_point(field_set:common.identity_card.id_type)
}

// optional bytes id_card = 2;
inline bool identity_card::has_id_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void identity_card::set_has_id_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void identity_card::clear_has_id_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void identity_card::clear_id_card() {
  if (id_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_card_->clear();
  }
  clear_has_id_card();
}
inline const ::std::string& identity_card::id_card() const {
  // @@protoc_insertion_point(field_get:common.identity_card.id_card)
  return *id_card_;
}
inline void identity_card::set_id_card(const ::std::string& value) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(value);
  // @@protoc_insertion_point(field_set:common.identity_card.id_card)
}
inline void identity_card::set_id_card(const char* value) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.identity_card.id_card)
}
inline void identity_card::set_id_card(const void* value, size_t size) {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_card_ = new ::std::string;
  }
  id_card_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.identity_card.id_card)
}
inline ::std::string* identity_card::mutable_id_card() {
  set_has_id_card();
  if (id_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_card_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.identity_card.id_card)
  return id_card_;
}
inline ::std::string* identity_card::release_id_card() {
  clear_has_id_card();
  if (id_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_card_;
    id_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void identity_card::set_allocated_id_card(::std::string* id_card) {
  if (id_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_card_;
  }
  if (id_card) {
    set_has_id_card();
    id_card_ = id_card;
  } else {
    clear_has_id_card();
    id_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.identity_card.id_card)
}

// optional bytes card_address = 3;
inline bool identity_card::has_card_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void identity_card::set_has_card_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void identity_card::clear_has_card_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void identity_card::clear_card_address() {
  if (card_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_address_->clear();
  }
  clear_has_card_address();
}
inline const ::std::string& identity_card::card_address() const {
  // @@protoc_insertion_point(field_get:common.identity_card.card_address)
  return *card_address_;
}
inline void identity_card::set_card_address(const ::std::string& value) {
  set_has_card_address();
  if (card_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_address_ = new ::std::string;
  }
  card_address_->assign(value);
  // @@protoc_insertion_point(field_set:common.identity_card.card_address)
}
inline void identity_card::set_card_address(const char* value) {
  set_has_card_address();
  if (card_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_address_ = new ::std::string;
  }
  card_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.identity_card.card_address)
}
inline void identity_card::set_card_address(const void* value, size_t size) {
  set_has_card_address();
  if (card_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_address_ = new ::std::string;
  }
  card_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.identity_card.card_address)
}
inline ::std::string* identity_card::mutable_card_address() {
  set_has_card_address();
  if (card_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.identity_card.card_address)
  return card_address_;
}
inline ::std::string* identity_card::release_card_address() {
  clear_has_card_address();
  if (card_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = card_address_;
    card_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void identity_card::set_allocated_card_address(::std::string* card_address) {
  if (card_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete card_address_;
  }
  if (card_address) {
    set_has_card_address();
    card_address_ = card_address;
  } else {
    clear_has_card_address();
    card_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.identity_card.card_address)
}

// -------------------------------------------------------------------

// location_info

// optional bytes province = 1;
inline bool location_info::has_province() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void location_info::set_has_province() {
  _has_bits_[0] |= 0x00000001u;
}
inline void location_info::clear_has_province() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void location_info::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& location_info::province() const {
  // @@protoc_insertion_point(field_get:common.location_info.province)
  return *province_;
}
inline void location_info::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.province)
}
inline void location_info::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.province)
}
inline void location_info::set_province(const void* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.province)
}
inline ::std::string* location_info::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.province)
  return province_;
}
inline ::std::string* location_info::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.province)
}

// optional bytes city = 2;
inline bool location_info::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void location_info::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void location_info::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void location_info::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& location_info::city() const {
  // @@protoc_insertion_point(field_get:common.location_info.city)
  return *city_;
}
inline void location_info::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.city)
}
inline void location_info::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.city)
}
inline void location_info::set_city(const void* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.city)
}
inline ::std::string* location_info::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.city)
  return city_;
}
inline ::std::string* location_info::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.city)
}

// optional bytes area = 3;
inline bool location_info::has_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void location_info::set_has_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void location_info::clear_has_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void location_info::clear_area() {
  if (area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    area_->clear();
  }
  clear_has_area();
}
inline const ::std::string& location_info::area() const {
  // @@protoc_insertion_point(field_get:common.location_info.area)
  return *area_;
}
inline void location_info::set_area(const ::std::string& value) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    area_ = new ::std::string;
  }
  area_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.area)
}
inline void location_info::set_area(const char* value) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    area_ = new ::std::string;
  }
  area_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.area)
}
inline void location_info::set_area(const void* value, size_t size) {
  set_has_area();
  if (area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    area_ = new ::std::string;
  }
  area_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.area)
}
inline ::std::string* location_info::mutable_area() {
  set_has_area();
  if (area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    area_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.area)
  return area_;
}
inline ::std::string* location_info::release_area() {
  clear_has_area();
  if (area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = area_;
    area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_area(::std::string* area) {
  if (area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete area_;
  }
  if (area) {
    set_has_area();
    area_ = area;
  } else {
    clear_has_area();
    area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.area)
}

// optional bytes longitude = 4;
inline bool location_info::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void location_info::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void location_info::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void location_info::clear_longitude() {
  if (longitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    longitude_->clear();
  }
  clear_has_longitude();
}
inline const ::std::string& location_info::longitude() const {
  // @@protoc_insertion_point(field_get:common.location_info.longitude)
  return *longitude_;
}
inline void location_info::set_longitude(const ::std::string& value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.longitude)
}
inline void location_info::set_longitude(const char* value) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.longitude)
}
inline void location_info::set_longitude(const void* value, size_t size) {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    longitude_ = new ::std::string;
  }
  longitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.longitude)
}
inline ::std::string* location_info::mutable_longitude() {
  set_has_longitude();
  if (longitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    longitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.longitude)
  return longitude_;
}
inline ::std::string* location_info::release_longitude() {
  clear_has_longitude();
  if (longitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = longitude_;
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_longitude(::std::string* longitude) {
  if (longitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete longitude_;
  }
  if (longitude) {
    set_has_longitude();
    longitude_ = longitude;
  } else {
    clear_has_longitude();
    longitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.longitude)
}

// optional bytes latitude = 5;
inline bool location_info::has_latitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void location_info::set_has_latitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void location_info::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void location_info::clear_latitude() {
  if (latitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latitude_->clear();
  }
  clear_has_latitude();
}
inline const ::std::string& location_info::latitude() const {
  // @@protoc_insertion_point(field_get:common.location_info.latitude)
  return *latitude_;
}
inline void location_info::set_latitude(const ::std::string& value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.latitude)
}
inline void location_info::set_latitude(const char* value) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.latitude)
}
inline void location_info::set_latitude(const void* value, size_t size) {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latitude_ = new ::std::string;
  }
  latitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.latitude)
}
inline ::std::string* location_info::mutable_latitude() {
  set_has_latitude();
  if (latitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.latitude)
  return latitude_;
}
inline ::std::string* location_info::release_latitude() {
  clear_has_latitude();
  if (latitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latitude_;
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_latitude(::std::string* latitude) {
  if (latitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latitude_;
  }
  if (latitude) {
    set_has_latitude();
    latitude_ = latitude;
  } else {
    clear_has_latitude();
    latitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.latitude)
}

// optional bytes event_time = 6;
inline bool location_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void location_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void location_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void location_info::clear_event_time() {
  if (event_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_time_->clear();
  }
  clear_has_event_time();
}
inline const ::std::string& location_info::event_time() const {
  // @@protoc_insertion_point(field_get:common.location_info.event_time)
  return *event_time_;
}
inline void location_info::set_event_time(const ::std::string& value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.event_time)
}
inline void location_info::set_event_time(const char* value) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.event_time)
}
inline void location_info::set_event_time(const void* value, size_t size) {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_time_ = new ::std::string;
  }
  event_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.event_time)
}
inline ::std::string* location_info::mutable_event_time() {
  set_has_event_time();
  if (event_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.event_time)
  return event_time_;
}
inline ::std::string* location_info::release_event_time() {
  clear_has_event_time();
  if (event_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = event_time_;
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_event_time(::std::string* event_time) {
  if (event_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete event_time_;
  }
  if (event_time) {
    set_has_event_time();
    event_time_ = event_time;
  } else {
    clear_has_event_time();
    event_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.event_time)
}

// optional bytes real_position = 7;
inline bool location_info::has_real_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void location_info::set_has_real_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void location_info::clear_has_real_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void location_info::clear_real_position() {
  if (real_position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_position_->clear();
  }
  clear_has_real_position();
}
inline const ::std::string& location_info::real_position() const {
  // @@protoc_insertion_point(field_get:common.location_info.real_position)
  return *real_position_;
}
inline void location_info::set_real_position(const ::std::string& value) {
  set_has_real_position();
  if (real_position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_position_ = new ::std::string;
  }
  real_position_->assign(value);
  // @@protoc_insertion_point(field_set:common.location_info.real_position)
}
inline void location_info::set_real_position(const char* value) {
  set_has_real_position();
  if (real_position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_position_ = new ::std::string;
  }
  real_position_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.location_info.real_position)
}
inline void location_info::set_real_position(const void* value, size_t size) {
  set_has_real_position();
  if (real_position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_position_ = new ::std::string;
  }
  real_position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.location_info.real_position)
}
inline ::std::string* location_info::mutable_real_position() {
  set_has_real_position();
  if (real_position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.location_info.real_position)
  return real_position_;
}
inline ::std::string* location_info::release_real_position() {
  clear_has_real_position();
  if (real_position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_position_;
    real_position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void location_info::set_allocated_real_position(::std::string* real_position) {
  if (real_position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_position_;
  }
  if (real_position) {
    set_has_real_position();
    real_position_ = real_position;
  } else {
    clear_has_real_position();
    real_position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.location_info.real_position)
}

// -------------------------------------------------------------------

// school_info

// optional bytes collegeName = 1;
inline bool school_info::has_collegename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void school_info::set_has_collegename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void school_info::clear_has_collegename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void school_info::clear_collegename() {
  if (collegename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_->clear();
  }
  clear_has_collegename();
}
inline const ::std::string& school_info::collegename() const {
  // @@protoc_insertion_point(field_get:common.school_info.collegeName)
  return *collegename_;
}
inline void school_info::set_collegename(const ::std::string& value) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.collegeName)
}
inline void school_info::set_collegename(const char* value) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.collegeName)
}
inline void school_info::set_collegename(const void* value, size_t size) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.collegeName)
}
inline ::std::string* school_info::mutable_collegename() {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.collegeName)
  return collegename_;
}
inline ::std::string* school_info::release_collegename() {
  clear_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = collegename_;
    collegename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_collegename(::std::string* collegename) {
  if (collegename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete collegename_;
  }
  if (collegename) {
    set_has_collegename();
    collegename_ = collegename;
  } else {
    clear_has_collegename();
    collegename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.collegeName)
}

// optional .common.degree eductionDegree = 2;
inline bool school_info::has_eductiondegree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void school_info::set_has_eductiondegree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void school_info::clear_has_eductiondegree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void school_info::clear_eductiondegree() {
  eductiondegree_ = 1;
  clear_has_eductiondegree();
}
inline ::common::degree school_info::eductiondegree() const {
  // @@protoc_insertion_point(field_get:common.school_info.eductionDegree)
  return static_cast< ::common::degree >(eductiondegree_);
}
inline void school_info::set_eductiondegree(::common::degree value) {
  assert(::common::degree_IsValid(value));
  set_has_eductiondegree();
  eductiondegree_ = value;
  // @@protoc_insertion_point(field_set:common.school_info.eductionDegree)
}

// optional bytes educationCategory = 3;
inline bool school_info::has_educationcategory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void school_info::set_has_educationcategory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void school_info::clear_has_educationcategory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void school_info::clear_educationcategory() {
  if (educationcategory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_->clear();
  }
  clear_has_educationcategory();
}
inline const ::std::string& school_info::educationcategory() const {
  // @@protoc_insertion_point(field_get:common.school_info.educationCategory)
  return *educationcategory_;
}
inline void school_info::set_educationcategory(const ::std::string& value) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.educationCategory)
}
inline void school_info::set_educationcategory(const char* value) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.educationCategory)
}
inline void school_info::set_educationcategory(const void* value, size_t size) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.educationCategory)
}
inline ::std::string* school_info::mutable_educationcategory() {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.educationCategory)
  return educationcategory_;
}
inline ::std::string* school_info::release_educationcategory() {
  clear_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = educationcategory_;
    educationcategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_educationcategory(::std::string* educationcategory) {
  if (educationcategory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete educationcategory_;
  }
  if (educationcategory) {
    set_has_educationcategory();
    educationcategory_ = educationcategory;
  } else {
    clear_has_educationcategory();
    educationcategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.educationCategory)
}

// optional bytes graduateYear = 4;
inline bool school_info::has_graduateyear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void school_info::set_has_graduateyear() {
  _has_bits_[0] |= 0x00000008u;
}
inline void school_info::clear_has_graduateyear() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void school_info::clear_graduateyear() {
  if (graduateyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_->clear();
  }
  clear_has_graduateyear();
}
inline const ::std::string& school_info::graduateyear() const {
  // @@protoc_insertion_point(field_get:common.school_info.graduateYear)
  return *graduateyear_;
}
inline void school_info::set_graduateyear(const ::std::string& value) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.graduateYear)
}
inline void school_info::set_graduateyear(const char* value) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.graduateYear)
}
inline void school_info::set_graduateyear(const void* value, size_t size) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.graduateYear)
}
inline ::std::string* school_info::mutable_graduateyear() {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.graduateYear)
  return graduateyear_;
}
inline ::std::string* school_info::release_graduateyear() {
  clear_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = graduateyear_;
    graduateyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_graduateyear(::std::string* graduateyear) {
  if (graduateyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete graduateyear_;
  }
  if (graduateyear) {
    set_has_graduateyear();
    graduateyear_ = graduateyear;
  } else {
    clear_has_graduateyear();
    graduateyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.graduateYear)
}

// optional bytes enrollmentYear = 5;
inline bool school_info::has_enrollmentyear() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void school_info::set_has_enrollmentyear() {
  _has_bits_[0] |= 0x00000010u;
}
inline void school_info::clear_has_enrollmentyear() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void school_info::clear_enrollmentyear() {
  if (enrollmentyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_->clear();
  }
  clear_has_enrollmentyear();
}
inline const ::std::string& school_info::enrollmentyear() const {
  // @@protoc_insertion_point(field_get:common.school_info.enrollmentYear)
  return *enrollmentyear_;
}
inline void school_info::set_enrollmentyear(const ::std::string& value) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.enrollmentYear)
}
inline void school_info::set_enrollmentyear(const char* value) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.enrollmentYear)
}
inline void school_info::set_enrollmentyear(const void* value, size_t size) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.enrollmentYear)
}
inline ::std::string* school_info::mutable_enrollmentyear() {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.enrollmentYear)
  return enrollmentyear_;
}
inline ::std::string* school_info::release_enrollmentyear() {
  clear_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enrollmentyear_;
    enrollmentyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_enrollmentyear(::std::string* enrollmentyear) {
  if (enrollmentyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enrollmentyear_;
  }
  if (enrollmentyear) {
    set_has_enrollmentyear();
    enrollmentyear_ = enrollmentyear;
  } else {
    clear_has_enrollmentyear();
    enrollmentyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.enrollmentYear)
}

// optional bytes major_subject = 6;
inline bool school_info::has_major_subject() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void school_info::set_has_major_subject() {
  _has_bits_[0] |= 0x00000020u;
}
inline void school_info::clear_has_major_subject() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void school_info::clear_major_subject() {
  if (major_subject_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    major_subject_->clear();
  }
  clear_has_major_subject();
}
inline const ::std::string& school_info::major_subject() const {
  // @@protoc_insertion_point(field_get:common.school_info.major_subject)
  return *major_subject_;
}
inline void school_info::set_major_subject(const ::std::string& value) {
  set_has_major_subject();
  if (major_subject_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    major_subject_ = new ::std::string;
  }
  major_subject_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.major_subject)
}
inline void school_info::set_major_subject(const char* value) {
  set_has_major_subject();
  if (major_subject_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    major_subject_ = new ::std::string;
  }
  major_subject_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.major_subject)
}
inline void school_info::set_major_subject(const void* value, size_t size) {
  set_has_major_subject();
  if (major_subject_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    major_subject_ = new ::std::string;
  }
  major_subject_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.major_subject)
}
inline ::std::string* school_info::mutable_major_subject() {
  set_has_major_subject();
  if (major_subject_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    major_subject_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.major_subject)
  return major_subject_;
}
inline ::std::string* school_info::release_major_subject() {
  clear_has_major_subject();
  if (major_subject_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = major_subject_;
    major_subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_major_subject(::std::string* major_subject) {
  if (major_subject_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete major_subject_;
  }
  if (major_subject) {
    set_has_major_subject();
    major_subject_ = major_subject;
  } else {
    clear_has_major_subject();
    major_subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.major_subject)
}

// optional bytes school_loc_privonce = 7;
inline bool school_info::has_school_loc_privonce() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void school_info::set_has_school_loc_privonce() {
  _has_bits_[0] |= 0x00000040u;
}
inline void school_info::clear_has_school_loc_privonce() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void school_info::clear_school_loc_privonce() {
  if (school_loc_privonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_privonce_->clear();
  }
  clear_has_school_loc_privonce();
}
inline const ::std::string& school_info::school_loc_privonce() const {
  // @@protoc_insertion_point(field_get:common.school_info.school_loc_privonce)
  return *school_loc_privonce_;
}
inline void school_info::set_school_loc_privonce(const ::std::string& value) {
  set_has_school_loc_privonce();
  if (school_loc_privonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_privonce_ = new ::std::string;
  }
  school_loc_privonce_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.school_loc_privonce)
}
inline void school_info::set_school_loc_privonce(const char* value) {
  set_has_school_loc_privonce();
  if (school_loc_privonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_privonce_ = new ::std::string;
  }
  school_loc_privonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.school_loc_privonce)
}
inline void school_info::set_school_loc_privonce(const void* value, size_t size) {
  set_has_school_loc_privonce();
  if (school_loc_privonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_privonce_ = new ::std::string;
  }
  school_loc_privonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.school_loc_privonce)
}
inline ::std::string* school_info::mutable_school_loc_privonce() {
  set_has_school_loc_privonce();
  if (school_loc_privonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_privonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.school_loc_privonce)
  return school_loc_privonce_;
}
inline ::std::string* school_info::release_school_loc_privonce() {
  clear_has_school_loc_privonce();
  if (school_loc_privonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = school_loc_privonce_;
    school_loc_privonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_school_loc_privonce(::std::string* school_loc_privonce) {
  if (school_loc_privonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete school_loc_privonce_;
  }
  if (school_loc_privonce) {
    set_has_school_loc_privonce();
    school_loc_privonce_ = school_loc_privonce;
  } else {
    clear_has_school_loc_privonce();
    school_loc_privonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.school_loc_privonce)
}

// optional bytes school_loc_city = 8;
inline bool school_info::has_school_loc_city() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void school_info::set_has_school_loc_city() {
  _has_bits_[0] |= 0x00000080u;
}
inline void school_info::clear_has_school_loc_city() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void school_info::clear_school_loc_city() {
  if (school_loc_city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_city_->clear();
  }
  clear_has_school_loc_city();
}
inline const ::std::string& school_info::school_loc_city() const {
  // @@protoc_insertion_point(field_get:common.school_info.school_loc_city)
  return *school_loc_city_;
}
inline void school_info::set_school_loc_city(const ::std::string& value) {
  set_has_school_loc_city();
  if (school_loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_city_ = new ::std::string;
  }
  school_loc_city_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.school_loc_city)
}
inline void school_info::set_school_loc_city(const char* value) {
  set_has_school_loc_city();
  if (school_loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_city_ = new ::std::string;
  }
  school_loc_city_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.school_loc_city)
}
inline void school_info::set_school_loc_city(const void* value, size_t size) {
  set_has_school_loc_city();
  if (school_loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_city_ = new ::std::string;
  }
  school_loc_city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.school_loc_city)
}
inline ::std::string* school_info::mutable_school_loc_city() {
  set_has_school_loc_city();
  if (school_loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.school_loc_city)
  return school_loc_city_;
}
inline ::std::string* school_info::release_school_loc_city() {
  clear_has_school_loc_city();
  if (school_loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = school_loc_city_;
    school_loc_city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_school_loc_city(::std::string* school_loc_city) {
  if (school_loc_city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete school_loc_city_;
  }
  if (school_loc_city) {
    set_has_school_loc_city();
    school_loc_city_ = school_loc_city;
  } else {
    clear_has_school_loc_city();
    school_loc_city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.school_loc_city)
}

// optional bytes school_loc_area = 9;
inline bool school_info::has_school_loc_area() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void school_info::set_has_school_loc_area() {
  _has_bits_[0] |= 0x00000100u;
}
inline void school_info::clear_has_school_loc_area() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void school_info::clear_school_loc_area() {
  if (school_loc_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_area_->clear();
  }
  clear_has_school_loc_area();
}
inline const ::std::string& school_info::school_loc_area() const {
  // @@protoc_insertion_point(field_get:common.school_info.school_loc_area)
  return *school_loc_area_;
}
inline void school_info::set_school_loc_area(const ::std::string& value) {
  set_has_school_loc_area();
  if (school_loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_area_ = new ::std::string;
  }
  school_loc_area_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.school_loc_area)
}
inline void school_info::set_school_loc_area(const char* value) {
  set_has_school_loc_area();
  if (school_loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_area_ = new ::std::string;
  }
  school_loc_area_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.school_loc_area)
}
inline void school_info::set_school_loc_area(const void* value, size_t size) {
  set_has_school_loc_area();
  if (school_loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_area_ = new ::std::string;
  }
  school_loc_area_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.school_loc_area)
}
inline ::std::string* school_info::mutable_school_loc_area() {
  set_has_school_loc_area();
  if (school_loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_loc_area_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.school_loc_area)
  return school_loc_area_;
}
inline ::std::string* school_info::release_school_loc_area() {
  clear_has_school_loc_area();
  if (school_loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = school_loc_area_;
    school_loc_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_school_loc_area(::std::string* school_loc_area) {
  if (school_loc_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete school_loc_area_;
  }
  if (school_loc_area) {
    set_has_school_loc_area();
    school_loc_area_ = school_loc_area;
  } else {
    clear_has_school_loc_area();
    school_loc_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.school_loc_area)
}

// optional bytes school_name = 10;
inline bool school_info::has_school_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void school_info::set_has_school_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void school_info::clear_has_school_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void school_info::clear_school_name() {
  if (school_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_name_->clear();
  }
  clear_has_school_name();
}
inline const ::std::string& school_info::school_name() const {
  // @@protoc_insertion_point(field_get:common.school_info.school_name)
  return *school_name_;
}
inline void school_info::set_school_name(const ::std::string& value) {
  set_has_school_name();
  if (school_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_name_ = new ::std::string;
  }
  school_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.school_name)
}
inline void school_info::set_school_name(const char* value) {
  set_has_school_name();
  if (school_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_name_ = new ::std::string;
  }
  school_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.school_name)
}
inline void school_info::set_school_name(const void* value, size_t size) {
  set_has_school_name();
  if (school_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_name_ = new ::std::string;
  }
  school_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.school_name)
}
inline ::std::string* school_info::mutable_school_name() {
  set_has_school_name();
  if (school_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.school_name)
  return school_name_;
}
inline ::std::string* school_info::release_school_name() {
  clear_has_school_name();
  if (school_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = school_name_;
    school_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_school_name(::std::string* school_name) {
  if (school_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete school_name_;
  }
  if (school_name) {
    set_has_school_name();
    school_name_ = school_name;
  } else {
    clear_has_school_name();
    school_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.school_name)
}

// optional bytes school_address = 11;
inline bool school_info::has_school_address() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void school_info::set_has_school_address() {
  _has_bits_[0] |= 0x00000400u;
}
inline void school_info::clear_has_school_address() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void school_info::clear_school_address() {
  if (school_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_address_->clear();
  }
  clear_has_school_address();
}
inline const ::std::string& school_info::school_address() const {
  // @@protoc_insertion_point(field_get:common.school_info.school_address)
  return *school_address_;
}
inline void school_info::set_school_address(const ::std::string& value) {
  set_has_school_address();
  if (school_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_address_ = new ::std::string;
  }
  school_address_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.school_address)
}
inline void school_info::set_school_address(const char* value) {
  set_has_school_address();
  if (school_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_address_ = new ::std::string;
  }
  school_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.school_address)
}
inline void school_info::set_school_address(const void* value, size_t size) {
  set_has_school_address();
  if (school_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_address_ = new ::std::string;
  }
  school_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.school_address)
}
inline ::std::string* school_info::mutable_school_address() {
  set_has_school_address();
  if (school_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    school_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.school_address)
  return school_address_;
}
inline ::std::string* school_info::release_school_address() {
  clear_has_school_address();
  if (school_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = school_address_;
    school_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_school_address(::std::string* school_address) {
  if (school_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete school_address_;
  }
  if (school_address) {
    set_has_school_address();
    school_address_ = school_address;
  } else {
    clear_has_school_address();
    school_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.school_address)
}

// optional bytes educonclusion = 12;
inline bool school_info::has_educonclusion() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void school_info::set_has_educonclusion() {
  _has_bits_[0] |= 0x00000800u;
}
inline void school_info::clear_has_educonclusion() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void school_info::clear_educonclusion() {
  if (educonclusion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educonclusion_->clear();
  }
  clear_has_educonclusion();
}
inline const ::std::string& school_info::educonclusion() const {
  // @@protoc_insertion_point(field_get:common.school_info.educonclusion)
  return *educonclusion_;
}
inline void school_info::set_educonclusion(const ::std::string& value) {
  set_has_educonclusion();
  if (educonclusion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educonclusion_ = new ::std::string;
  }
  educonclusion_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.educonclusion)
}
inline void school_info::set_educonclusion(const char* value) {
  set_has_educonclusion();
  if (educonclusion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educonclusion_ = new ::std::string;
  }
  educonclusion_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.educonclusion)
}
inline void school_info::set_educonclusion(const void* value, size_t size) {
  set_has_educonclusion();
  if (educonclusion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educonclusion_ = new ::std::string;
  }
  educonclusion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.educonclusion)
}
inline ::std::string* school_info::mutable_educonclusion() {
  set_has_educonclusion();
  if (educonclusion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educonclusion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.educonclusion)
  return educonclusion_;
}
inline ::std::string* school_info::release_educonclusion() {
  clear_has_educonclusion();
  if (educonclusion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = educonclusion_;
    educonclusion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_educonclusion(::std::string* educonclusion) {
  if (educonclusion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete educonclusion_;
  }
  if (educonclusion) {
    set_has_educonclusion();
    educonclusion_ = educonclusion;
  } else {
    clear_has_educonclusion();
    educonclusion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.educonclusion)
}

// optional bytes eduform = 13;
inline bool school_info::has_eduform() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void school_info::set_has_eduform() {
  _has_bits_[0] |= 0x00001000u;
}
inline void school_info::clear_has_eduform() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void school_info::clear_eduform() {
  if (eduform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduform_->clear();
  }
  clear_has_eduform();
}
inline const ::std::string& school_info::eduform() const {
  // @@protoc_insertion_point(field_get:common.school_info.eduform)
  return *eduform_;
}
inline void school_info::set_eduform(const ::std::string& value) {
  set_has_eduform();
  if (eduform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduform_ = new ::std::string;
  }
  eduform_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.eduform)
}
inline void school_info::set_eduform(const char* value) {
  set_has_eduform();
  if (eduform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduform_ = new ::std::string;
  }
  eduform_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.eduform)
}
inline void school_info::set_eduform(const void* value, size_t size) {
  set_has_eduform();
  if (eduform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduform_ = new ::std::string;
  }
  eduform_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.eduform)
}
inline ::std::string* school_info::mutable_eduform() {
  set_has_eduform();
  if (eduform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduform_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.eduform)
  return eduform_;
}
inline ::std::string* school_info::release_eduform() {
  clear_has_eduform();
  if (eduform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eduform_;
    eduform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_eduform(::std::string* eduform) {
  if (eduform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eduform_;
  }
  if (eduform) {
    set_has_eduform();
    eduform_ = eduform;
  } else {
    clear_has_eduform();
    eduform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.eduform)
}

// optional bytes edurecord = 14;
inline bool school_info::has_edurecord() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void school_info::set_has_edurecord() {
  _has_bits_[0] |= 0x00002000u;
}
inline void school_info::clear_has_edurecord() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void school_info::clear_edurecord() {
  if (edurecord_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edurecord_->clear();
  }
  clear_has_edurecord();
}
inline const ::std::string& school_info::edurecord() const {
  // @@protoc_insertion_point(field_get:common.school_info.edurecord)
  return *edurecord_;
}
inline void school_info::set_edurecord(const ::std::string& value) {
  set_has_edurecord();
  if (edurecord_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edurecord_ = new ::std::string;
  }
  edurecord_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.edurecord)
}
inline void school_info::set_edurecord(const char* value) {
  set_has_edurecord();
  if (edurecord_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edurecord_ = new ::std::string;
  }
  edurecord_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.edurecord)
}
inline void school_info::set_edurecord(const void* value, size_t size) {
  set_has_edurecord();
  if (edurecord_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edurecord_ = new ::std::string;
  }
  edurecord_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.edurecord)
}
inline ::std::string* school_info::mutable_edurecord() {
  set_has_edurecord();
  if (edurecord_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edurecord_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.edurecord)
  return edurecord_;
}
inline ::std::string* school_info::release_edurecord() {
  clear_has_edurecord();
  if (edurecord_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = edurecord_;
    edurecord_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_edurecord(::std::string* edurecord) {
  if (edurecord_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete edurecord_;
  }
  if (edurecord) {
    set_has_edurecord();
    edurecord_ = edurecord;
  } else {
    clear_has_edurecord();
    edurecord_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.edurecord)
}

// optional bytes eduschool = 15;
inline bool school_info::has_eduschool() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void school_info::set_has_eduschool() {
  _has_bits_[0] |= 0x00004000u;
}
inline void school_info::clear_has_eduschool() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void school_info::clear_eduschool() {
  if (eduschool_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduschool_->clear();
  }
  clear_has_eduschool();
}
inline const ::std::string& school_info::eduschool() const {
  // @@protoc_insertion_point(field_get:common.school_info.eduschool)
  return *eduschool_;
}
inline void school_info::set_eduschool(const ::std::string& value) {
  set_has_eduschool();
  if (eduschool_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduschool_ = new ::std::string;
  }
  eduschool_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.eduschool)
}
inline void school_info::set_eduschool(const char* value) {
  set_has_eduschool();
  if (eduschool_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduschool_ = new ::std::string;
  }
  eduschool_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.eduschool)
}
inline void school_info::set_eduschool(const void* value, size_t size) {
  set_has_eduschool();
  if (eduschool_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduschool_ = new ::std::string;
  }
  eduschool_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.eduschool)
}
inline ::std::string* school_info::mutable_eduschool() {
  set_has_eduschool();
  if (eduschool_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eduschool_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.eduschool)
  return eduschool_;
}
inline ::std::string* school_info::release_eduschool() {
  clear_has_eduschool();
  if (eduschool_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eduschool_;
    eduschool_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_eduschool(::std::string* eduschool) {
  if (eduschool_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eduschool_;
  }
  if (eduschool) {
    set_has_eduschool();
    eduschool_ = eduschool;
  } else {
    clear_has_eduschool();
    eduschool_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.eduschool)
}

// optional bytes edutype = 16;
inline bool school_info::has_edutype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void school_info::set_has_edutype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void school_info::clear_has_edutype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void school_info::clear_edutype() {
  if (edutype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edutype_->clear();
  }
  clear_has_edutype();
}
inline const ::std::string& school_info::edutype() const {
  // @@protoc_insertion_point(field_get:common.school_info.edutype)
  return *edutype_;
}
inline void school_info::set_edutype(const ::std::string& value) {
  set_has_edutype();
  if (edutype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edutype_ = new ::std::string;
  }
  edutype_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.edutype)
}
inline void school_info::set_edutype(const char* value) {
  set_has_edutype();
  if (edutype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edutype_ = new ::std::string;
  }
  edutype_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.edutype)
}
inline void school_info::set_edutype(const void* value, size_t size) {
  set_has_edutype();
  if (edutype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edutype_ = new ::std::string;
  }
  edutype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.edutype)
}
inline ::std::string* school_info::mutable_edutype() {
  set_has_edutype();
  if (edutype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    edutype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.edutype)
  return edutype_;
}
inline ::std::string* school_info::release_edutype() {
  clear_has_edutype();
  if (edutype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = edutype_;
    edutype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_edutype(::std::string* edutype) {
  if (edutype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete edutype_;
  }
  if (edutype) {
    set_has_edutype();
    edutype_ = edutype;
  } else {
    clear_has_edutype();
    edutype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.edutype)
}

// optional bytes source = 18;
inline bool school_info::has_source() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void school_info::set_has_source() {
  _has_bits_[0] |= 0x00010000u;
}
inline void school_info::clear_has_source() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void school_info::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& school_info::source() const {
  // @@protoc_insertion_point(field_get:common.school_info.source)
  return *source_;
}
inline void school_info::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.source)
}
inline void school_info::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.source)
}
inline void school_info::set_source(const void* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.source)
}
inline ::std::string* school_info::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.source)
  return source_;
}
inline ::std::string* school_info::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.source)
}

// optional bytes specialty = 19;
inline bool school_info::has_specialty() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void school_info::set_has_specialty() {
  _has_bits_[0] |= 0x00020000u;
}
inline void school_info::clear_has_specialty() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void school_info::clear_specialty() {
  if (specialty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    specialty_->clear();
  }
  clear_has_specialty();
}
inline const ::std::string& school_info::specialty() const {
  // @@protoc_insertion_point(field_get:common.school_info.specialty)
  return *specialty_;
}
inline void school_info::set_specialty(const ::std::string& value) {
  set_has_specialty();
  if (specialty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    specialty_ = new ::std::string;
  }
  specialty_->assign(value);
  // @@protoc_insertion_point(field_set:common.school_info.specialty)
}
inline void school_info::set_specialty(const char* value) {
  set_has_specialty();
  if (specialty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    specialty_ = new ::std::string;
  }
  specialty_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.school_info.specialty)
}
inline void school_info::set_specialty(const void* value, size_t size) {
  set_has_specialty();
  if (specialty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    specialty_ = new ::std::string;
  }
  specialty_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.school_info.specialty)
}
inline ::std::string* school_info::mutable_specialty() {
  set_has_specialty();
  if (specialty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    specialty_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.school_info.specialty)
  return specialty_;
}
inline ::std::string* school_info::release_specialty() {
  clear_has_specialty();
  if (specialty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = specialty_;
    specialty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void school_info::set_allocated_specialty(::std::string* specialty) {
  if (specialty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete specialty_;
  }
  if (specialty) {
    set_has_specialty();
    specialty_ = specialty;
  } else {
    clear_has_specialty();
    specialty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.school_info.specialty)
}

// -------------------------------------------------------------------

// relation_contact

// optional .common.relation_type relationship = 1;
inline bool relation_contact::has_relationship() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void relation_contact::set_has_relationship() {
  _has_bits_[0] |= 0x00000001u;
}
inline void relation_contact::clear_has_relationship() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void relation_contact::clear_relationship() {
  relationship_ = 1;
  clear_has_relationship();
}
inline ::common::relation_type relation_contact::relationship() const {
  // @@protoc_insertion_point(field_get:common.relation_contact.relationship)
  return static_cast< ::common::relation_type >(relationship_);
}
inline void relation_contact::set_relationship(::common::relation_type value) {
  assert(::common::relation_type_IsValid(value));
  set_has_relationship();
  relationship_ = value;
  // @@protoc_insertion_point(field_set:common.relation_contact.relationship)
}

// optional bytes contact_name = 2;
inline bool relation_contact::has_contact_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void relation_contact::set_has_contact_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void relation_contact::clear_has_contact_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void relation_contact::clear_contact_name() {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_->clear();
  }
  clear_has_contact_name();
}
inline const ::std::string& relation_contact::contact_name() const {
  // @@protoc_insertion_point(field_get:common.relation_contact.contact_name)
  return *contact_name_;
}
inline void relation_contact::set_contact_name(const ::std::string& value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.relation_contact.contact_name)
}
inline void relation_contact::set_contact_name(const char* value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.relation_contact.contact_name)
}
inline void relation_contact::set_contact_name(const void* value, size_t size) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.relation_contact.contact_name)
}
inline ::std::string* relation_contact::mutable_contact_name() {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.relation_contact.contact_name)
  return contact_name_;
}
inline ::std::string* relation_contact::release_contact_name() {
  clear_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_name_;
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void relation_contact::set_allocated_contact_name(::std::string* contact_name) {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_name_;
  }
  if (contact_name) {
    set_has_contact_name();
    contact_name_ = contact_name;
  } else {
    clear_has_contact_name();
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.relation_contact.contact_name)
}

// optional bytes mobilephone = 3;
inline bool relation_contact::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void relation_contact::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void relation_contact::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void relation_contact::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& relation_contact::mobilephone() const {
  // @@protoc_insertion_point(field_get:common.relation_contact.mobilephone)
  return *mobilephone_;
}
inline void relation_contact::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
  // @@protoc_insertion_point(field_set:common.relation_contact.mobilephone)
}
inline void relation_contact::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.relation_contact.mobilephone)
}
inline void relation_contact::set_mobilephone(const void* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.relation_contact.mobilephone)
}
inline ::std::string* relation_contact::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobilephone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.relation_contact.mobilephone)
  return mobilephone_;
}
inline ::std::string* relation_contact::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void relation_contact::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.relation_contact.mobilephone)
}

// -------------------------------------------------------------------

// family_info

// optional .common.marriage_status marriage = 1;
inline bool family_info::has_marriage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_info::set_has_marriage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_info::clear_has_marriage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_info::clear_marriage() {
  marriage_ = 0;
  clear_has_marriage();
}
inline ::common::marriage_status family_info::marriage() const {
  // @@protoc_insertion_point(field_get:common.family_info.marriage)
  return static_cast< ::common::marriage_status >(marriage_);
}
inline void family_info::set_marriage(::common::marriage_status value) {
  assert(::common::marriage_status_IsValid(value));
  set_has_marriage();
  marriage_ = value;
  // @@protoc_insertion_point(field_set:common.family_info.marriage)
}

// optional bool childred_status = 2;
inline bool family_info::has_childred_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_info::set_has_childred_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_info::clear_has_childred_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_info::clear_childred_status() {
  childred_status_ = false;
  clear_has_childred_status();
}
inline bool family_info::childred_status() const {
  // @@protoc_insertion_point(field_get:common.family_info.childred_status)
  return childred_status_;
}
inline void family_info::set_childred_status(bool value) {
  set_has_childred_status();
  childred_status_ = value;
  // @@protoc_insertion_point(field_set:common.family_info.childred_status)
}

// repeated .common.relation_contact contact_list = 3;
inline int family_info::contact_list_size() const {
  return contact_list_.size();
}
inline void family_info::clear_contact_list() {
  contact_list_.Clear();
}
inline const ::common::relation_contact& family_info::contact_list(int index) const {
  // @@protoc_insertion_point(field_get:common.family_info.contact_list)
  return contact_list_.Get(index);
}
inline ::common::relation_contact* family_info::mutable_contact_list(int index) {
  // @@protoc_insertion_point(field_mutable:common.family_info.contact_list)
  return contact_list_.Mutable(index);
}
inline ::common::relation_contact* family_info::add_contact_list() {
  // @@protoc_insertion_point(field_add:common.family_info.contact_list)
  return contact_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::relation_contact >&
family_info::contact_list() const {
  // @@protoc_insertion_point(field_list:common.family_info.contact_list)
  return contact_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::relation_contact >*
family_info::mutable_contact_list() {
  // @@protoc_insertion_point(field_mutable_list:common.family_info.contact_list)
  return &contact_list_;
}

// -------------------------------------------------------------------

// property_info

// optional .common.property_type ptype = 1;
inline bool property_info::has_ptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void property_info::set_has_ptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void property_info::clear_has_ptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void property_info::clear_ptype() {
  ptype_ = 1;
  clear_has_ptype();
}
inline ::common::property_type property_info::ptype() const {
  // @@protoc_insertion_point(field_get:common.property_info.ptype)
  return static_cast< ::common::property_type >(ptype_);
}
inline void property_info::set_ptype(::common::property_type value) {
  assert(::common::property_type_IsValid(value));
  set_has_ptype();
  ptype_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.ptype)
}

// optional int32 valuation = 2;
inline bool property_info::has_valuation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void property_info::set_has_valuation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void property_info::clear_has_valuation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void property_info::clear_valuation() {
  valuation_ = 0;
  clear_has_valuation();
}
inline ::google::protobuf::int32 property_info::valuation() const {
  // @@protoc_insertion_point(field_get:common.property_info.valuation)
  return valuation_;
}
inline void property_info::set_valuation(::google::protobuf::int32 value) {
  set_has_valuation();
  valuation_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.valuation)
}

// optional bool loan_status = 3;
inline bool property_info::has_loan_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void property_info::set_has_loan_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void property_info::clear_has_loan_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void property_info::clear_loan_status() {
  loan_status_ = false;
  clear_has_loan_status();
}
inline bool property_info::loan_status() const {
  // @@protoc_insertion_point(field_get:common.property_info.loan_status)
  return loan_status_;
}
inline void property_info::set_loan_status(bool value) {
  set_has_loan_status();
  loan_status_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.loan_status)
}

// optional int32 debt_info = 4;
inline bool property_info::has_debt_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void property_info::set_has_debt_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void property_info::clear_has_debt_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void property_info::clear_debt_info() {
  debt_info_ = 0;
  clear_has_debt_info();
}
inline ::google::protobuf::int32 property_info::debt_info() const {
  // @@protoc_insertion_point(field_get:common.property_info.debt_info)
  return debt_info_;
}
inline void property_info::set_debt_info(::google::protobuf::int32 value) {
  set_has_debt_info();
  debt_info_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.debt_info)
}

// optional int32 age_limit = 5;
inline bool property_info::has_age_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void property_info::set_has_age_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void property_info::clear_has_age_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void property_info::clear_age_limit() {
  age_limit_ = 0;
  clear_has_age_limit();
}
inline ::google::protobuf::int32 property_info::age_limit() const {
  // @@protoc_insertion_point(field_get:common.property_info.age_limit)
  return age_limit_;
}
inline void property_info::set_age_limit(::google::protobuf::int32 value) {
  set_has_age_limit();
  age_limit_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.age_limit)
}

// optional bytes loc_province = 6;
inline bool property_info::has_loc_province() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void property_info::set_has_loc_province() {
  _has_bits_[0] |= 0x00000020u;
}
inline void property_info::clear_has_loc_province() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void property_info::clear_loc_province() {
  if (loc_province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_province_->clear();
  }
  clear_has_loc_province();
}
inline const ::std::string& property_info::loc_province() const {
  // @@protoc_insertion_point(field_get:common.property_info.loc_province)
  return *loc_province_;
}
inline void property_info::set_loc_province(const ::std::string& value) {
  set_has_loc_province();
  if (loc_province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_province_ = new ::std::string;
  }
  loc_province_->assign(value);
  // @@protoc_insertion_point(field_set:common.property_info.loc_province)
}
inline void property_info::set_loc_province(const char* value) {
  set_has_loc_province();
  if (loc_province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_province_ = new ::std::string;
  }
  loc_province_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.property_info.loc_province)
}
inline void property_info::set_loc_province(const void* value, size_t size) {
  set_has_loc_province();
  if (loc_province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_province_ = new ::std::string;
  }
  loc_province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.property_info.loc_province)
}
inline ::std::string* property_info::mutable_loc_province() {
  set_has_loc_province();
  if (loc_province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.property_info.loc_province)
  return loc_province_;
}
inline ::std::string* property_info::release_loc_province() {
  clear_has_loc_province();
  if (loc_province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loc_province_;
    loc_province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void property_info::set_allocated_loc_province(::std::string* loc_province) {
  if (loc_province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loc_province_;
  }
  if (loc_province) {
    set_has_loc_province();
    loc_province_ = loc_province;
  } else {
    clear_has_loc_province();
    loc_province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.property_info.loc_province)
}

// optional bytes loc_city = 7;
inline bool property_info::has_loc_city() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void property_info::set_has_loc_city() {
  _has_bits_[0] |= 0x00000040u;
}
inline void property_info::clear_has_loc_city() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void property_info::clear_loc_city() {
  if (loc_city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_city_->clear();
  }
  clear_has_loc_city();
}
inline const ::std::string& property_info::loc_city() const {
  // @@protoc_insertion_point(field_get:common.property_info.loc_city)
  return *loc_city_;
}
inline void property_info::set_loc_city(const ::std::string& value) {
  set_has_loc_city();
  if (loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_city_ = new ::std::string;
  }
  loc_city_->assign(value);
  // @@protoc_insertion_point(field_set:common.property_info.loc_city)
}
inline void property_info::set_loc_city(const char* value) {
  set_has_loc_city();
  if (loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_city_ = new ::std::string;
  }
  loc_city_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.property_info.loc_city)
}
inline void property_info::set_loc_city(const void* value, size_t size) {
  set_has_loc_city();
  if (loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_city_ = new ::std::string;
  }
  loc_city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.property_info.loc_city)
}
inline ::std::string* property_info::mutable_loc_city() {
  set_has_loc_city();
  if (loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.property_info.loc_city)
  return loc_city_;
}
inline ::std::string* property_info::release_loc_city() {
  clear_has_loc_city();
  if (loc_city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loc_city_;
    loc_city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void property_info::set_allocated_loc_city(::std::string* loc_city) {
  if (loc_city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loc_city_;
  }
  if (loc_city) {
    set_has_loc_city();
    loc_city_ = loc_city;
  } else {
    clear_has_loc_city();
    loc_city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.property_info.loc_city)
}

// optional bytes loc_area = 8;
inline bool property_info::has_loc_area() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void property_info::set_has_loc_area() {
  _has_bits_[0] |= 0x00000080u;
}
inline void property_info::clear_has_loc_area() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void property_info::clear_loc_area() {
  if (loc_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_area_->clear();
  }
  clear_has_loc_area();
}
inline const ::std::string& property_info::loc_area() const {
  // @@protoc_insertion_point(field_get:common.property_info.loc_area)
  return *loc_area_;
}
inline void property_info::set_loc_area(const ::std::string& value) {
  set_has_loc_area();
  if (loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_area_ = new ::std::string;
  }
  loc_area_->assign(value);
  // @@protoc_insertion_point(field_set:common.property_info.loc_area)
}
inline void property_info::set_loc_area(const char* value) {
  set_has_loc_area();
  if (loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_area_ = new ::std::string;
  }
  loc_area_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.property_info.loc_area)
}
inline void property_info::set_loc_area(const void* value, size_t size) {
  set_has_loc_area();
  if (loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_area_ = new ::std::string;
  }
  loc_area_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.property_info.loc_area)
}
inline ::std::string* property_info::mutable_loc_area() {
  set_has_loc_area();
  if (loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loc_area_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.property_info.loc_area)
  return loc_area_;
}
inline ::std::string* property_info::release_loc_area() {
  clear_has_loc_area();
  if (loc_area_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loc_area_;
    loc_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void property_info::set_allocated_loc_area(::std::string* loc_area) {
  if (loc_area_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loc_area_;
  }
  if (loc_area) {
    set_has_loc_area();
    loc_area_ = loc_area;
  } else {
    clear_has_loc_area();
    loc_area_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.property_info.loc_area)
}

// optional int32 measurement = 9;
inline bool property_info::has_measurement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void property_info::set_has_measurement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void property_info::clear_has_measurement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void property_info::clear_measurement() {
  measurement_ = 0;
  clear_has_measurement();
}
inline ::google::protobuf::int32 property_info::measurement() const {
  // @@protoc_insertion_point(field_get:common.property_info.measurement)
  return measurement_;
}
inline void property_info::set_measurement(::google::protobuf::int32 value) {
  set_has_measurement();
  measurement_ = value;
  // @@protoc_insertion_point(field_set:common.property_info.measurement)
}

// optional bytes extend_info = 10;
inline bool property_info::has_extend_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void property_info::set_has_extend_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void property_info::clear_has_extend_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void property_info::clear_extend_info() {
  if (extend_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extend_info_->clear();
  }
  clear_has_extend_info();
}
inline const ::std::string& property_info::extend_info() const {
  // @@protoc_insertion_point(field_get:common.property_info.extend_info)
  return *extend_info_;
}
inline void property_info::set_extend_info(const ::std::string& value) {
  set_has_extend_info();
  if (extend_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extend_info_ = new ::std::string;
  }
  extend_info_->assign(value);
  // @@protoc_insertion_point(field_set:common.property_info.extend_info)
}
inline void property_info::set_extend_info(const char* value) {
  set_has_extend_info();
  if (extend_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extend_info_ = new ::std::string;
  }
  extend_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.property_info.extend_info)
}
inline void property_info::set_extend_info(const void* value, size_t size) {
  set_has_extend_info();
  if (extend_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extend_info_ = new ::std::string;
  }
  extend_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.property_info.extend_info)
}
inline ::std::string* property_info::mutable_extend_info() {
  set_has_extend_info();
  if (extend_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extend_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.property_info.extend_info)
  return extend_info_;
}
inline ::std::string* property_info::release_extend_info() {
  clear_has_extend_info();
  if (extend_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extend_info_;
    extend_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void property_info::set_allocated_extend_info(::std::string* extend_info) {
  if (extend_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extend_info_;
  }
  if (extend_info) {
    set_has_extend_info();
    extend_info_ = extend_info;
  } else {
    clear_has_extend_info();
    extend_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.property_info.extend_info)
}

// -------------------------------------------------------------------

// work_info

// optional bytes company_name = 1;
inline bool work_info::has_company_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void work_info::set_has_company_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void work_info::clear_has_company_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void work_info::clear_company_name() {
  if (company_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_name_->clear();
  }
  clear_has_company_name();
}
inline const ::std::string& work_info::company_name() const {
  // @@protoc_insertion_point(field_get:common.work_info.company_name)
  return *company_name_;
}
inline void work_info::set_company_name(const ::std::string& value) {
  set_has_company_name();
  if (company_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_name_ = new ::std::string;
  }
  company_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.company_name)
}
inline void work_info::set_company_name(const char* value) {
  set_has_company_name();
  if (company_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_name_ = new ::std::string;
  }
  company_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.company_name)
}
inline void work_info::set_company_name(const void* value, size_t size) {
  set_has_company_name();
  if (company_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_name_ = new ::std::string;
  }
  company_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.company_name)
}
inline ::std::string* work_info::mutable_company_name() {
  set_has_company_name();
  if (company_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.company_name)
  return company_name_;
}
inline ::std::string* work_info::release_company_name() {
  clear_has_company_name();
  if (company_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_name_;
    company_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_company_name(::std::string* company_name) {
  if (company_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_name_;
  }
  if (company_name) {
    set_has_company_name();
    company_name_ = company_name;
  } else {
    clear_has_company_name();
    company_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.company_name)
}

// optional bytes position = 2;
inline bool work_info::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void work_info::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void work_info::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void work_info::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& work_info::position() const {
  // @@protoc_insertion_point(field_get:common.work_info.position)
  return *position_;
}
inline void work_info::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.position)
}
inline void work_info::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.position)
}
inline void work_info::set_position(const void* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.position)
}
inline ::std::string* work_info::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.position)
  return position_;
}
inline ::std::string* work_info::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.position)
}

// optional bytes department = 3;
inline bool work_info::has_department() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void work_info::set_has_department() {
  _has_bits_[0] |= 0x00000004u;
}
inline void work_info::clear_has_department() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void work_info::clear_department() {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_->clear();
  }
  clear_has_department();
}
inline const ::std::string& work_info::department() const {
  // @@protoc_insertion_point(field_get:common.work_info.department)
  return *department_;
}
inline void work_info::set_department(const ::std::string& value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.department)
}
inline void work_info::set_department(const char* value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.department)
}
inline void work_info::set_department(const void* value, size_t size) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.department)
}
inline ::std::string* work_info::mutable_department() {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.department)
  return department_;
}
inline ::std::string* work_info::release_department() {
  clear_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = department_;
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_department(::std::string* department) {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete department_;
  }
  if (department) {
    set_has_department();
    department_ = department;
  } else {
    clear_has_department();
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.department)
}

// optional .common.location_info company_loc = 4;
inline bool work_info::has_company_loc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void work_info::set_has_company_loc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void work_info::clear_has_company_loc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void work_info::clear_company_loc() {
  if (company_loc_ != NULL) company_loc_->::common::location_info::Clear();
  clear_has_company_loc();
}
inline const ::common::location_info& work_info::company_loc() const {
  // @@protoc_insertion_point(field_get:common.work_info.company_loc)
  return company_loc_ != NULL ? *company_loc_ : *default_instance_->company_loc_;
}
inline ::common::location_info* work_info::mutable_company_loc() {
  set_has_company_loc();
  if (company_loc_ == NULL) company_loc_ = new ::common::location_info;
  // @@protoc_insertion_point(field_mutable:common.work_info.company_loc)
  return company_loc_;
}
inline ::common::location_info* work_info::release_company_loc() {
  clear_has_company_loc();
  ::common::location_info* temp = company_loc_;
  company_loc_ = NULL;
  return temp;
}
inline void work_info::set_allocated_company_loc(::common::location_info* company_loc) {
  delete company_loc_;
  company_loc_ = company_loc;
  if (company_loc) {
    set_has_company_loc();
  } else {
    clear_has_company_loc();
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.company_loc)
}

// optional bytes industry = 5;
inline bool work_info::has_industry() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void work_info::set_has_industry() {
  _has_bits_[0] |= 0x00000010u;
}
inline void work_info::clear_has_industry() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void work_info::clear_industry() {
  if (industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_->clear();
  }
  clear_has_industry();
}
inline const ::std::string& work_info::industry() const {
  // @@protoc_insertion_point(field_get:common.work_info.industry)
  return *industry_;
}
inline void work_info::set_industry(const ::std::string& value) {
  set_has_industry();
  if (industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_ = new ::std::string;
  }
  industry_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.industry)
}
inline void work_info::set_industry(const char* value) {
  set_has_industry();
  if (industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_ = new ::std::string;
  }
  industry_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.industry)
}
inline void work_info::set_industry(const void* value, size_t size) {
  set_has_industry();
  if (industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_ = new ::std::string;
  }
  industry_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.industry)
}
inline ::std::string* work_info::mutable_industry() {
  set_has_industry();
  if (industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.industry)
  return industry_;
}
inline ::std::string* work_info::release_industry() {
  clear_has_industry();
  if (industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = industry_;
    industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_industry(::std::string* industry) {
  if (industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete industry_;
  }
  if (industry) {
    set_has_industry();
    industry_ = industry;
  } else {
    clear_has_industry();
    industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.industry)
}

// optional bytes years = 6;
inline bool work_info::has_years() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void work_info::set_has_years() {
  _has_bits_[0] |= 0x00000020u;
}
inline void work_info::clear_has_years() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void work_info::clear_years() {
  if (years_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    years_->clear();
  }
  clear_has_years();
}
inline const ::std::string& work_info::years() const {
  // @@protoc_insertion_point(field_get:common.work_info.years)
  return *years_;
}
inline void work_info::set_years(const ::std::string& value) {
  set_has_years();
  if (years_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    years_ = new ::std::string;
  }
  years_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.years)
}
inline void work_info::set_years(const char* value) {
  set_has_years();
  if (years_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    years_ = new ::std::string;
  }
  years_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.years)
}
inline void work_info::set_years(const void* value, size_t size) {
  set_has_years();
  if (years_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    years_ = new ::std::string;
  }
  years_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.years)
}
inline ::std::string* work_info::mutable_years() {
  set_has_years();
  if (years_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    years_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.years)
  return years_;
}
inline ::std::string* work_info::release_years() {
  clear_has_years();
  if (years_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = years_;
    years_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_years(::std::string* years) {
  if (years_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete years_;
  }
  if (years) {
    set_has_years();
    years_ = years;
  } else {
    clear_has_years();
    years_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.years)
}

// optional bytes income = 7;
inline bool work_info::has_income() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void work_info::set_has_income() {
  _has_bits_[0] |= 0x00000040u;
}
inline void work_info::clear_has_income() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void work_info::clear_income() {
  if (income_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_->clear();
  }
  clear_has_income();
}
inline const ::std::string& work_info::income() const {
  // @@protoc_insertion_point(field_get:common.work_info.income)
  return *income_;
}
inline void work_info::set_income(const ::std::string& value) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(value);
  // @@protoc_insertion_point(field_set:common.work_info.income)
}
inline void work_info::set_income(const char* value) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.work_info.income)
}
inline void work_info::set_income(const void* value, size_t size) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.work_info.income)
}
inline ::std::string* work_info::mutable_income() {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.work_info.income)
  return income_;
}
inline ::std::string* work_info::release_income() {
  clear_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = income_;
    income_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void work_info::set_allocated_income(::std::string* income) {
  if (income_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete income_;
  }
  if (income) {
    set_has_income();
    income_ = income;
  } else {
    clear_has_income();
    income_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.income)
}

// optional .common.location_info work_loc = 8;
inline bool work_info::has_work_loc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void work_info::set_has_work_loc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void work_info::clear_has_work_loc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void work_info::clear_work_loc() {
  if (work_loc_ != NULL) work_loc_->::common::location_info::Clear();
  clear_has_work_loc();
}
inline const ::common::location_info& work_info::work_loc() const {
  // @@protoc_insertion_point(field_get:common.work_info.work_loc)
  return work_loc_ != NULL ? *work_loc_ : *default_instance_->work_loc_;
}
inline ::common::location_info* work_info::mutable_work_loc() {
  set_has_work_loc();
  if (work_loc_ == NULL) work_loc_ = new ::common::location_info;
  // @@protoc_insertion_point(field_mutable:common.work_info.work_loc)
  return work_loc_;
}
inline ::common::location_info* work_info::release_work_loc() {
  clear_has_work_loc();
  ::common::location_info* temp = work_loc_;
  work_loc_ = NULL;
  return temp;
}
inline void work_info::set_allocated_work_loc(::common::location_info* work_loc) {
  delete work_loc_;
  work_loc_ = work_loc;
  if (work_loc) {
    set_has_work_loc();
  } else {
    clear_has_work_loc();
  }
  // @@protoc_insertion_point(field_set_allocated:common.work_info.work_loc)
}

// -------------------------------------------------------------------

// card_info

// optional bytes bankcode = 1;
inline bool card_info::has_bankcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void card_info::set_has_bankcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void card_info::clear_has_bankcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void card_info::clear_bankcode() {
  if (bankcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankcode_->clear();
  }
  clear_has_bankcode();
}
inline const ::std::string& card_info::bankcode() const {
  // @@protoc_insertion_point(field_get:common.card_info.bankcode)
  return *bankcode_;
}
inline void card_info::set_bankcode(const ::std::string& value) {
  set_has_bankcode();
  if (bankcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankcode_ = new ::std::string;
  }
  bankcode_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.bankcode)
}
inline void card_info::set_bankcode(const char* value) {
  set_has_bankcode();
  if (bankcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankcode_ = new ::std::string;
  }
  bankcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.bankcode)
}
inline void card_info::set_bankcode(const void* value, size_t size) {
  set_has_bankcode();
  if (bankcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankcode_ = new ::std::string;
  }
  bankcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.bankcode)
}
inline ::std::string* card_info::mutable_bankcode() {
  set_has_bankcode();
  if (bankcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.bankcode)
  return bankcode_;
}
inline ::std::string* card_info::release_bankcode() {
  clear_has_bankcode();
  if (bankcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bankcode_;
    bankcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_bankcode(::std::string* bankcode) {
  if (bankcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bankcode_;
  }
  if (bankcode) {
    set_has_bankcode();
    bankcode_ = bankcode;
  } else {
    clear_has_bankcode();
    bankcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.bankcode)
}

// optional bytes cardno = 2;
inline bool card_info::has_cardno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void card_info::set_has_cardno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void card_info::clear_has_cardno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void card_info::clear_cardno() {
  if (cardno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cardno_->clear();
  }
  clear_has_cardno();
}
inline const ::std::string& card_info::cardno() const {
  // @@protoc_insertion_point(field_get:common.card_info.cardno)
  return *cardno_;
}
inline void card_info::set_cardno(const ::std::string& value) {
  set_has_cardno();
  if (cardno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cardno_ = new ::std::string;
  }
  cardno_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.cardno)
}
inline void card_info::set_cardno(const char* value) {
  set_has_cardno();
  if (cardno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cardno_ = new ::std::string;
  }
  cardno_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.cardno)
}
inline void card_info::set_cardno(const void* value, size_t size) {
  set_has_cardno();
  if (cardno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cardno_ = new ::std::string;
  }
  cardno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.cardno)
}
inline ::std::string* card_info::mutable_cardno() {
  set_has_cardno();
  if (cardno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cardno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.cardno)
  return cardno_;
}
inline ::std::string* card_info::release_cardno() {
  clear_has_cardno();
  if (cardno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cardno_;
    cardno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_cardno(::std::string* cardno) {
  if (cardno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cardno_;
  }
  if (cardno) {
    set_has_cardno();
    cardno_ = cardno;
  } else {
    clear_has_cardno();
    cardno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.cardno)
}

// optional bytes accountname = 3;
inline bool card_info::has_accountname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void card_info::set_has_accountname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void card_info::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void card_info::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& card_info::accountname() const {
  // @@protoc_insertion_point(field_get:common.card_info.accountname)
  return *accountname_;
}
inline void card_info::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.accountname)
}
inline void card_info::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.accountname)
}
inline void card_info::set_accountname(const void* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.accountname)
}
inline ::std::string* card_info::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.accountname)
  return accountname_;
}
inline ::std::string* card_info::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.accountname)
}

// optional bytes email = 4;
inline bool card_info::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void card_info::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void card_info::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void card_info::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& card_info::email() const {
  // @@protoc_insertion_point(field_get:common.card_info.email)
  return *email_;
}
inline void card_info::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.email)
}
inline void card_info::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.email)
}
inline void card_info::set_email(const void* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.email)
}
inline ::std::string* card_info::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.email)
  return email_;
}
inline ::std::string* card_info::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.email)
}

// optional double maxLineofcredit = 5;
inline bool card_info::has_maxlineofcredit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void card_info::set_has_maxlineofcredit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void card_info::clear_has_maxlineofcredit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void card_info::clear_maxlineofcredit() {
  maxlineofcredit_ = 0;
  clear_has_maxlineofcredit();
}
inline double card_info::maxlineofcredit() const {
  // @@protoc_insertion_point(field_get:common.card_info.maxLineofcredit)
  return maxlineofcredit_;
}
inline void card_info::set_maxlineofcredit(double value) {
  set_has_maxlineofcredit();
  maxlineofcredit_ = value;
  // @@protoc_insertion_point(field_set:common.card_info.maxLineofcredit)
}

// optional double maxreturnamount = 6;
inline bool card_info::has_maxreturnamount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void card_info::set_has_maxreturnamount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void card_info::clear_has_maxreturnamount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void card_info::clear_maxreturnamount() {
  maxreturnamount_ = 0;
  clear_has_maxreturnamount();
}
inline double card_info::maxreturnamount() const {
  // @@protoc_insertion_point(field_get:common.card_info.maxreturnamount)
  return maxreturnamount_;
}
inline void card_info::set_maxreturnamount(double value) {
  set_has_maxreturnamount();
  maxreturnamount_ = value;
  // @@protoc_insertion_point(field_set:common.card_info.maxreturnamount)
}

// optional bytes verifytime = 7;
inline bool card_info::has_verifytime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void card_info::set_has_verifytime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void card_info::clear_has_verifytime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void card_info::clear_verifytime() {
  if (verifytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verifytime_->clear();
  }
  clear_has_verifytime();
}
inline const ::std::string& card_info::verifytime() const {
  // @@protoc_insertion_point(field_get:common.card_info.verifytime)
  return *verifytime_;
}
inline void card_info::set_verifytime(const ::std::string& value) {
  set_has_verifytime();
  if (verifytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verifytime_ = new ::std::string;
  }
  verifytime_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.verifytime)
}
inline void card_info::set_verifytime(const char* value) {
  set_has_verifytime();
  if (verifytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verifytime_ = new ::std::string;
  }
  verifytime_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.verifytime)
}
inline void card_info::set_verifytime(const void* value, size_t size) {
  set_has_verifytime();
  if (verifytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verifytime_ = new ::std::string;
  }
  verifytime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.verifytime)
}
inline ::std::string* card_info::mutable_verifytime() {
  set_has_verifytime();
  if (verifytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verifytime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.verifytime)
  return verifytime_;
}
inline ::std::string* card_info::release_verifytime() {
  clear_has_verifytime();
  if (verifytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verifytime_;
    verifytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_verifytime(::std::string* verifytime) {
  if (verifytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verifytime_;
  }
  if (verifytime) {
    set_has_verifytime();
    verifytime_ = verifytime;
  } else {
    clear_has_verifytime();
    verifytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.verifytime)
}

// optional bytes createtime = 8;
inline bool card_info::has_createtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void card_info::set_has_createtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void card_info::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void card_info::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& card_info::createtime() const {
  // @@protoc_insertion_point(field_get:common.card_info.createtime)
  return *createtime_;
}
inline void card_info::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.createtime)
}
inline void card_info::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.createtime)
}
inline void card_info::set_createtime(const void* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.createtime)
}
inline ::std::string* card_info::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createtime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.createtime)
  return createtime_;
}
inline ::std::string* card_info::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.createtime)
}

// optional bytes updatetime = 9;
inline bool card_info::has_updatetime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void card_info::set_has_updatetime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void card_info::clear_has_updatetime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void card_info::clear_updatetime() {
  if (updatetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    updatetime_->clear();
  }
  clear_has_updatetime();
}
inline const ::std::string& card_info::updatetime() const {
  // @@protoc_insertion_point(field_get:common.card_info.updatetime)
  return *updatetime_;
}
inline void card_info::set_updatetime(const ::std::string& value) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
  // @@protoc_insertion_point(field_set:common.card_info.updatetime)
}
inline void card_info::set_updatetime(const char* value) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.card_info.updatetime)
}
inline void card_info::set_updatetime(const void* value, size_t size) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.card_info.updatetime)
}
inline ::std::string* card_info::mutable_updatetime() {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    updatetime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.card_info.updatetime)
  return updatetime_;
}
inline ::std::string* card_info::release_updatetime() {
  clear_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = updatetime_;
    updatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void card_info::set_allocated_updatetime(::std::string* updatetime) {
  if (updatetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete updatetime_;
  }
  if (updatetime) {
    set_has_updatetime();
    updatetime_ = updatetime;
  } else {
    clear_has_updatetime();
    updatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.card_info.updatetime)
}

// -------------------------------------------------------------------

// user_info

// optional bytes user_id = 1;
inline bool user_info::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_info::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_info::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_info::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& user_info::user_id() const {
  // @@protoc_insertion_point(field_get:common.user_info.user_id)
  return *user_id_;
}
inline void user_info::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.user_id)
}
inline void user_info::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.user_id)
}
inline void user_info::set_user_id(const void* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.user_id)
}
inline ::std::string* user_info::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.user_id)
  return user_id_;
}
inline ::std::string* user_info::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.user_id)
}

// optional .common.identity_card id_card = 2;
inline bool user_info::has_id_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_info::set_has_id_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_info::clear_has_id_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_info::clear_id_card() {
  if (id_card_ != NULL) id_card_->::common::identity_card::Clear();
  clear_has_id_card();
}
inline const ::common::identity_card& user_info::id_card() const {
  // @@protoc_insertion_point(field_get:common.user_info.id_card)
  return id_card_ != NULL ? *id_card_ : *default_instance_->id_card_;
}
inline ::common::identity_card* user_info::mutable_id_card() {
  set_has_id_card();
  if (id_card_ == NULL) id_card_ = new ::common::identity_card;
  // @@protoc_insertion_point(field_mutable:common.user_info.id_card)
  return id_card_;
}
inline ::common::identity_card* user_info::release_id_card() {
  clear_has_id_card();
  ::common::identity_card* temp = id_card_;
  id_card_ = NULL;
  return temp;
}
inline void user_info::set_allocated_id_card(::common::identity_card* id_card) {
  delete id_card_;
  id_card_ = id_card;
  if (id_card) {
    set_has_id_card();
  } else {
    clear_has_id_card();
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.id_card)
}

// optional bytes real_name = 3;
inline bool user_info::has_real_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_info::set_has_real_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_info::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_info::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& user_info::real_name() const {
  // @@protoc_insertion_point(field_get:common.user_info.real_name)
  return *real_name_;
}
inline void user_info::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.real_name)
}
inline void user_info::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.real_name)
}
inline void user_info::set_real_name(const void* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.real_name)
}
inline ::std::string* user_info::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.real_name)
  return real_name_;
}
inline ::std::string* user_info::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.real_name)
}

// optional bytes user_nickname = 4;
inline bool user_info::has_user_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_info::set_has_user_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_info::clear_has_user_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_info::clear_user_nickname() {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_->clear();
  }
  clear_has_user_nickname();
}
inline const ::std::string& user_info::user_nickname() const {
  // @@protoc_insertion_point(field_get:common.user_info.user_nickname)
  return *user_nickname_;
}
inline void user_info::set_user_nickname(const ::std::string& value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.user_nickname)
}
inline void user_info::set_user_nickname(const char* value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.user_nickname)
}
inline void user_info::set_user_nickname(const void* value, size_t size) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.user_nickname)
}
inline ::std::string* user_info::mutable_user_nickname() {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.user_nickname)
  return user_nickname_;
}
inline ::std::string* user_info::release_user_nickname() {
  clear_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_nickname_;
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_user_nickname(::std::string* user_nickname) {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nickname_;
  }
  if (user_nickname) {
    set_has_user_nickname();
    user_nickname_ = user_nickname;
  } else {
    clear_has_user_nickname();
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.user_nickname)
}

// optional bytes mobile_phone = 5;
inline bool user_info::has_mobile_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_info::set_has_mobile_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_info::clear_has_mobile_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_info::clear_mobile_phone() {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_->clear();
  }
  clear_has_mobile_phone();
}
inline const ::std::string& user_info::mobile_phone() const {
  // @@protoc_insertion_point(field_get:common.user_info.mobile_phone)
  return *mobile_phone_;
}
inline void user_info::set_mobile_phone(const ::std::string& value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.mobile_phone)
}
inline void user_info::set_mobile_phone(const char* value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.mobile_phone)
}
inline void user_info::set_mobile_phone(const void* value, size_t size) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.mobile_phone)
}
inline ::std::string* user_info::mutable_mobile_phone() {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.mobile_phone)
  return mobile_phone_;
}
inline ::std::string* user_info::release_mobile_phone() {
  clear_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_phone_;
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_mobile_phone(::std::string* mobile_phone) {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_phone_;
  }
  if (mobile_phone) {
    set_has_mobile_phone();
    mobile_phone_ = mobile_phone;
  } else {
    clear_has_mobile_phone();
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.mobile_phone)
}

// optional bytes email = 6;
inline bool user_info::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_info::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_info::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_info::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& user_info::email() const {
  // @@protoc_insertion_point(field_get:common.user_info.email)
  return *email_;
}
inline void user_info::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.email)
}
inline void user_info::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.email)
}
inline void user_info::set_email(const void* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.email)
}
inline ::std::string* user_info::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.email)
  return email_;
}
inline ::std::string* user_info::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.email)
}

// optional bytes address = 7;
inline bool user_info::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_info::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_info::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_info::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& user_info::address() const {
  // @@protoc_insertion_point(field_get:common.user_info.address)
  return *address_;
}
inline void user_info::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.address)
}
inline void user_info::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.address)
}
inline void user_info::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.address)
}
inline ::std::string* user_info::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.address)
  return address_;
}
inline ::std::string* user_info::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.address)
}

// optional bytes bank_cart = 8;
inline bool user_info::has_bank_cart() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_info::set_has_bank_cart() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_info::clear_has_bank_cart() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_info::clear_bank_cart() {
  if (bank_cart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_->clear();
  }
  clear_has_bank_cart();
}
inline const ::std::string& user_info::bank_cart() const {
  // @@protoc_insertion_point(field_get:common.user_info.bank_cart)
  return *bank_cart_;
}
inline void user_info::set_bank_cart(const ::std::string& value) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.bank_cart)
}
inline void user_info::set_bank_cart(const char* value) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.bank_cart)
}
inline void user_info::set_bank_cart(const void* value, size_t size) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.bank_cart)
}
inline ::std::string* user_info::mutable_bank_cart() {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.bank_cart)
  return bank_cart_;
}
inline ::std::string* user_info::release_bank_cart() {
  clear_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bank_cart_;
    bank_cart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_bank_cart(::std::string* bank_cart) {
  if (bank_cart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bank_cart_;
  }
  if (bank_cart) {
    set_has_bank_cart();
    bank_cart_ = bank_cart;
  } else {
    clear_has_bank_cart();
    bank_cart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.bank_cart)
}

// optional bytes ip = 9;
inline bool user_info::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_info::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_info::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& user_info::ip() const {
  // @@protoc_insertion_point(field_get:common.user_info.ip)
  return *ip_;
}
inline void user_info::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.ip)
}
inline void user_info::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.ip)
}
inline void user_info::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.ip)
}
inline ::std::string* user_info::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.ip)
  return ip_;
}
inline ::std::string* user_info::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.ip)
}

// optional bytes mac = 10;
inline bool user_info::has_mac() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void user_info::set_has_mac() {
  _has_bits_[0] |= 0x00000200u;
}
inline void user_info::clear_has_mac() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void user_info::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& user_info::mac() const {
  // @@protoc_insertion_point(field_get:common.user_info.mac)
  return *mac_;
}
inline void user_info::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.mac)
}
inline void user_info::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.mac)
}
inline void user_info::set_mac(const void* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.mac)
}
inline ::std::string* user_info::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.mac)
  return mac_;
}
inline ::std::string* user_info::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.mac)
}

// optional bytes imei = 11;
inline bool user_info::has_imei() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void user_info::set_has_imei() {
  _has_bits_[0] |= 0x00000400u;
}
inline void user_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void user_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& user_info::imei() const {
  // @@protoc_insertion_point(field_get:common.user_info.imei)
  return *imei_;
}
inline void user_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.imei)
}
inline void user_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.imei)
}
inline void user_info::set_imei(const void* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.imei)
}
inline ::std::string* user_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.imei)
  return imei_;
}
inline ::std::string* user_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.imei)
}

// optional bytes blackBox = 12;
inline bool user_info::has_blackbox() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void user_info::set_has_blackbox() {
  _has_bits_[0] |= 0x00000800u;
}
inline void user_info::clear_has_blackbox() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void user_info::clear_blackbox() {
  if (blackbox_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_->clear();
  }
  clear_has_blackbox();
}
inline const ::std::string& user_info::blackbox() const {
  // @@protoc_insertion_point(field_get:common.user_info.blackBox)
  return *blackbox_;
}
inline void user_info::set_blackbox(const ::std::string& value) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.blackBox)
}
inline void user_info::set_blackbox(const char* value) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.blackBox)
}
inline void user_info::set_blackbox(const void* value, size_t size) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.blackBox)
}
inline ::std::string* user_info::mutable_blackbox() {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.blackBox)
  return blackbox_;
}
inline ::std::string* user_info::release_blackbox() {
  clear_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blackbox_;
    blackbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_blackbox(::std::string* blackbox) {
  if (blackbox_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blackbox_;
  }
  if (blackbox) {
    set_has_blackbox();
    blackbox_ = blackbox;
  } else {
    clear_has_blackbox();
    blackbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.blackBox)
}

// optional bool is_prove = 13;
inline bool user_info::has_is_prove() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void user_info::set_has_is_prove() {
  _has_bits_[0] |= 0x00001000u;
}
inline void user_info::clear_has_is_prove() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void user_info::clear_is_prove() {
  is_prove_ = false;
  clear_has_is_prove();
}
inline bool user_info::is_prove() const {
  // @@protoc_insertion_point(field_get:common.user_info.is_prove)
  return is_prove_;
}
inline void user_info::set_is_prove(bool value) {
  set_has_is_prove();
  is_prove_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.is_prove)
}

// optional bytes avatar = 14;
inline bool user_info::has_avatar() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void user_info::set_has_avatar() {
  _has_bits_[0] |= 0x00002000u;
}
inline void user_info::clear_has_avatar() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void user_info::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& user_info::avatar() const {
  // @@protoc_insertion_point(field_get:common.user_info.avatar)
  return *avatar_;
}
inline void user_info::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.avatar)
}
inline void user_info::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.avatar)
}
inline void user_info::set_avatar(const void* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.avatar)
}
inline ::std::string* user_info::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.avatar)
  return avatar_;
}
inline ::std::string* user_info::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.avatar)
}

// optional .common.school_info schoolinfo = 15;
inline bool user_info::has_schoolinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void user_info::set_has_schoolinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void user_info::clear_has_schoolinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void user_info::clear_schoolinfo() {
  if (schoolinfo_ != NULL) schoolinfo_->::common::school_info::Clear();
  clear_has_schoolinfo();
}
inline const ::common::school_info& user_info::schoolinfo() const {
  // @@protoc_insertion_point(field_get:common.user_info.schoolinfo)
  return schoolinfo_ != NULL ? *schoolinfo_ : *default_instance_->schoolinfo_;
}
inline ::common::school_info* user_info::mutable_schoolinfo() {
  set_has_schoolinfo();
  if (schoolinfo_ == NULL) schoolinfo_ = new ::common::school_info;
  // @@protoc_insertion_point(field_mutable:common.user_info.schoolinfo)
  return schoolinfo_;
}
inline ::common::school_info* user_info::release_schoolinfo() {
  clear_has_schoolinfo();
  ::common::school_info* temp = schoolinfo_;
  schoolinfo_ = NULL;
  return temp;
}
inline void user_info::set_allocated_schoolinfo(::common::school_info* schoolinfo) {
  delete schoolinfo_;
  schoolinfo_ = schoolinfo;
  if (schoolinfo) {
    set_has_schoolinfo();
  } else {
    clear_has_schoolinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.schoolinfo)
}

// optional .common.family_info family = 16;
inline bool user_info::has_family() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void user_info::set_has_family() {
  _has_bits_[0] |= 0x00008000u;
}
inline void user_info::clear_has_family() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void user_info::clear_family() {
  if (family_ != NULL) family_->::common::family_info::Clear();
  clear_has_family();
}
inline const ::common::family_info& user_info::family() const {
  // @@protoc_insertion_point(field_get:common.user_info.family)
  return family_ != NULL ? *family_ : *default_instance_->family_;
}
inline ::common::family_info* user_info::mutable_family() {
  set_has_family();
  if (family_ == NULL) family_ = new ::common::family_info;
  // @@protoc_insertion_point(field_mutable:common.user_info.family)
  return family_;
}
inline ::common::family_info* user_info::release_family() {
  clear_has_family();
  ::common::family_info* temp = family_;
  family_ = NULL;
  return temp;
}
inline void user_info::set_allocated_family(::common::family_info* family) {
  delete family_;
  family_ = family;
  if (family) {
    set_has_family();
  } else {
    clear_has_family();
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.family)
}

// repeated .common.property_info property = 17;
inline int user_info::property_size() const {
  return property_.size();
}
inline void user_info::clear_property() {
  property_.Clear();
}
inline const ::common::property_info& user_info::property(int index) const {
  // @@protoc_insertion_point(field_get:common.user_info.property)
  return property_.Get(index);
}
inline ::common::property_info* user_info::mutable_property(int index) {
  // @@protoc_insertion_point(field_mutable:common.user_info.property)
  return property_.Mutable(index);
}
inline ::common::property_info* user_info::add_property() {
  // @@protoc_insertion_point(field_add:common.user_info.property)
  return property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::property_info >&
user_info::property() const {
  // @@protoc_insertion_point(field_list:common.user_info.property)
  return property_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::property_info >*
user_info::mutable_property() {
  // @@protoc_insertion_point(field_mutable_list:common.user_info.property)
  return &property_;
}

// optional bytes login_from_others = 18;
inline bool user_info::has_login_from_others() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void user_info::set_has_login_from_others() {
  _has_bits_[0] |= 0x00020000u;
}
inline void user_info::clear_has_login_from_others() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void user_info::clear_login_from_others() {
  if (login_from_others_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_from_others_->clear();
  }
  clear_has_login_from_others();
}
inline const ::std::string& user_info::login_from_others() const {
  // @@protoc_insertion_point(field_get:common.user_info.login_from_others)
  return *login_from_others_;
}
inline void user_info::set_login_from_others(const ::std::string& value) {
  set_has_login_from_others();
  if (login_from_others_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_from_others_ = new ::std::string;
  }
  login_from_others_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.login_from_others)
}
inline void user_info::set_login_from_others(const char* value) {
  set_has_login_from_others();
  if (login_from_others_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_from_others_ = new ::std::string;
  }
  login_from_others_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.login_from_others)
}
inline void user_info::set_login_from_others(const void* value, size_t size) {
  set_has_login_from_others();
  if (login_from_others_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_from_others_ = new ::std::string;
  }
  login_from_others_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.login_from_others)
}
inline ::std::string* user_info::mutable_login_from_others() {
  set_has_login_from_others();
  if (login_from_others_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_from_others_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.login_from_others)
  return login_from_others_;
}
inline ::std::string* user_info::release_login_from_others() {
  clear_has_login_from_others();
  if (login_from_others_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_from_others_;
    login_from_others_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_login_from_others(::std::string* login_from_others) {
  if (login_from_others_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_from_others_;
  }
  if (login_from_others) {
    set_has_login_from_others();
    login_from_others_ = login_from_others;
  } else {
    clear_has_login_from_others();
    login_from_others_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.login_from_others)
}

// optional bytes login_id = 19;
inline bool user_info::has_login_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void user_info::set_has_login_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void user_info::clear_has_login_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void user_info::clear_login_id() {
  if (login_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_id_->clear();
  }
  clear_has_login_id();
}
inline const ::std::string& user_info::login_id() const {
  // @@protoc_insertion_point(field_get:common.user_info.login_id)
  return *login_id_;
}
inline void user_info::set_login_id(const ::std::string& value) {
  set_has_login_id();
  if (login_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_id_ = new ::std::string;
  }
  login_id_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.login_id)
}
inline void user_info::set_login_id(const char* value) {
  set_has_login_id();
  if (login_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_id_ = new ::std::string;
  }
  login_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.login_id)
}
inline void user_info::set_login_id(const void* value, size_t size) {
  set_has_login_id();
  if (login_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_id_ = new ::std::string;
  }
  login_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.login_id)
}
inline ::std::string* user_info::mutable_login_id() {
  set_has_login_id();
  if (login_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.login_id)
  return login_id_;
}
inline ::std::string* user_info::release_login_id() {
  clear_has_login_id();
  if (login_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_id_;
    login_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_login_id(::std::string* login_id) {
  if (login_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_id_;
  }
  if (login_id) {
    set_has_login_id();
    login_id_ = login_id;
  } else {
    clear_has_login_id();
    login_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.login_id)
}

// optional bytes user_account = 20;
inline bool user_info::has_user_account() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void user_info::set_has_user_account() {
  _has_bits_[0] |= 0x00080000u;
}
inline void user_info::clear_has_user_account() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void user_info::clear_user_account() {
  if (user_account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_account_->clear();
  }
  clear_has_user_account();
}
inline const ::std::string& user_info::user_account() const {
  // @@protoc_insertion_point(field_get:common.user_info.user_account)
  return *user_account_;
}
inline void user_info::set_user_account(const ::std::string& value) {
  set_has_user_account();
  if (user_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_account_ = new ::std::string;
  }
  user_account_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.user_account)
}
inline void user_info::set_user_account(const char* value) {
  set_has_user_account();
  if (user_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_account_ = new ::std::string;
  }
  user_account_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.user_account)
}
inline void user_info::set_user_account(const void* value, size_t size) {
  set_has_user_account();
  if (user_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_account_ = new ::std::string;
  }
  user_account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.user_account)
}
inline ::std::string* user_info::mutable_user_account() {
  set_has_user_account();
  if (user_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.user_account)
  return user_account_;
}
inline ::std::string* user_info::release_user_account() {
  clear_has_user_account();
  if (user_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_account_;
    user_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_user_account(::std::string* user_account) {
  if (user_account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_account_;
  }
  if (user_account) {
    set_has_user_account();
    user_account_ = user_account;
  } else {
    clear_has_user_account();
    user_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.user_account)
}

// optional .common.tc_user_status user_status = 21;
inline bool user_info::has_user_status() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void user_info::set_has_user_status() {
  _has_bits_[0] |= 0x00100000u;
}
inline void user_info::clear_has_user_status() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void user_info::clear_user_status() {
  user_status_ = 0;
  clear_has_user_status();
}
inline ::common::tc_user_status user_info::user_status() const {
  // @@protoc_insertion_point(field_get:common.user_info.user_status)
  return static_cast< ::common::tc_user_status >(user_status_);
}
inline void user_info::set_user_status(::common::tc_user_status value) {
  assert(::common::tc_user_status_IsValid(value));
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.user_status)
}

// optional .common.sex sex_type = 22;
inline bool user_info::has_sex_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void user_info::set_has_sex_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void user_info::clear_has_sex_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void user_info::clear_sex_type() {
  sex_type_ = 1;
  clear_has_sex_type();
}
inline ::common::sex user_info::sex_type() const {
  // @@protoc_insertion_point(field_get:common.user_info.sex_type)
  return static_cast< ::common::sex >(sex_type_);
}
inline void user_info::set_sex_type(::common::sex value) {
  assert(::common::sex_IsValid(value));
  set_has_sex_type();
  sex_type_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.sex_type)
}

// optional bytes homtown = 23;
inline bool user_info::has_homtown() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void user_info::set_has_homtown() {
  _has_bits_[0] |= 0x00400000u;
}
inline void user_info::clear_has_homtown() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void user_info::clear_homtown() {
  if (homtown_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homtown_->clear();
  }
  clear_has_homtown();
}
inline const ::std::string& user_info::homtown() const {
  // @@protoc_insertion_point(field_get:common.user_info.homtown)
  return *homtown_;
}
inline void user_info::set_homtown(const ::std::string& value) {
  set_has_homtown();
  if (homtown_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homtown_ = new ::std::string;
  }
  homtown_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.homtown)
}
inline void user_info::set_homtown(const char* value) {
  set_has_homtown();
  if (homtown_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homtown_ = new ::std::string;
  }
  homtown_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.homtown)
}
inline void user_info::set_homtown(const void* value, size_t size) {
  set_has_homtown();
  if (homtown_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homtown_ = new ::std::string;
  }
  homtown_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.homtown)
}
inline ::std::string* user_info::mutable_homtown() {
  set_has_homtown();
  if (homtown_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homtown_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.homtown)
  return homtown_;
}
inline ::std::string* user_info::release_homtown() {
  clear_has_homtown();
  if (homtown_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = homtown_;
    homtown_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_homtown(::std::string* homtown) {
  if (homtown_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete homtown_;
  }
  if (homtown) {
    set_has_homtown();
    homtown_ = homtown;
  } else {
    clear_has_homtown();
    homtown_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.homtown)
}

// optional bytes birthday = 24;
inline bool user_info::has_birthday() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void user_info::set_has_birthday() {
  _has_bits_[0] |= 0x00800000u;
}
inline void user_info::clear_has_birthday() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void user_info::clear_birthday() {
  if (birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    birthday_->clear();
  }
  clear_has_birthday();
}
inline const ::std::string& user_info::birthday() const {
  // @@protoc_insertion_point(field_get:common.user_info.birthday)
  return *birthday_;
}
inline void user_info::set_birthday(const ::std::string& value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.birthday)
}
inline void user_info::set_birthday(const char* value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.birthday)
}
inline void user_info::set_birthday(const void* value, size_t size) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.birthday)
}
inline ::std::string* user_info::mutable_birthday() {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    birthday_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.birthday)
  return birthday_;
}
inline ::std::string* user_info::release_birthday() {
  clear_has_birthday();
  if (birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = birthday_;
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_birthday(::std::string* birthday) {
  if (birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete birthday_;
  }
  if (birthday) {
    set_has_birthday();
    birthday_ = birthday;
  } else {
    clear_has_birthday();
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.birthday)
}

// optional .common.location_info living_loc_info = 25;
inline bool user_info::has_living_loc_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void user_info::set_has_living_loc_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void user_info::clear_has_living_loc_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void user_info::clear_living_loc_info() {
  if (living_loc_info_ != NULL) living_loc_info_->::common::location_info::Clear();
  clear_has_living_loc_info();
}
inline const ::common::location_info& user_info::living_loc_info() const {
  // @@protoc_insertion_point(field_get:common.user_info.living_loc_info)
  return living_loc_info_ != NULL ? *living_loc_info_ : *default_instance_->living_loc_info_;
}
inline ::common::location_info* user_info::mutable_living_loc_info() {
  set_has_living_loc_info();
  if (living_loc_info_ == NULL) living_loc_info_ = new ::common::location_info;
  // @@protoc_insertion_point(field_mutable:common.user_info.living_loc_info)
  return living_loc_info_;
}
inline ::common::location_info* user_info::release_living_loc_info() {
  clear_has_living_loc_info();
  ::common::location_info* temp = living_loc_info_;
  living_loc_info_ = NULL;
  return temp;
}
inline void user_info::set_allocated_living_loc_info(::common::location_info* living_loc_info) {
  delete living_loc_info_;
  living_loc_info_ = living_loc_info;
  if (living_loc_info) {
    set_has_living_loc_info();
  } else {
    clear_has_living_loc_info();
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.living_loc_info)
}

// optional int32 age = 26;
inline bool user_info::has_age() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void user_info::set_has_age() {
  _has_bits_[0] |= 0x02000000u;
}
inline void user_info::clear_has_age() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void user_info::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline ::google::protobuf::int32 user_info::age() const {
  // @@protoc_insertion_point(field_get:common.user_info.age)
  return age_;
}
inline void user_info::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.age)
}

// optional .common.work_info work_info_ = 27;
inline bool user_info::has_work_info_() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void user_info::set_has_work_info_() {
  _has_bits_[0] |= 0x04000000u;
}
inline void user_info::clear_has_work_info_() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void user_info::clear_work_info_() {
  if (work_info__ != NULL) work_info__->::common::work_info::Clear();
  clear_has_work_info_();
}
inline const ::common::work_info& user_info::work_info_() const {
  // @@protoc_insertion_point(field_get:common.user_info.work_info_)
  return work_info__ != NULL ? *work_info__ : *default_instance_->work_info__;
}
inline ::common::work_info* user_info::mutable_work_info_() {
  set_has_work_info_();
  if (work_info__ == NULL) work_info__ = new ::common::work_info;
  // @@protoc_insertion_point(field_mutable:common.user_info.work_info_)
  return work_info__;
}
inline ::common::work_info* user_info::release_work_info_() {
  clear_has_work_info_();
  ::common::work_info* temp = work_info__;
  work_info__ = NULL;
  return temp;
}
inline void user_info::set_allocated_work_info_(::common::work_info* work_info_) {
  delete work_info__;
  work_info__ = work_info_;
  if (work_info_) {
    set_has_work_info_();
  } else {
    clear_has_work_info_();
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.work_info_)
}

// optional int32 istuandai = 28;
inline bool user_info::has_istuandai() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void user_info::set_has_istuandai() {
  _has_bits_[0] |= 0x08000000u;
}
inline void user_info::clear_has_istuandai() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void user_info::clear_istuandai() {
  istuandai_ = 0;
  clear_has_istuandai();
}
inline ::google::protobuf::int32 user_info::istuandai() const {
  // @@protoc_insertion_point(field_get:common.user_info.istuandai)
  return istuandai_;
}
inline void user_info::set_istuandai(::google::protobuf::int32 value) {
  set_has_istuandai();
  istuandai_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.istuandai)
}

// optional int32 isjcredit = 29;
inline bool user_info::has_isjcredit() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void user_info::set_has_isjcredit() {
  _has_bits_[0] |= 0x10000000u;
}
inline void user_info::clear_has_isjcredit() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void user_info::clear_isjcredit() {
  isjcredit_ = 0;
  clear_has_isjcredit();
}
inline ::google::protobuf::int32 user_info::isjcredit() const {
  // @@protoc_insertion_point(field_get:common.user_info.isjcredit)
  return isjcredit_;
}
inline void user_info::set_isjcredit(::google::protobuf::int32 value) {
  set_has_isjcredit();
  isjcredit_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.isjcredit)
}

// optional int32 isdcredit = 30;
inline bool user_info::has_isdcredit() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void user_info::set_has_isdcredit() {
  _has_bits_[0] |= 0x20000000u;
}
inline void user_info::clear_has_isdcredit() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void user_info::clear_isdcredit() {
  isdcredit_ = 0;
  clear_has_isdcredit();
}
inline ::google::protobuf::int32 user_info::isdcredit() const {
  // @@protoc_insertion_point(field_get:common.user_info.isdcredit)
  return isdcredit_;
}
inline void user_info::set_isdcredit(::google::protobuf::int32 value) {
  set_has_isdcredit();
  isdcredit_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.isdcredit)
}

// optional int32 isverify = 31;
inline bool user_info::has_isverify() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void user_info::set_has_isverify() {
  _has_bits_[0] |= 0x40000000u;
}
inline void user_info::clear_has_isverify() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void user_info::clear_isverify() {
  isverify_ = 0;
  clear_has_isverify();
}
inline ::google::protobuf::int32 user_info::isverify() const {
  // @@protoc_insertion_point(field_get:common.user_info.isverify)
  return isverify_;
}
inline void user_info::set_isverify(::google::protobuf::int32 value) {
  set_has_isverify();
  isverify_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.isverify)
}

// optional int32 educationapplytype = 32;
inline bool user_info::has_educationapplytype() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void user_info::set_has_educationapplytype() {
  _has_bits_[0] |= 0x80000000u;
}
inline void user_info::clear_has_educationapplytype() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void user_info::clear_educationapplytype() {
  educationapplytype_ = 0;
  clear_has_educationapplytype();
}
inline ::google::protobuf::int32 user_info::educationapplytype() const {
  // @@protoc_insertion_point(field_get:common.user_info.educationapplytype)
  return educationapplytype_;
}
inline void user_info::set_educationapplytype(::google::protobuf::int32 value) {
  set_has_educationapplytype();
  educationapplytype_ = value;
  // @@protoc_insertion_point(field_set:common.user_info.educationapplytype)
}

// optional bytes educationapplytime = 33;
inline bool user_info::has_educationapplytime() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void user_info::set_has_educationapplytime() {
  _has_bits_[1] |= 0x00000001u;
}
inline void user_info::clear_has_educationapplytime() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void user_info::clear_educationapplytime() {
  if (educationapplytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationapplytime_->clear();
  }
  clear_has_educationapplytime();
}
inline const ::std::string& user_info::educationapplytime() const {
  // @@protoc_insertion_point(field_get:common.user_info.educationapplytime)
  return *educationapplytime_;
}
inline void user_info::set_educationapplytime(const ::std::string& value) {
  set_has_educationapplytime();
  if (educationapplytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationapplytime_ = new ::std::string;
  }
  educationapplytime_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_info.educationapplytime)
}
inline void user_info::set_educationapplytime(const char* value) {
  set_has_educationapplytime();
  if (educationapplytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationapplytime_ = new ::std::string;
  }
  educationapplytime_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_info.educationapplytime)
}
inline void user_info::set_educationapplytime(const void* value, size_t size) {
  set_has_educationapplytime();
  if (educationapplytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationapplytime_ = new ::std::string;
  }
  educationapplytime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_info.educationapplytime)
}
inline ::std::string* user_info::mutable_educationapplytime() {
  set_has_educationapplytime();
  if (educationapplytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationapplytime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_info.educationapplytime)
  return educationapplytime_;
}
inline ::std::string* user_info::release_educationapplytime() {
  clear_has_educationapplytime();
  if (educationapplytime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = educationapplytime_;
    educationapplytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_educationapplytime(::std::string* educationapplytime) {
  if (educationapplytime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete educationapplytime_;
  }
  if (educationapplytime) {
    set_has_educationapplytime();
    educationapplytime_ = educationapplytime;
  } else {
    clear_has_educationapplytime();
    educationapplytime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_info.educationapplytime)
}

// repeated .common.card_info cardinfo = 34;
inline int user_info::cardinfo_size() const {
  return cardinfo_.size();
}
inline void user_info::clear_cardinfo() {
  cardinfo_.Clear();
}
inline const ::common::card_info& user_info::cardinfo(int index) const {
  // @@protoc_insertion_point(field_get:common.user_info.cardinfo)
  return cardinfo_.Get(index);
}
inline ::common::card_info* user_info::mutable_cardinfo(int index) {
  // @@protoc_insertion_point(field_mutable:common.user_info.cardinfo)
  return cardinfo_.Mutable(index);
}
inline ::common::card_info* user_info::add_cardinfo() {
  // @@protoc_insertion_point(field_add:common.user_info.cardinfo)
  return cardinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::card_info >&
user_info::cardinfo() const {
  // @@protoc_insertion_point(field_list:common.user_info.cardinfo)
  return cardinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::common::card_info >*
user_info::mutable_cardinfo() {
  // @@protoc_insertion_point(field_mutable_list:common.user_info.cardinfo)
  return &cardinfo_;
}

// -------------------------------------------------------------------

// user_basic_identification

// optional bytes identity_card = 1;
inline bool user_basic_identification::has_identity_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_basic_identification::set_has_identity_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_basic_identification::clear_has_identity_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_basic_identification::clear_identity_card() {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_->clear();
  }
  clear_has_identity_card();
}
inline const ::std::string& user_basic_identification::identity_card() const {
  // @@protoc_insertion_point(field_get:common.user_basic_identification.identity_card)
  return *identity_card_;
}
inline void user_basic_identification::set_identity_card(const ::std::string& value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_basic_identification.identity_card)
}
inline void user_basic_identification::set_identity_card(const char* value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_basic_identification.identity_card)
}
inline void user_basic_identification::set_identity_card(const void* value, size_t size) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_basic_identification.identity_card)
}
inline ::std::string* user_basic_identification::mutable_identity_card() {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_basic_identification.identity_card)
  return identity_card_;
}
inline ::std::string* user_basic_identification::release_identity_card() {
  clear_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = identity_card_;
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_identification::set_allocated_identity_card(::std::string* identity_card) {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete identity_card_;
  }
  if (identity_card) {
    set_has_identity_card();
    identity_card_ = identity_card;
  } else {
    clear_has_identity_card();
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_basic_identification.identity_card)
}

// optional bytes mobile_phone = 2;
inline bool user_basic_identification::has_mobile_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_basic_identification::set_has_mobile_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_basic_identification::clear_has_mobile_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_basic_identification::clear_mobile_phone() {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_->clear();
  }
  clear_has_mobile_phone();
}
inline const ::std::string& user_basic_identification::mobile_phone() const {
  // @@protoc_insertion_point(field_get:common.user_basic_identification.mobile_phone)
  return *mobile_phone_;
}
inline void user_basic_identification::set_mobile_phone(const ::std::string& value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_basic_identification.mobile_phone)
}
inline void user_basic_identification::set_mobile_phone(const char* value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_basic_identification.mobile_phone)
}
inline void user_basic_identification::set_mobile_phone(const void* value, size_t size) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_basic_identification.mobile_phone)
}
inline ::std::string* user_basic_identification::mutable_mobile_phone() {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_basic_identification.mobile_phone)
  return mobile_phone_;
}
inline ::std::string* user_basic_identification::release_mobile_phone() {
  clear_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_phone_;
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_identification::set_allocated_mobile_phone(::std::string* mobile_phone) {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_phone_;
  }
  if (mobile_phone) {
    set_has_mobile_phone();
    mobile_phone_ = mobile_phone;
  } else {
    clear_has_mobile_phone();
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_basic_identification.mobile_phone)
}

// optional bytes real_name = 3;
inline bool user_basic_identification::has_real_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_basic_identification::set_has_real_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_basic_identification::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_basic_identification::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& user_basic_identification::real_name() const {
  // @@protoc_insertion_point(field_get:common.user_basic_identification.real_name)
  return *real_name_;
}
inline void user_basic_identification::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set:common.user_basic_identification.real_name)
}
inline void user_basic_identification::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.user_basic_identification.real_name)
}
inline void user_basic_identification::set_real_name(const void* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.user_basic_identification.real_name)
}
inline ::std::string* user_basic_identification::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.user_basic_identification.real_name)
  return real_name_;
}
inline ::std::string* user_basic_identification::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_identification::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.user_basic_identification.real_name)
}

// -------------------------------------------------------------------

// common_ask_header

// optional bytes response_topic = 1;
inline bool common_ask_header::has_response_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void common_ask_header::set_has_response_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void common_ask_header::clear_has_response_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void common_ask_header::clear_response_topic() {
  if (response_topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_topic_->clear();
  }
  clear_has_response_topic();
}
inline const ::std::string& common_ask_header::response_topic() const {
  // @@protoc_insertion_point(field_get:common.common_ask_header.response_topic)
  return *response_topic_;
}
inline void common_ask_header::set_response_topic(const ::std::string& value) {
  set_has_response_topic();
  if (response_topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_topic_ = new ::std::string;
  }
  response_topic_->assign(value);
  // @@protoc_insertion_point(field_set:common.common_ask_header.response_topic)
}
inline void common_ask_header::set_response_topic(const char* value) {
  set_has_response_topic();
  if (response_topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_topic_ = new ::std::string;
  }
  response_topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:common.common_ask_header.response_topic)
}
inline void common_ask_header::set_response_topic(const void* value, size_t size) {
  set_has_response_topic();
  if (response_topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_topic_ = new ::std::string;
  }
  response_topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.common_ask_header.response_topic)
}
inline ::std::string* common_ask_header::mutable_response_topic() {
  set_has_response_topic();
  if (response_topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:common.common_ask_header.response_topic)
  return response_topic_;
}
inline ::std::string* common_ask_header::release_response_topic() {
  clear_has_response_topic();
  if (response_topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_topic_;
    response_topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void common_ask_header::set_allocated_response_topic(::std::string* response_topic) {
  if (response_topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_topic_;
  }
  if (response_topic) {
    set_has_response_topic();
    response_topic_ = response_topic;
  } else {
    clear_has_response_topic();
    response_topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:common.common_ask_header.response_topic)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::common::degree> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::degree>() {
  return ::common::degree_descriptor();
}
template <> struct is_proto_enum< ::common::platform_serial_number> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::platform_serial_number>() {
  return ::common::platform_serial_number_descriptor();
}
template <> struct is_proto_enum< ::common::sex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::sex>() {
  return ::common::sex_descriptor();
}
template <> struct is_proto_enum< ::common::err_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::err_code>() {
  return ::common::err_code_descriptor();
}
template <> struct is_proto_enum< ::common::result_code_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::result_code_type>() {
  return ::common::result_code_type_descriptor();
}
template <> struct is_proto_enum< ::common::user_id_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::user_id_type>() {
  return ::common::user_id_type_descriptor();
}
template <> struct is_proto_enum< ::common::property_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::property_type>() {
  return ::common::property_type_descriptor();
}
template <> struct is_proto_enum< ::common::marriage_status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::marriage_status>() {
  return ::common::marriage_status_descriptor();
}
template <> struct is_proto_enum< ::common::relation_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::relation_type>() {
  return ::common::relation_type_descriptor();
}
template <> struct is_proto_enum< ::common::tc_user_status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::tc_user_status>() {
  return ::common::tc_user_status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
