【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py

【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py















【API】标准库：
https://docs.python.org/2/library/

http://python.usyiyi.cn/python_278/library/index.html  （中文）

python3-cookbook：
http://python3-cookbook.readthedocs.org/zh_CN/latest/

python API： python -m pydoc  -p 12345

【WSGI】
PEP 0333：
https://www.python.org/dev/peps/pep-0333/


【IDLE】
TAB键：提示
Alt-P：前一个
Alt-N: 下一个


python部落：
http://python.freelycode.com/



【整数范围】
32位整数无符号整数：
最大值：2^32-1（11111111111111111111111111111111）  4294967295
最小值：0 （0000 0000 0000 0000 0000 0000 0000 0000）  0

对于有符号的整数：由于第一位是代表符号为的"-",“+”.0正号,1负号
最小值：-2^31 （11111111 11111111 11111111 11111111）  -2147483648
最大值：2^31-1 (01111111 11111111 11111111 11111111)    2147483647


Pypi： python包索引
https://pypi.python.org     defias / Pypi_148091348      yzh87117835@163.com

构建发布文件： python setup.py sdist
将发布安装到本地python副本中： python setup.py install
(至此就可以在本地import 模块名进行使用了)

向PYPI上传代码：
python setup.py  register  仅需一次  使用第1项并输出PYPI上网站上注册的账户
python setup.py sdist upload


【关于异步】
https://segmentfault.com/a/1190000000471602

gevent：
http://xlambda.com/gevent-tutorial/


【XML】
目前而言，Python存取XML有以下四种方法：
　　1.Expat   一个面向流的解析器
　　2.DOM     与SAX比较，DOM典型的缺点是比较慢，消耗更多的内存，因为DOM会将整个XML数读入内存中，并为树
中的第一个节点建立一个对象。使用DOM的好处是你不需要对状态进行追踪，因为每一个节点都知道谁是它的
父节点，谁是子节点。但是DOM用起来有些麻烦。
　　3.SAX     pyhton 标准库包含SAX解析器，SAX是一种典型的极为快速的工具，在解析XML时，不会占用大量内存。
但是这是基于回调机制的，因此在某些数据中，它会调用某些方法进行传递。这意味着必须为数据指定句柄，
以维持自己的状态，这是非常困难的。
　　4.ElementTree   ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少，这里主要
介绍ElementTree

    需要指出的是存取XML的这几项技术并不是Python独创的，Python也是通过借鉴其他语言或者直接从其他语言引入进来的。例如Expat就是一个用C语言开发的、用来解析XML文档的开发库。而SAX最初是由DavidMegginson采用java语言开发的，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。可以应用于任何编程语言。


【pydev】
修改字体：
windows--->preferences--->generral--->apprarance--->colors and fonts --->basic--->text font

【pdb】
python -m pdb demo.py
b（or break）：设置断点；设置函数：b demo.func；设置行数：b demo:14(行数)
n（or next）：执行下一行：Step over，跳过
c（or continue）：执行下一个断点，没有断点则到程序结束：Step filter
s（or step）：进入函数，Step into，单步跳入
r（or return）：跳出函数，Step return
l（or list）：查看当前代码段
q（or quit）：退出当前debug
p（or print）：打印变量值
h（or help）：查看帮助
cl（clear）：清除所有节点
disable [bpnumber[bpnumber]]：将第num个断点失效，enable，失效第10个断点
enable [bpnumber[bpnumber]]：启用第num个断点，enable 10，启用第10个断点
w（where）：打印堆栈信息
a（args）：打印当前函数参数信息
bt：查看调用堆栈
 reload

【pip】
安裝：pip install PackageName

更新：pip install -U PackageName

移除：pip uninstall PackageName

搜索：pip search PackageName

pip install foo 安装包foo
pip uninstall foo 卸载包foo
pip install --upgrade foo 升级包foo
pip show --files foo 显示包foo所在目录
pip list --outdated 列出需要升级的包

help(‘modules’)   列出所有已经安装的模块
help()
modules

PyPI (PythonPackageIndex)是python官方的第三方库的仓库
用easy_install和pip来安装第三方库很方便，它们的原理其实就是从Python的官方源pypi.python.org/pypi 下载到本地，然后解包安装。

如果因为某些原因，访问官方的pypi不稳定，很慢甚至有些还时不时的访问不了，在国内可以使用豆瓣的源http://pypi.douban.com/simple/
使用镜像源很简单，用-i指定就行了：
sudo easy_install -i http://pypi.douban.com/simple/ saltTesting
sudo pip install -i http://pypi.douban.com/simple/ saltTesting




【python字符串与数字的转化】
数字变为字符串 str(4)
字符串变为数字 string.atoi(s,[，base]) //base为进制基数
浮点数转换 string.atof(s)
字符转数字 int(str)

Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。
函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式（如果没有等价的
语法，则会发生SyntaxError 异常） 某对象没有适于人阅读的解释形式的话， str() 会返回与repr()
等同的值。很多类型，诸如数值或链表、字典这样的结构，针对各函数都有着统一的解读方式。字符串和
浮点数，有着独特的解读方式。
repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注
意，在大多数时候有eval(repr(object)) == object。

基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的
__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。

【关于静态方法和类方法】
class MyClass:
    val1 = 'Value 1'
    def __init__(self):
        self.val2 = 'Value 2'

    @staticmethod
    def staticmd():
        print '静态方法，无法访问val1和val2'

    @classmethod
    def classmd(cls):
        print '类方法，类：' + str(cls) + '，val1：' + cls.val1 + '，无法访问val2的值'

静态方法：无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，换个角度来讲，其实就是放在一个类的作用域里的函数而已， 可以被继承。
类方法：可以访问类属性，无法访问实例属性， 可以被继承。
类的静态方法和类方法都可以直接通过类来访问，也可以使用实例来访问

关于类属性：
可采用类来访问类属性，如果实例没有同名的属性的话，也可以用实例来访问
如果要修改类属性的值，必需要通过类来访问，而不是通过实例。因为任何对实例属性的赋值都会创建一个实例属性（如果不存在的话）并且对其赋值



【位运算】
#按位与运算&， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算
operationNumber=7&18
print operationNumber        #输出结果：2

#按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算
operationNumber=7|18
print operationNumber        #输出结果：23   #结题思路和按位与运算的一样，可以参考按位与运算

#按位异或
operationNumber=7^18
print operationNumber        #输出结果：21   #结题思路和按位与运算的一样，可以参考按位与运算

#按位翻转 ~   按位翻转公式: ~x= - (x+1)
operationNumber=~12  #~12=- (12+1) = -13
print operationNumber        #输出结果：-13   #结题思路和按位与运算的一样，可以参考按位与运算

#左移<<
'''
比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。
左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，
即:      左移n个单位相当于乘以2的n次幂
'''
operationNumber=12<<1
print operationNumber        #输出结果：24
operationNumber=3<<3
print operationNumber        #输出结果：24

#右移>>
'''
理解左移以后，右移就很好理解了。
右移是左移的逆运算，将对应的二进制数向右移动。
右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，
即:      右移n个单位相当于除以2的n次幂
'''
operationNumber=12>>1
print operationNumber        #输出结果：6
operationNumber=12>>2
print operationNumber        #输出结果：3


【socket】
Python 提供了两个基本的 socket 模块。
   第一个是 Socket，它提供了标准的 BSD Sockets API。
   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
下面讲的是Socket模块功能
1、Socket 类型
套接字格式：
socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。

socket类型

描述

socket.AF_UNIX

只能够用于单一的Unix系统进程间通信

socket.AF_INET

服务器之间网络通信

socket.AF_INET6

IPv6

socket.SOCK_STREAM

流式socket , for TCP

socket.SOCK_DGRAM

数据报式socket , for UDP

socket.SOCK_RAW

原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_SEQPACKET

可靠的连续数据包服务

创建TCP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

创建UDP Socket：

s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

2、Socket 函数
注意点:
1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。
2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。

socket函数

服务端socket函数

s.bind(address)

将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.

s.listen(backlog)

开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

s.accept()

接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。

客户端socket函数

s.connect(address)

连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

s.connect_ex(adddress)

功能与connect(address)相同，但是成功返回0，失败返回errno的值。

公共socket函数

s.recv(bufsize[,flag])

接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。

s.send(string[,flag])

发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。

s.sendall(string[,flag])

完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。

s.recvfrom(bufsize[.flag])

接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。

s.sendto(string[,flag],address)

发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。

s.close()

关闭套接字。

s.getpeername()

返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。

s.getsockname()

返回套接字自己的地址。通常是一个元组(ipaddr,port)

s.setsockopt(level,optname,value)

设置给定套接字选项的值。

s.getsockopt(level,optname[.buflen])

返回套接字选项的值。

s.settimeout(timeout)

设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）

s.gettimeout()

返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。

s.fileno()

返回套接字的文件描述符。

s.setblocking(flag)

如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。

s.makefile()

创建一个与该套接字相关连的文件

3、socket编程思路
TCP服务端：
1 创建套接字，绑定套接字到本地IP与端口
   # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()
2 开始监听连接                   #s.listen()
3 进入循环，不断接受客户端的连接请求              #s.accept()
4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()
5 传输完毕后，关闭套接字                     #s.close()

TCP客户端:
1 创建套接字，连接远端地址
       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()
2 连接后发送数据和接收数据          # s.sendall(), s.recv()
3 传输完毕后，关闭套接字          #s.close()


【内部类】
>>> class sdf(object):
...    class fds(object):
...      def aaa(self):
...        print 'aaa'
...    def www(self):
...      fdsd = sdf.fds()
...      fdsd.aaa()
...      print 'www'
...
>>> sdfd = sdf()
>>> sdfd.www()
aaa
www

>>> class outter(object):
...   def __init__(self,name):
...     self.name = name
...   def a(self):
...     innerO = self.inner(self)
...     innerO.test()
...
     class inner:
...     out = None
...     def __init__(self, out=None):
...       self.out = out
...     def test(self):
...       print self.out.name
...
>>> t = outter('hello world!')
>>> t.a()
hello world!

【pydoc】
python -m pydoc -p 4567

python -m pydoc -w  Custom_Server Custom_Server.html

例如如何寻找selenium模块帮助服务：
1、在命令行DOC窗口输入：python -m pydoc -p 4567
python -m pydoc表示打开pydoc模块，pydoc是查看python文档的首选工具；-p 4567表示在4567端口上启动server;

2、然后在浏览器中访问http://localhost:4567/，此时应该可以看到python中所有的Modules

3、按ctrl+f，输入selenium,定位到selenium文档的链接，然后点击进入到http://localhost:4567/selenium.html这个页面,这就是selenium文档所在的位置了。接下来便可以根据自己的需要进行查看了。举个例子，如果你想查看Webdriver类的基本方法，可以访问这个页面http://localhost:4567/selenium.webdriver.remote.webdriver.html


【distutils】

distutils - Python自带的基本安装工具, 适用于非常简单的应用场景使用
通过distutils来打包，生成安装包，安装python包等工作，需要编写名为setup.py python脚本文件。如下代码：
Python代码  收藏代码
from distutils.core import setup

setup(
name = "testpackage",
version = "1.0",
description = "Distutils sample distribution testpackage",
packages = ['TestPackage']
)

通过上述代码可以进行打包或生成安装文件，并能进行安装
1.打包：python setup.py sdist
2.安装：python setup.py install
生成了zip包和exe的可执行包，这时就可以通过解开zip包后用python setyp.py install来安装，或者在Windows下直接双击安装。安装完后会在%python_home%\Lib\site-packages下多出此安装包，你就可以爽爽地使用了。

distutils的魔力在于，创建模块分发包时，和安装模块分发包使用的是完全相同的setup.py文件。
% python setup.py build
% python setup.py install
% python setup.py sdist   //源码安装包
% python setup.py bdist_wininst   //Windows下使用
% python setup.py bdist_rpm  //Linux下使用

https://docs.python.org/2/distutils/apiref.html

https://docs.python.org/2.7/distutils/index.html

【pyinstaller】
打包为可执行文件，同时支持windows和linux
一、首先安装pyinstaller
下载地址：http://download.csdn.net/detail/zj910092147/7827835
传统方式：通过命令提示符cd到该解压的目录（和setup.py同一目录），然后输入python setup.py install
或者直接在命令提示符中输入pip install pyinstaller
通过pip list 可以查看你所有安装的包以及包的版本
二、开始打包成exe
1、命令提示符cd 到需要打包的文件的目录
2、直接在命令提示符中输入pyinstaller -F 文件名.py 注意F要大些，呵呵就这么简单
3、打包成功后会出现两个文件夹，其中一个就是所需要的exe文件；
注：若是gui文件可以在输入pyinstaller -F -w文件名.py 其中w是小写，意思就是五命令行窗口，默认的是-c有命令行窗口，当然一般的文件也可以-w，这样命令行窗口就没有了。
三、pyinstaller 的其他常用的参数
--icon=图标路径
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
还有一些可以通过pyinstaller -h 来查看参数

pyinstaller -F --icon="tb.ico" RunTianchengTest.py

ico图标在线转换：http://www.damotou.com/
【py2exe】打包为exe
setup.py:
----------
#coding=utf8
from distutils.core import setup
import py2exe

setup(console=["RunTianchengTest.py"])
build.bat:
----------
python setup.py py2exe
pause

【python-mysql】
查询后中文会正确显示，但在数据库中却是乱码的。经过我从网上查找，发现用一个属性有可搞定：

在Python代码

conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python') 中加一个属性：
 改为：
conn = MySQLdb.Connect(host='localhost', user='root', passwd='root', db='python',charset='utf8')
charset是要跟你数据库的编码一样，如果是数据库是gb2312 ,则写charset='gb2312'。


下面贴一下常用的函数：

然后,这个连接对象也提供了对事务操作的支持,标准的方法
commit() 提交
rollback() 回滚

cursor用来执行命令的方法:
callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数
execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数
executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数
nextset(self):移动到下一个结果集

cursor用来接收返回值的方法:
fetchall(self):接收全部的返回结果行.
fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.
fetchone(self):返回一条结果行.
scroll(self, value, mode='relative'):移动指针到某一行.如果mode='relative',则表示从当前所在行移动value条,如果 mode='absolute',则表示从结果集的第一行移动value条.

#一次插入多条记录
sqli="insert into student values(%s,%s,%s,%s)"
cur.executemany(sqli,[
    ('3','Tom','1 year 1 class','6'),
    ('3','Jack','2 year 1 class','7'),
    ('3','Yaheng','2 year 2 class','7'),
    ])


【python 调用shell命令】

1.用os.system(cmd)   不过取不了返回值
2.用os.popen(cmd)   要得到命令的输出内容，只需再调用下read()或readlines()等 如a=os.popen(cmd).read()
3.用 commands 模块。其实也是对popen的封装。此模块主要有如下方法
commands.getstatusoutput(cmd) 返回(status, output).
commands.getoutput(cmd) 只返回输出结果
commands.getstatus(file) 返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法.
如

>>> import commands>>> commands.getstatusoutput('ls /bin/ls')(0, '/bin/ls')>>> commands.getstatusoutput('cat /bin/junk')(256, 'cat: /bin/junk: No such file or directory')>>> commands.getstatusoutput('/bin/junk')(256, 'sh: /bin/junk: not found')>>> commands.getoutput('ls /bin/ls')'/bin/ls'>>> commands.getstatus('/bin/ls')

【多线程】
python中的thread的一些机制和C/C++不同：
在C/C++中：主线程结束后，其子线程会默认被主线程kill掉
在python中：
在底层的thread模块中，只要主线程结束了，所有的其它线程都会结束，这很明显，主线程结束python将销毁运行时环境，子线程肯定会被结束。
threading模块的线程setDaemon就是为了解决这个问题的，如果setDaemon(True)，那么和之前一样，主线程结束，所有子线程都将结束。如果setDaemon(False)，主线程将等待该线程结束，等同于你调用线程的join方法。


setDaemon()方法。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(True),这个的意思是，把主线程B设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出。 否则即setDaemon(False) 会等待子线程结束，这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。
setDaemon默认为：setDaemon(False)

join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行
原型：join([timeout])   里面的参数时可选的，代表线程运行的最大时间，即如果超过这个时间，不管这个此线程有没有执行完毕都会被回收，然后主线程或函数都会接着执行的。

当对线程要求较高时可考虑使用 -- -微线程 stackless python     greenlet


在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。
守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。


【线程通信、线程安全】
线程之间可以：共享变量
当多个线程同时改变同一个共享变量时，会发送紊乱（表现为操作系统在不同的时间计算而引起计算结果不同） 解决方法：锁lock（互斥锁）
访问共享且缺乏（有限、不能被重复消费）的资源使用：信号量semaphore  (或：python中的队列Queue模块）
对复杂线程同步使用：条件变量Condition  可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池， Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。

多线程之间资源共享访问时，需要注意避免：死锁（方法：1、以一个固定顺序取得锁   2、按照与取得锁相反的顺序释放锁）
改善大流量网站性能使用：线程池：（1、帧听线程来接收和分派客户端连接给工作线程   2、工作线程处理客户端请求   3、处理意外终止的线程


理解 Python 中的多线程：
http://my.oschina.net/leejun2005/blog/179265

【fork】
进程调用fork函数时，操作系统会新建一个子进程，它本质上与父进程完全相同。子进程从父进程继承了多个值的拷贝，比如全局变量和环境变量。两个进程唯一的区别就是fork的返回值。child（子）进程接收返回值为0，而父进程接收子进程的pid作为返回值。调用fork函数后，两个进程并发执行同一个程序。父进程和子进程既并发执行，又相互独立

【僵尸进程】
http://www.cnblogs.com/Anker/p/3271773.html
僵尸进程解决办法：
（1）通过信号机制
（2）fork两次



【日志】
默认情况下，logging将日志打印到屏幕，日志级别为WARNING；
日志级别大小关系为：CRITICAL > ERROR > WARNING > INFO > DEBUG > NOTSET，当然也可以自己定义日志级别。

 site.py 是 python 解释器启动后, 默认加载的一个脚本. 如果使用 python -S 启动的话, 将不会自动加载 site.py

#coding的功能是告诉py文件是什么编码的。也告诉喜欢python的文本编辑器用什么编码保存文件。
所以'中文'的编码就是#coding中的编码。
setdefaultencoding的意思是unicode('中文')时采用的编码。

【enumerate 】

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回（返回list）

【排序】
zdk = [('UPS', 1), ('UPS', 4), ('UPS', 2), ('UPS', 5)]

sorted(zdk,key=lambda x:x[1], reverse=True)  --第二个域降序排序， 默认第一个域升序排序


【名字空间】
globals返回的是当前模块的全局变量 locals返回的是局部变量。
注意，locals返回的是当前所在最小命名空间的局部变量的一个拷贝。比如说在一个函数中调用locals()，那么返回的将是这个函数内部的局部变量。

Python使用叫做名字空间的东西来记录变量的轨迹。名字空间只是一个字典，它的键字就是变量名，字典的值就是那些变
量的值。实际上，名字空间可以象Python的字典一样进行访问

每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数
和局部定义的变量。每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变
量，包括函数、类、其它导入的模块、模块级的变量和常量。还有就是内置名字空间，任何模
块均可访问它，它存放着内置的函数和异常。

当一行代码要使用变量 x 的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：
1.局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python将使用
  这个变量，然后停止搜索。
2.全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python
  将使用这个变量然后停止搜索。
3.内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python将假设 x 是内置函数或变量。

locals 是只读的，globals 不是

python中检测某个变量是否有定义
第一种方法：利用名字空间
'var'   in   locals().keys()

第二种方法：利用异常
try:
    print   var
except   NameError:
    print   'var   not   defined'

def  isset(v):
     try :
         type (eval(v))
      except :
          return   0
      else :
          return   1

if isset('user_name'):
    print 'user_name is defined'
else
    print 'user_name is not defined'

第三种方法：
'var'   in   dir()

【subprocess 】
Python subprocess模块学习总结：http://www.jb51.net/article/48086.htm

【迭代器】
 相关的库

Python内置了一个模块itertools，包含了很多函数用于creating iterators for efficient looping（创建更有效率的循环迭代器），这说明很是霸气，这一小节就来浏览一遍这些函数并留下印象吧，需要这些功能的时候隐约记得这里面有就好。这一小节的内容翻译自itertools模块官方文档。

1. 无限迭代
- count(start, [step])
- 从start开始，以后每个元素都加上step。step默认值为1。
count(10) --> 10 11 12 13 14 ...

- cycle(p)
- 迭代至序列p的最后一个元素后，从p的第一个元素重新开始。
cycle('ABCD') --> A B C D A B C D ...

- repeat(elem [,n])
- 将elem重复n次。如果不指定n，则无限重复。
repeat(10, 3) --> 10 10 10

2. 在最短的序列参数终止时停止迭代
- chain(p, q, ...)
迭代至序列p的最后一个元素后，从q的第一个元素开始，直到所有序列终止。
chain('ABC', 'DEF') --> A B C D E F

- compress(data, selectors)
如果bool(selectors[n])为True，则next()返回data[n]，否则跳过data[n]。
compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

- dropwhile(pred, seq)
当pred对seq[n]的调用返回False时才开始迭代。
dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1

- takewhile(pred, seq)
dropwhile的相反版本。
takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

- ifilter(pred, seq)
内建函数filter的迭代器版本。
ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9

- ifilterfalse(pred, seq)
ifilter的相反版本。
ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8

- imap(func, p, q, ...)
内建函数map的迭代器版本。
imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000

- starmap(func, seq)
将seq的每个元素以变长参数(*args)的形式调用func。
starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

- izip(p, q, ...)
内建函数zip的迭代器版本。
izip('ABCD', 'xy') --> Ax By

- izip_longest(p, q, ..., fillvalue=None)
- izip的取最长序列的版本，短序列将填入fillvalue。
izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

- tee(it, n)
返回n个迭代器it的复制迭代器。

- groupby(iterable[, keyfunc])
这个函数功能类似于SQL的分组。使用groupby前，首先需要使用相同的keyfunc对iterable进行排序，比如调用内建的sorted函数。然后，groupby返回迭代器，每次迭代的元素是元组(key值, iterable中具有相同key值的元素的集合的子迭代器)。或许看看Python的排序指南对理解这个函数有帮助。
groupby([0, 0, 0, 1, 1, 1, 2, 2, 2]) --> (0, (0 0 0)) (1, (1 1 1)) (2, (2 2 2))

3. 组合迭代器
- product(p, q, ... [repeat=1])
笛卡尔积。
product('ABCD', repeat=2) --> AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD

- permutations(p[, r])
去除重复的元素。
permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

- combinations(p, r)
- 排序后去除重复的元素。
combinations('ABCD', 2) --> AB AC AD BC BD CD

- combinations_with_replacement()
排序后，包含重复元素。
combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

【路径 os.path模块】
os.path.abspath(path) #返回绝对路径
os.path.basename(path) #返回文件名
os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。
os.path.dirname(path) #返回文件路径
os.path.exists(path)  #路径存在则返回True,路径损坏返回False
os.path.lexists  #路径存在则返回True,路径损坏也返回True
os.path.expanduser(path)  #把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)  #根据环境变量的值替换path中包含的”$name”和”${name}”
os.path.getatime(path)  #返回最后一次进入此path的时间。
os.path.getmtime(path)  #返回在此path下最后一次修改的时间。
os.path.getctime(path)  #返回path的大小
os.path.getsize(path)  #返回文件大小，如果文件不存在就返回错误
os.path.isabs(path)  #判断是否为绝对路径
os.path.isfile(path)  #判断路径是否为文件
os.path.isdir(path)  #判断路径是否为目录
os.path.islink(path)  #判断路径是否为链接
os.path.ismount(path)  #判断路径是否为挂载点（）
os.path.join(path1[, path2[, ...]])  #把目录和文件名合成一个路径
os.path.normcase(path)  #转换path的大小写和斜杠
os.path.normpath(path)  #规范path字符串形式
os.path.realpath(path)  #返回path的真实路径
os.path.relpath(path[, start])  #从start开始计算相对路径
os.path.samefile(path1, path2)  #判断目录或文件是否相同
os.path.sameopenfile(fp1, fp2)  #判断fp1和fp2是否指向同一文件
os.path.samestat(stat1, stat2)  #判断stat tuple stat1和stat2是否指向同一个文件
os.path.split(path)  #把路径分割成dirname和basename，返回一个元组
os.path.splitdrive(path)   #一般用在windows下，返回驱动器名和路径组成的元组
os.path.splitext(path)  #分割路径，返回路径名和文件扩展名的元组
os.path.splitunc(path)  #把路径分割为加载点与文件
os.path.walk(path, visit, arg)  #遍历path，进入每个目录都调用visit函数，visit函数必须有
3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有
文件名，args则为walk的第三个参数
os.path.supports_unicode_filenames  #设置是否支持unicode路径名


【json】


json.loads('{"1":"2"}')   #注意引号的写法

在使用json.dumps时要注意一个问题
>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"

输出的会是
'中国' 中的ascii 字符码，而不是真正的中文。

这是因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False：

>>> import json
>>> print json.dumps('中国')
"\u4e2d\u56fd"
>>> print json.dumps('中国',ensure_ascii=False)
"中国"
>>>

http://blog.chinaunix.net/uid-20393955-id-3066671.html

自动化测试框架的设计原则： http://blog.chinaunix.net/uid-1829236-id-3236173.html




【编码】

http://www.jb51.net/article/17560.htm

unicode --> str ：
u'My 阿斯蒂芬big title!'.encode('gbk')  #含中文
str(u'My big title!')  或 u'My big title!'.encode('gbk')  #不含中文


unicodestring = u"Hello world"
# 将Unicode转化为普通Python字符串："encode"
utf8string = unicodestring.encode("utf-8")
asciistring = unicodestring.encode("ascii")
isostring = unicodestring.encode("ISO-8859-1")
utf16string = unicodestring.encode("utf-16")
# 将普通Python字符串转化为Unicode："decode"
plainstring1 = unicode(utf8string, "utf-8")
plainstring2 = unicode(asciistring, "ascii")
plainstring3 = unicode(isostring, "ISO-8859-1")
plainstring4 = unicode(utf16string, "utf-16")

原则：windows上所有含中文的字符串使用unicode

# sitecustomize.py (1)
# this file can be anywhere in your Python path,
# but it usually goes in ${pythondir}/lib/site-packages/
import sys
sys.setdefaultencoding('iso-8859-1') (2)

sitecustomize.py 是一个特殊的脚本；Python 会在启动的时候导入它，所以在其中的任何代码都将自动运行。就像注解中提到的那样，它可以放在任何地方 (只要 import 能够找到它)，但是通常它位于 Python 的 lib 目录的 sitepackages 目录中。
setdefaultencoding 函数设置默认编码。Python 会在任何需要将 unicode字符串自动转换为正规字符串的地方，使用这个编码模式


【字典】
不常用方法：
dict.fromkeys(seq[, value]))
创建一个新的字典，键为seq序列中提供的值，每个键的值都为提供的value，不提供时为None



D5 = dict(zip(keyslist, valueslist))   --zip：映射函数

D6 = dict（name='Bob', age=42）

cmp(dict1, dict2)
在向 dict1 中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1 中值比 dict2 中的值大(8080 vs.80)。

快速比较：
a = set([1,2,3])
b = set([1,4,5])
a^b
set([2, 3, 4, 5])

【集合】
a = t | s          # t 和 s的并集

b = t & s          # t 和 s的交集

c = t – s          # 求差集（项在t中，但不在s中）

d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）

http://blog.csdn.net/business122/article/details/7541486


【GUI】
http://www.2cto.com/kf/201009/74917.html

wxPython 界面设计的工具：  BOA   wxFormBuilder

GTK 的工具： Glade


【linux下安装python】
linux上编译安装python2.7.5
1. 下载python2.7.5，保存到 /data/qtongmon/software
http://www.python.org/ftp/python/

2. 解压文件
tar xvf Python-2.7.5.tar.bz2

3. 创建安装目录
mkdir /usr/local/python27

4. 安装python
./configure --prefix=/usr/local/python27
make
make install

5. 修改老版本的ln指向（注意：这里修改后，可能会影响yum的使用）

#mv /usr/bin/python /usr/bin/python2.4.3
#ln -s /usr/local/python27/bin/python /usr/bin/python
ln -s /usr/local/python2.7.10/bin/python /usr/local/bin/python
（PATH环境变量中/usr/local/bin 会在 /usr/bin前面）

解决修改完系统默认python版本后yum不可用的问题
#修改yum文件
vi /usr/bin/yum
将文件头部的
#!/usr/bin/python
改为如下内容
#!/usr/bin/python2.6.6


python频繁连接数据库问题？  连接池

mvc：



【关于杀子线程】
1、是否可以不杀，子线程自己运行结束
2、子线程中循环检查共享标志
3、解除子线程的阻塞
4、信号
5、thread模块exit
6、。。。


[mq]
http://www.01happy.com/python-pika-rabbitmq-summary/
https://www.rabbitmq.com/devtools.html
http://www.searchsoa.com.cn/showcontent_43337.htm
http://lynnkong.iteye.com/blog/1699684


生产者 --- 交换机 --- | --- 队列 ---消费者
对于生产者来说：队列是不可见的，发送消息时指定交换机和/或路由key
对于消费者来说：需要自己定义自己的队列，并将队列绑定到要接收消息的交换机上


[exit]
1. sys.exit(n) 退出程序引发SystemExit异常, 可以捕获异常执行些清理工作. n默认值为0, 表示正常退出. 其他都是非正常退出. 还可以sys.exit("sorry, goodbye!"); 一般主程序中使用此退出.
2. os._exit(n), 直接退出, 不抛异常, 不执行相关清理工作. 常用在子进程的退出.
3. exit()/quit(), 跑出SystemExit异常. 一般在交互式shell中退出时使用.

================================================================================================================================================
【python资源】

试着用它们实现一些东西出来：
• The Django Tutorial 试着用 Django Web Framework 创建一个 web 应用。
• SciPy 如果你对科学，数学，还有工程感兴趣的话。如果你想结合 SciPy 或者别的代码写篇美观
的论文，你还可以看看 Dexy。
• PyGame 看看能不能写出一个带图形界面和声音的游戏出来。
• Pandas 用来做数据处理和分析。
• Natural Language Tool Kit 用来分析文本，以及实现垃圾邮件过滤和自动聊天机器人这样的软
件。
• Requests 学习一下用户端 HTTP 以及 web 知识。
• SimpleCV 让你的计算机看到真实世界里的东西。
• ScraPy 遍历并攫取网站内容。
• Panda3D 设计 3D 图形界面和游戏。
• Kivy 桌面和移动平台的用户界面开发。
• SciKit-Learn 实现机器学习应用。
• Ren’Py 实现交互式角色扮演游戏，和本书中的游戏类似，不过多了图形界面。
• Learn C The Hard Way 等你熟悉 Python 后试着用我写的别的书学习 C 和算法。慢慢来，C
是一门不同的语言，不过很值得学习。



PyCoder’s Weekly：
http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html#

pupy
Pupy是一个远程管理工具（Administration Tool），开源并且支持多个平台。Pupy还内置了一个Python解释器，可以从内存中加载Python包，访问远程Python对象。

pyxley
使用Flask和React.js，快速开发数据面板在网页上显示一个数据面板是与人分享数据科学发现的最直观方法。对R语言来说有Shiny来简化数据科学家开发网页的工作，而Pyxley就相当于Python版的Shiny。使用Pyxley不光不用写HTML、CSS， 你还可以加入自己的JavaScript来进行定制。

【应用范围】
  系统编程，API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具。
  图形处理，有PIL、Tkinter等图形库支持，能方便进行图形处理。
  数学处理，NumPy扩展提供大量与许多标准数学库的接口。
  文本处理，python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。
  数据库编程，程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，Mysql、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的 SQL环境。
  网络编程，提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。
  作为Web应用的开发语言，支持最新的XML技术。
  多媒体应用，Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。

头：
#!/usr/bin/env python
# -*- coding:utf-8 -*-
__author__ = 'shouke'

【常用的库】
  Tkinter———— Python默认的图形界面接口。
  Tkinter是一个和Tk接口的Python模块，Tkinter库提供了对Tk API的接口，它属于Tcl/Tk的GUI工具组。Tcl/Tk是由John Ousterhout发展的书写和图形设备。Tcl(工具命令语言)是个宏语言，用于简化shell下复杂程序的开发，Tk工具包是和Tcl一起开发的， 目的是为了简化用户接口的设计过程。Tk工具包由许多不同的小部件，如一个按钮、一个滚动条等。通过Tk提供的这些小部件，我们就可快速地进行GUI开 发。Perl、Scheme等语言也利用Tk库进行GUI开发。Tkinter是跨平台，在各种平台下都能使用。
  Python Imaging Library(PIL)————python提供强大的图形处理的能力，并提供广泛的图形文件格式支持，该库能进行图形格式的转换、打印和显示。还能进 行一些图形效果的处理，如图形的放大、缩小和旋转等。是Python用户进行图象处理的强有力工具。
  Pmw(Python megawidgets)Python超级GUI组件集————一个在python中利用Tkinter模块构建的高级GUI组件，每个Pmw都合并了一个或多个Tkinter组件，以实现更有用和更复杂的功能。
  PyXML———— 用Python解析和处理XML文档的工具包，包中的4DOM是完全相容于W3C DOM规范的。它包含以下内容：
  xmlproc: 一个符合规范的XML解析器。
  Expat: 一个快速的，非验证的XML解析器。 还有其他
  和他同级别的还有 PyHtml PySGML
  PyGame———— 用于多媒体开发和游戏软件开发的模块。
  PyOpenGL———— 模块封装了“OpenGL应用程序编程接口”，通过该模块python程序员可在程序中集成2D和3D的图形。
  NumPy、NumArray和SAGE———— NumArray是Python的一个扩展库，主要用于处理任意维数的固定类型数组，简单说就是一个矩阵库。它的低层代码使用C来编写，所以速度的优势很 明显。NumPy是Numarray的后继者，用来代替NumArray。SAGE是基于NumPy和其他几个工具所整合成的数学软件包，目标是取代 Magma, Maple, Mathematica和Matlab 这类工具。
  MySQLdb模块———— 用于连接MySQL数据库。还有用于zope的ZMySQLDA模块，通过它就可在zope中连接mysql数据库。
  PyGTK ———— 用于python GUI程序开发的GTK+库。GTK就是用来实现GIMP和Gnome的那个库。有了它，你完全可以自信的尝试自己制造Photoshop
  PyQt ———— 用于python的Qt开发库。QT就是实现了KDE环境的那个库，由一系列的模块组成，有qt, qtcanvas, qtgl, qtnetwork, qtsql, qttable, qtui and qtxml，包含有300个类和超过5750个的函数和方法。PyQt还支持一个叫qtext的模块，它包含一个QScintilla库。该库是 Scintillar编辑器类的Qt接口。
  PyMedia ———— 用于多媒体操作的python模块。它提供了丰富而简单的接口用于多媒体处理(wav, mp3, ogg, avi, divx, dvd, cdda etc)。可在Windows和Linux平台下使用。
  Psyco ———— 一个Python代码加速度器，可使Python代码的执行速度提高到与编译语言一样的水平。
  Python-ldap ———— 提供一组面向对象的API，可方便地在python中访问ldap目录服务，它基于OpenLDAP2.x。
  smtplib模块 ———— 发送电子邮件。
  ftplib模块 ———— 定义了FTP类和一些方法，用以进行客户端的ftp编程。我们可用python编写一个自己的ftp客户端程序，用于下载文件或镜像站点。如果想了解ftp协议的详细内容，请参考RFC959。
  xmpppy模块 ———— Jabber服务器采用开发的XMPP协议，Google Talk也是采用XMPP协议的IM系统。在Python中有一个xmpppy模块支持该协议。也就是说，我们可以通过该模块与Jabber服务器通信，是不是很Cool。
  下面这些就不详细介绍，只列出名字和功能
  adodb ———— ADO数据库连接组件
  bsddb3 ———— BerkeleyDB的连接组件
  chardet ———— 编码检测
  scons ———— 项目构建工具，写好了模板用起来还是很方便的
  sendpkt ———— Python发包
  setuptools ———— 一套python包管理机制
  Cheetah ———— 构建和扩充任何种类的基于文本的内容
  pycurl ———— URL处理工具
  pydot ———— 画图的，graphiz
  pyevent ———— Python的事件支持
  pylint ———— 培养良好的编码习惯
  Pylons ———— 又一个web framework
  pypcap ———— 抓包的
  pysqlite2 ———— SQLite的连接组件
  python-dnet ———— 控制网络安全的其他设备
  pythonwin ———— Python的Windows扩展
  pywmi ———— 省了好多折腾功夫
  reportlab ———— Python操作PDF的Libary。
  scapy ———— 网络包构建分析框架,可编程的wireshark,有兴趣的google “Silver Needle in the Skype”
  simplejson ———— JSON的支持
  sqlalchemy ———— SQL数据库连接池
  SQLObject ———— 数据库连接池
  cherrypy ———— 一个WEB framework
  ctypes ———— 用来调用动态链接库
  Cx-oracle ———— 连接oracle的工具
  DBUtils ———— 数据库连接池
  django ———— 一个WEB framework
  DPKT ———— raw-scoket网络编程
  docutils ———— 用来写文档的
  dpkt ———— 数据包的解包和组包
  feedparser ———— rss解析
  Kodos ———— 正则表达式调试工具
  Mechanize ———— 爬虫连接网站常用
  pefile ———— windows pe文件解析器
  py2exe ———— 用来生成windows可执行文件
  twisted ———— 巨无霸的网络编程框架
  winpdb ———— 自己的程序或者用别的库不太明白的时候就靠它了
  wxPython ———— GUI编程框架,熟悉MFC的人会非常喜欢，简直是同一架构
  PIL———— Python 的图像处理库，可以打开数十种图像格式，还提供许多图像处理函数，如图像增强、滤波算法等。
  Pyro———— Python实现与JAVA RMI类似的技术
  PLY———— 基于Python的LEX、YACC的语言工具
  Corepy———— 使用Python开发编写x86汇编程序
  LightCloud———— Python实现的分布式的键-值数据库
  Parallel Python（PP）———— 轻松开发SMP、集群并行计算的库
Zope-应用服务器
  Plone-内容管理系统
  Django-鼓励快速开发的web framework
  Twisted - Python Network Application Framework Python的网络应用程序框架
  TurboGears - 另一个Web应用快速开发框架
  Bit Torrent - 著名的BT下载工具
  还有很多游戏也是用Python制作的
文件管理 (部分os包，shutil包)
存储对象 (pickle包，cPickle包)
Matplotlib是一个Python的图形框架

【Python开源框架 】
GitHub中整理出了15个最受欢迎的Python开源框架，这些框架包括事件I/O、OLAP、Web开发、高性能网络通信、测试、爬虫等。
1. Django: Python Web应用开发框架
Django应该是最出名的Python框架，GAE甚至Erlang都有框架受它影响。Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。

2. Diesel：基于Greenlet的事件I/O框架
Diesel提供一个整洁的API来编写网络客户端和服务器。支持TCP和UDP。

3. Flask：一个用Python编写的轻量级Web应用框架
Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI工具箱和Jinja2 模板引擎。Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数 据库、窗体验证工具。
flask 轻量! 可以灵活组合各类组件进行开发(第三方组件很丰富), 简单高效, 便于快速开发和维护.

4. Cubes：轻量级Python OLAP框架
Cubes是一个轻量级Python框架，包含OLAP、多维数据分析和浏览聚合数据(aggregated data)等工具。

5. Kartograph.py：创造矢量地图的轻量级Python框架
Kartograph是一个Python库，用来为ESRI生成SVG地图。Kartograph.py目前仍处于beta阶段，你可以在virtualenv环境下来测试。

6. Pulsar：Python的事件驱动并发框架
Pulsar是一个事件驱动的并发框架，有了pulsar，你可以写出在不同进程或线程中运行一个或多个活动的异步服务器。

7. Web2py：全栈式Web框架
Web2py是一个为Python语言提供的全功能Web应用框架，旨在敏捷快速的开发Web应用，具有快速、安全以及可移植的数据库驱动的应用，兼容Google App Engine。

8. Falcon：构建云API和网络应用后端的高性能Python框架
Falcon是一个构建云API的高性能Python框架，它鼓励使用REST架构风格，尽可能以最少的力气做最多的事情。

9. Dpark：Python版的Spark
DPark是Spark的Python克隆，是一个Python实现的分布式计算框架，可以非常方便地实现大规模数据处理和迭代计算。DPark由豆瓣实现，目前豆瓣内部的绝大多数数据分析都使用DPark完成，正日趋完善。

10. Buildbot：基于Python的持续集成测试框架
Buildbot是一个开源框架，可以自动化软件构建、测试和发布等过程。每当代码有改变，服务器要求不同平台上的客户端立即进行代码构建和测试，收集并报告不同平台的构建和测试结果。

11. Zerorpc：基于ZeroMQ的高性能分布式RPC框架
Zerorpc是一个基于ZeroMQ和MessagePack开发的远程过程调用协议(RPC)实现。和 Zerorpc 一起使用的 Service API 被称为 zeroservice。Zerorpc 可以通过编程或命令行方式调用。

12. Bottle：微型Python Web框架
Bottle是一个简单高效的遵循WSGI的微型python Web框架。说微型，是因为它只有一个文件，除Python标准库外，它不依赖于任何第三方模块。

13. Tornado：异步非阻塞IO的Python Web框架
Tornado的全称是Torado Web Server，从名字上看就可知道它可以用作Web服务器，但同时它也是一个Python Web的开发框架。最初是在FriendFeed公司的网站上使用，FaceBook收购了之后便开源了出来。

14. webpy：轻量级的Python Web框架
webpy的设计理念力求精简(Keep it simple and powerful)，源码很简短，只提供一个框架所必须的东西，不依赖大量的第三方模块，它没有URL路由、没有模板也没有数据库的访问。

15. Scrapy：Python的爬虫框架
Scrapy是一个使用Python编写的，轻量级的，简单轻巧，并且使用起来非常的方便。


【Python开源工具】
1. Radon
Radon是一个用于 从源代码中计算出各种指标的 Python工具，包括：
McCabe复杂性计算，也就是循环复杂度
SLOC（ 源代码行 ）、注释行数、空白行数等指标计算
Halstead指标计算
可维护性指数（主要是用在Visual Studio里面）
Radon只需要一个代码库就能在Python 2.6版本到Python 3.3版本之间运行，而且不需要任何辅助工具。除此之外它还能在PyPy上毫无障碍的运行。（目前只提供PyPy 2.0.0测试版本）

2. Django-conch
这是一个非常简洁的项目。Django-conch将Django shell以一个SSH服务器的形象展现出来。如果你想调试远程服务器上的Django应用的话，那该项目已经非常实用了。

3. PuDB
PuDB是一个全屏的基于控制台的Python调试器。
PuDB的目标是以轻量级、便携程序包形式来提供更加先进的基于GUI的调试器。PuDB允许用户在任何地点调试代码，并且在终端位置进行测试。如果你之前使用过DOS-based Turbo Pascal或者是C工具的话，那么PuDB的用户界面看上去会比较熟悉。

4. Python-Social-Auth
Python Social Auth的目标是成为能够认证所有社交服务的利器。该项目目前支持Django、Flask以及Webpy，并且支持许多服务。
通过从Django-Social-Auth那里复制基础代码，然后再精心修改调试，这样就实现了一个通用的接口，从第三方途径定义新的身份验证提供者，并将支持更多的框架和ORM。

5. Motor
该项目是专为Tornado应用编写的MongoDB驱动，功能比较全面，是以非阻塞方式实现的。
Tornado的维护者Ben Darnell表示，“Motor使用一个比较灵活的greenlet-based方式，从一个单一的代码库里完全支持同步和异步接口。广大的用户还是很乐见像MongoDB这样的公司为他们自己的产品生产第一手异步驱动的。”

6. Elephant
该项目是一个基于S3的键值存储和查询工具，并且提供ElasticSearch检索功能。将数据存储在S3里面就像是存储JSON文档一样简单，不过你可以通过HTTP立刻查询它。

7. Sublime-Bower
Sublime-Bower是一个非常酷的工具。现在使用Twitter Bower工具的人可以通过文件包控制来安装Sublime Text 2到项目里。

8. Pony ORM
Pony ORM这个项目挺好玩的，它会把Python的代码翻译成SQL。并且还有一个图形化的编辑器能够把对象模型转换成Python代码。

9. Falcon Framework
Falcon是个高性能的云API框架。与Web框架相比， Falcon号称 它能够提供在相同的硬件上服务超过30倍的请求。有兴趣的可以点击进去试试看。

10. Cherrymusic
该项目是一个用Python编写的音乐流服务器。其特点包含：
免费、开源（GPL协议）
易于安装、下载和运行
快速搜索
便于分享
赶紧把你自己的音乐唱片集推送到你的设备上吧！

11. Smiley
Smiley包含了一些子命令，能够运行Python程序并监控其执行的过程，能够记录运行过程并生成一个报告。

12. Wssh
该项目是Websockets桥接的SSH，可以通过HTTP调用远程SSH shell，总体上非常不错。这里面还包含了一个Web界面以及一个服务器。

13. Babel
Babel是个Python的国际化库，提供了一个集成的集合实用程序，协助国际化和本地化Python应用程序，特别是基于Web的应用程序。

14. RegExpBuilder
RegExpBuilder整合正则表达式到编程语言里，能够使得正则表达式可读性变强，同时易于维护。写正则表达式时，该项目采用了链式方法以及变量，例如数组或字符串。

15. Flask-Restful
该项目只是一个简单的框架，能够在Flask项目中快速地搭建出REST API。

16. Pulsar
如果你正在寻找一个能够很好地支持异步操作的Python Web框架的话，那么Pulsar就非常适合你，这是一个事件驱动的Python并发框架。

17. Quokka
这是一个基于Flask的内容管理系统，该系统还使用了MongoDB数据库。

18. Dejavu
你一定很好奇Shazam到底是怎么实现的吧？那就来看看这个用Python实现的声纹识别算法吧！看看它是怎么 工作 的！
Dejavu只要听一遍就能记住音频，还能通过指纹来进行识别。然后通过播放歌曲和输入麦克风录音，Dejavu就会尝试将这些数据和数据库里的音频、指纹数据进行比对，正确的话就会继续播放歌曲。


微信框架： WeRoBot
web框架:django  flask  tornado  bottle
系统方面：peewee  sqlalchemy
模板引擎：jinja2
图像处理：PillowPython Imaging Library (PIL)
命令行应用：docopt
静态网站生成器: pelican
数据处理：pandas
其他：awesome-python
ORM：SQLAlchemy
代码发布
fabric + rsync

【异常】
python标准异常：
AssertionError 断言语句（assert）失败
AttributeError 尝试访问未知的对象属性
EOFError 用户输入文件末尾标志EOF（Ctrl+d）
FloatingPointError 浮点计算错误
GeneratorExit generator.close()方法被调用的时候
ImportError 导入模块失败的时候
IndexError 索引超出序列的范围
KeyError 字典中查找一个不存在的关键字
KeyboardInterrupt 用户输入中断键（Ctrl+c）
MemoryError 内存溢出（可通过删除对象释放内存）
NameError 尝试访问一个不存在的变量
NotImplementedError 尚未实现的方法
OSError 操作系统产生的异常（例如打开一个不存在的文件）
OverflowError 数值运算超出最大限制
ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象
RuntimeError 一般的运行时错误
StopIteration 迭代器没有更多的值
SyntaxError Python的语法错误
IndentationError 缩进错误
TabError Tab和空格混合使用
SystemError Python编译器系统错误
SystemExit Python编译器进程被关闭
TypeError 不同类型间的无效操作
UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）
UnicodeError Unicode相关的错误（ValueError的子类）
UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）
UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）
UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）
ValueError 传入无效的参数
ZeroDivisionError 除数为零

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
      +-- StopIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

python调试： iPDB  pycallgraph  objgraph
==================================================================================================================
【GAE】
google app engine (GAE)

GAE可以提供我们稳定的免费网站空间，空间支持语言是python、java，数据库是google专有的数据库，数据库和空间可以免费使用1G，超过了1G就要买了，还提供Google的带宽，这个带宽约可以支撑一月500万次访问请求，超过500万次就要买了……对于一般网站这免费的资源就足够了，另外GAE还支持域名绑定，就相当于个人买的虚拟空间一样

GAE python SDK 下载：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python


【装饰器】
http://blog.csdn.net/dreamcoding/article/details/8611578


【知乎】
知乎：值得看的Python的开源项目有哪些？
https://www.zhihu.com/question/19840137


Head First ：
http://www.headfirstlabs.com/books/hfpython/

Head First  python：
http://python.itcarlow.ie/




Python编码注意事项：
1、可以在原位置改变列表和字典，但是不能改变数字、字符串和元组
2、字符串、列表、元组是序列，但字典是散列（无序）
3、对于L[1,2,3]:L为引用，L[:]为拷贝
4、==测试值是否相等，is测试对象的一致性（是否为同一对象，同一地址）
5、对于字典：索引一个不存在的键会出错，赋值一个不存在的键会生成一个新的字典入口；但对于列表：出界索引和出界赋值都会出错
6、try/except/else子句中：可以有任意多的except子句，else最多只能有一个；try/finally子句中：finally只能单独出现（没有except或else时）
7、字典和列表不能作为字典的主键
8、调用函数时一定要带括号---不管函数是否有参数
9、不要在导入和重载中使用扩展名或路径---如：不要写：import mod.py 而是：import mod,但是在系统提示模式下要使用文件扩展名，如：不要写：python sapm 而是：python sapm.py
10、Python区分大小写
11、别忘了冒号
12、从第一行开始---代码的第一行不能缩进
13、缩进要一致---不要在块的缩进中混合制表符和空格，除非你知道文字编辑器是如何处理制表符的
14、不要期待在原处修改的函数会返回结果---在赋值时必须弄清左表达式真正返回的是什么 如:mylist=mylist.append(X)
15、千万不要把源文件名定义为与库名一样，例如：re.py





























