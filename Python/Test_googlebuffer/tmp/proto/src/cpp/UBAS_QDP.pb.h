// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UBAS_QDP.proto

#ifndef PROTOBUF_UBAS_5fQDP_2eproto__INCLUDED
#define PROTOBUF_UBAS_5fQDP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace BUAS_QDP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

class LocationPoint;
class Location2Position_ask;
class LocationInfo;
class Location2Position_ans;
class ZhimaDataFlowReflux_ask;
class LoanRecordInfo;
class AssureRecordInfo;
class ZhimaDataFlowReflux_ans;

enum UserCredentialsType {
  Unknown = 0,
  IDCard = 1
};
bool UserCredentialsType_IsValid(int value);
const UserCredentialsType UserCredentialsType_MIN = Unknown;
const UserCredentialsType UserCredentialsType_MAX = IDCard;
const int UserCredentialsType_ARRAYSIZE = UserCredentialsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserCredentialsType_descriptor();
inline const ::std::string& UserCredentialsType_Name(UserCredentialsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserCredentialsType_descriptor(), value);
}
inline bool UserCredentialsType_Parse(
    const ::std::string& name, UserCredentialsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserCredentialsType>(
    UserCredentialsType_descriptor(), name, value);
}
// ===================================================================

class LocationPoint : public ::google::protobuf::Message {
 public:
  LocationPoint();
  virtual ~LocationPoint();

  LocationPoint(const LocationPoint& from);

  inline LocationPoint& operator=(const LocationPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationPoint& default_instance();

  void Swap(LocationPoint* other);

  // implements Message ----------------------------------------------

  LocationPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationPoint& from);
  void MergeFrom(const LocationPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes lng_lat = 1;
  inline bool has_lng_lat() const;
  inline void clear_lng_lat();
  static const int kLngLatFieldNumber = 1;
  inline const ::std::string& lng_lat() const;
  inline void set_lng_lat(const ::std::string& value);
  inline void set_lng_lat(const char* value);
  inline void set_lng_lat(const void* value, size_t size);
  inline ::std::string* mutable_lng_lat();
  inline ::std::string* release_lng_lat();
  inline void set_allocated_lng_lat(::std::string* lng_lat);

  // optional bytes localID = 2;
  inline bool has_localid() const;
  inline void clear_localid();
  static const int kLocalIDFieldNumber = 2;
  inline const ::std::string& localid() const;
  inline void set_localid(const ::std::string& value);
  inline void set_localid(const char* value);
  inline void set_localid(const void* value, size_t size);
  inline ::std::string* mutable_localid();
  inline ::std::string* release_localid();
  inline void set_allocated_localid(::std::string* localid);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.LocationPoint)
 private:
  inline void set_has_lng_lat();
  inline void clear_has_lng_lat();
  inline void set_has_localid();
  inline void clear_has_localid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* lng_lat_;
  ::std::string* localid_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static LocationPoint* default_instance_;
};
// -------------------------------------------------------------------

class Location2Position_ask : public ::google::protobuf::Message {
 public:
  Location2Position_ask();
  virtual ~Location2Position_ask();

  Location2Position_ask(const Location2Position_ask& from);

  inline Location2Position_ask& operator=(const Location2Position_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location2Position_ask& default_instance();

  void Swap(Location2Position_ask* other);

  // implements Message ----------------------------------------------

  Location2Position_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location2Position_ask& from);
  void MergeFrom(const Location2Position_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BUAS_QDP.LocationPoint lng_lat_list = 1;
  inline int lng_lat_list_size() const;
  inline void clear_lng_lat_list();
  static const int kLngLatListFieldNumber = 1;
  inline const ::BUAS_QDP::LocationPoint& lng_lat_list(int index) const;
  inline ::BUAS_QDP::LocationPoint* mutable_lng_lat_list(int index);
  inline ::BUAS_QDP::LocationPoint* add_lng_lat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationPoint >&
      lng_lat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationPoint >*
      mutable_lng_lat_list();

  // @@protoc_insertion_point(class_scope:BUAS_QDP.Location2Position_ask)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationPoint > lng_lat_list_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static Location2Position_ask* default_instance_;
};
// -------------------------------------------------------------------

class LocationInfo : public ::google::protobuf::Message {
 public:
  LocationInfo();
  virtual ~LocationInfo();

  LocationInfo(const LocationInfo& from);

  inline LocationInfo& operator=(const LocationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationInfo& default_instance();

  void Swap(LocationInfo* other);

  // implements Message ----------------------------------------------

  LocationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationInfo& from);
  void MergeFrom(const LocationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes position_info = 1;
  inline bool has_position_info() const;
  inline void clear_position_info();
  static const int kPositionInfoFieldNumber = 1;
  inline const ::std::string& position_info() const;
  inline void set_position_info(const ::std::string& value);
  inline void set_position_info(const char* value);
  inline void set_position_info(const void* value, size_t size);
  inline ::std::string* mutable_position_info();
  inline ::std::string* release_position_info();
  inline void set_allocated_position_info(::std::string* position_info);

  // optional bytes localID = 2;
  inline bool has_localid() const;
  inline void clear_localid();
  static const int kLocalIDFieldNumber = 2;
  inline const ::std::string& localid() const;
  inline void set_localid(const ::std::string& value);
  inline void set_localid(const char* value);
  inline void set_localid(const void* value, size_t size);
  inline ::std::string* mutable_localid();
  inline ::std::string* release_localid();
  inline void set_allocated_localid(::std::string* localid);

  // optional bytes lng_lat = 3;
  inline bool has_lng_lat() const;
  inline void clear_lng_lat();
  static const int kLngLatFieldNumber = 3;
  inline const ::std::string& lng_lat() const;
  inline void set_lng_lat(const ::std::string& value);
  inline void set_lng_lat(const char* value);
  inline void set_lng_lat(const void* value, size_t size);
  inline ::std::string* mutable_lng_lat();
  inline ::std::string* release_lng_lat();
  inline void set_allocated_lng_lat(::std::string* lng_lat);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.LocationInfo)
 private:
  inline void set_has_position_info();
  inline void clear_has_position_info();
  inline void set_has_localid();
  inline void clear_has_localid();
  inline void set_has_lng_lat();
  inline void clear_has_lng_lat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* position_info_;
  ::std::string* localid_;
  ::std::string* lng_lat_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static LocationInfo* default_instance_;
};
// -------------------------------------------------------------------

class Location2Position_ans : public ::google::protobuf::Message {
 public:
  Location2Position_ans();
  virtual ~Location2Position_ans();

  Location2Position_ans(const Location2Position_ans& from);

  inline Location2Position_ans& operator=(const Location2Position_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location2Position_ans& default_instance();

  void Swap(Location2Position_ans* other);

  // implements Message ----------------------------------------------

  Location2Position_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location2Position_ans& from);
  void MergeFrom(const Location2Position_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.errorinfo error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // repeated .BUAS_QDP.LocationInfo position_info = 2;
  inline int position_info_size() const;
  inline void clear_position_info();
  static const int kPositionInfoFieldNumber = 2;
  inline const ::BUAS_QDP::LocationInfo& position_info(int index) const;
  inline ::BUAS_QDP::LocationInfo* mutable_position_info(int index);
  inline ::BUAS_QDP::LocationInfo* add_position_info();
  inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationInfo >&
      position_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationInfo >*
      mutable_position_info();

  // @@protoc_insertion_point(class_scope:BUAS_QDP.Location2Position_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::errorinfo* error_;
  ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationInfo > position_info_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static Location2Position_ans* default_instance_;
};
// -------------------------------------------------------------------

class ZhimaDataFlowReflux_ask : public ::google::protobuf::Message {
 public:
  ZhimaDataFlowReflux_ask();
  virtual ~ZhimaDataFlowReflux_ask();

  ZhimaDataFlowReflux_ask(const ZhimaDataFlowReflux_ask& from);

  inline ZhimaDataFlowReflux_ask& operator=(const ZhimaDataFlowReflux_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZhimaDataFlowReflux_ask& default_instance();

  void Swap(ZhimaDataFlowReflux_ask* other);

  // implements Message ----------------------------------------------

  ZhimaDataFlowReflux_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZhimaDataFlowReflux_ask& from);
  void MergeFrom(const ZhimaDataFlowReflux_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .BUAS_QDP.UserCredentialsType user_credentials_type = 1;
  inline bool has_user_credentials_type() const;
  inline void clear_user_credentials_type();
  static const int kUserCredentialsTypeFieldNumber = 1;
  inline ::BUAS_QDP::UserCredentialsType user_credentials_type() const;
  inline void set_user_credentials_type(::BUAS_QDP::UserCredentialsType value);

  // optional bytes identity_card = 2;
  inline bool has_identity_card() const;
  inline void clear_identity_card();
  static const int kIdentityCardFieldNumber = 2;
  inline const ::std::string& identity_card() const;
  inline void set_identity_card(const ::std::string& value);
  inline void set_identity_card(const char* value);
  inline void set_identity_card(const void* value, size_t size);
  inline ::std::string* mutable_identity_card();
  inline ::std::string* release_identity_card();
  inline void set_allocated_identity_card(::std::string* identity_card);

  // optional bytes real_name = 3;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 3;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const void* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional bytes mobile_phone = 4;
  inline bool has_mobile_phone() const;
  inline void clear_mobile_phone();
  static const int kMobilePhoneFieldNumber = 4;
  inline const ::std::string& mobile_phone() const;
  inline void set_mobile_phone(const ::std::string& value);
  inline void set_mobile_phone(const char* value);
  inline void set_mobile_phone(const void* value, size_t size);
  inline ::std::string* mutable_mobile_phone();
  inline ::std::string* release_mobile_phone();
  inline void set_allocated_mobile_phone(::std::string* mobile_phone);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.ZhimaDataFlowReflux_ask)
 private:
  inline void set_has_user_credentials_type();
  inline void clear_has_user_credentials_type();
  inline void set_has_identity_card();
  inline void clear_has_identity_card();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_mobile_phone();
  inline void clear_has_mobile_phone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* identity_card_;
  ::std::string* real_name_;
  ::std::string* mobile_phone_;
  int user_credentials_type_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static ZhimaDataFlowReflux_ask* default_instance_;
};
// -------------------------------------------------------------------

class LoanRecordInfo : public ::google::protobuf::Message {
 public:
  LoanRecordInfo();
  virtual ~LoanRecordInfo();

  LoanRecordInfo(const LoanRecordInfo& from);

  inline LoanRecordInfo& operator=(const LoanRecordInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoanRecordInfo& default_instance();

  void Swap(LoanRecordInfo* other);

  // implements Message ----------------------------------------------

  LoanRecordInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoanRecordInfo& from);
  void MergeFrom(const LoanRecordInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes orderNo = 1;
  inline bool has_orderno() const;
  inline void clear_orderno();
  static const int kOrderNoFieldNumber = 1;
  inline const ::std::string& orderno() const;
  inline void set_orderno(const ::std::string& value);
  inline void set_orderno(const char* value);
  inline void set_orderno(const void* value, size_t size);
  inline ::std::string* mutable_orderno();
  inline ::std::string* release_orderno();
  inline void set_allocated_orderno(::std::string* orderno);

  // optional bytes orderType = 2;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 2;
  inline const ::std::string& ordertype() const;
  inline void set_ordertype(const ::std::string& value);
  inline void set_ordertype(const char* value);
  inline void set_ordertype(const void* value, size_t size);
  inline ::std::string* mutable_ordertype();
  inline ::std::string* release_ordertype();
  inline void set_allocated_ordertype(::std::string* ordertype);

  // optional bytes bizType = 3;
  inline bool has_biztype() const;
  inline void clear_biztype();
  static const int kBizTypeFieldNumber = 3;
  inline const ::std::string& biztype() const;
  inline void set_biztype(const ::std::string& value);
  inline void set_biztype(const char* value);
  inline void set_biztype(const void* value, size_t size);
  inline ::std::string* mutable_biztype();
  inline ::std::string* release_biztype();
  inline void set_allocated_biztype(::std::string* biztype);

  // optional bytes gmtOrderStart = 4;
  inline bool has_gmtorderstart() const;
  inline void clear_gmtorderstart();
  static const int kGmtOrderStartFieldNumber = 4;
  inline const ::std::string& gmtorderstart() const;
  inline void set_gmtorderstart(const ::std::string& value);
  inline void set_gmtorderstart(const char* value);
  inline void set_gmtorderstart(const void* value, size_t size);
  inline ::std::string* mutable_gmtorderstart();
  inline ::std::string* release_gmtorderstart();
  inline void set_allocated_gmtorderstart(::std::string* gmtorderstart);

  // optional bytes gmtDue = 5;
  inline bool has_gmtdue() const;
  inline void clear_gmtdue();
  static const int kGmtDueFieldNumber = 5;
  inline const ::std::string& gmtdue() const;
  inline void set_gmtdue(const ::std::string& value);
  inline void set_gmtdue(const char* value);
  inline void set_gmtdue(const void* value, size_t size);
  inline ::std::string* mutable_gmtdue();
  inline ::std::string* release_gmtdue();
  inline void set_allocated_gmtdue(::std::string* gmtdue);

  // optional bytes payFreq = 6;
  inline bool has_payfreq() const;
  inline void clear_payfreq();
  static const int kPayFreqFieldNumber = 6;
  inline const ::std::string& payfreq() const;
  inline void set_payfreq(const ::std::string& value);
  inline void set_payfreq(const char* value);
  inline void set_payfreq(const void* value, size_t size);
  inline ::std::string* mutable_payfreq();
  inline ::std::string* release_payfreq();
  inline void set_allocated_payfreq(::std::string* payfreq);

  // optional bytes payMonth = 7;
  inline bool has_paymonth() const;
  inline void clear_paymonth();
  static const int kPayMonthFieldNumber = 7;
  inline const ::std::string& paymonth() const;
  inline void set_paymonth(const ::std::string& value);
  inline void set_paymonth(const char* value);
  inline void set_paymonth(const void* value, size_t size);
  inline ::std::string* mutable_paymonth();
  inline ::std::string* release_paymonth();
  inline void set_allocated_paymonth(::std::string* paymonth);

  // optional bytes gmtOvdDate = 8;
  inline bool has_gmtovddate() const;
  inline void clear_gmtovddate();
  static const int kGmtOvdDateFieldNumber = 8;
  inline const ::std::string& gmtovddate() const;
  inline void set_gmtovddate(const ::std::string& value);
  inline void set_gmtovddate(const char* value);
  inline void set_gmtovddate(const void* value, size_t size);
  inline ::std::string* mutable_gmtovddate();
  inline ::std::string* release_gmtovddate();
  inline void set_allocated_gmtovddate(::std::string* gmtovddate);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.LoanRecordInfo)
 private:
  inline void set_has_orderno();
  inline void clear_has_orderno();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_biztype();
  inline void clear_has_biztype();
  inline void set_has_gmtorderstart();
  inline void clear_has_gmtorderstart();
  inline void set_has_gmtdue();
  inline void clear_has_gmtdue();
  inline void set_has_payfreq();
  inline void clear_has_payfreq();
  inline void set_has_paymonth();
  inline void clear_has_paymonth();
  inline void set_has_gmtovddate();
  inline void clear_has_gmtovddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* orderno_;
  ::std::string* ordertype_;
  ::std::string* biztype_;
  ::std::string* gmtorderstart_;
  ::std::string* gmtdue_;
  ::std::string* payfreq_;
  ::std::string* paymonth_;
  ::std::string* gmtovddate_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static LoanRecordInfo* default_instance_;
};
// -------------------------------------------------------------------

class AssureRecordInfo : public ::google::protobuf::Message {
 public:
  AssureRecordInfo();
  virtual ~AssureRecordInfo();

  AssureRecordInfo(const AssureRecordInfo& from);

  inline AssureRecordInfo& operator=(const AssureRecordInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssureRecordInfo& default_instance();

  void Swap(AssureRecordInfo* other);

  // implements Message ----------------------------------------------

  AssureRecordInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssureRecordInfo& from);
  void MergeFrom(const AssureRecordInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline const ::std::string& identity() const;
  inline void set_identity(const ::std::string& value);
  inline void set_identity(const char* value);
  inline void set_identity(const void* value, size_t size);
  inline ::std::string* mutable_identity();
  inline ::std::string* release_identity();
  inline void set_allocated_identity(::std::string* identity);

  // optional bytes orderNo = 2;
  inline bool has_orderno() const;
  inline void clear_orderno();
  static const int kOrderNoFieldNumber = 2;
  inline const ::std::string& orderno() const;
  inline void set_orderno(const ::std::string& value);
  inline void set_orderno(const char* value);
  inline void set_orderno(const void* value, size_t size);
  inline ::std::string* mutable_orderno();
  inline ::std::string* release_orderno();
  inline void set_allocated_orderno(::std::string* orderno);

  // optional bytes orderType = 3;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 3;
  inline const ::std::string& ordertype() const;
  inline void set_ordertype(const ::std::string& value);
  inline void set_ordertype(const char* value);
  inline void set_ordertype(const void* value, size_t size);
  inline ::std::string* mutable_ordertype();
  inline ::std::string* release_ordertype();
  inline void set_allocated_ordertype(::std::string* ordertype);

  // optional bytes guaAmt = 4;
  inline bool has_guaamt() const;
  inline void clear_guaamt();
  static const int kGuaAmtFieldNumber = 4;
  inline const ::std::string& guaamt() const;
  inline void set_guaamt(const ::std::string& value);
  inline void set_guaamt(const char* value);
  inline void set_guaamt(const void* value, size_t size);
  inline ::std::string* mutable_guaamt();
  inline ::std::string* release_guaamt();
  inline void set_allocated_guaamt(::std::string* guaamt);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.AssureRecordInfo)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_orderno();
  inline void clear_has_orderno();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_guaamt();
  inline void clear_has_guaamt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* identity_;
  ::std::string* orderno_;
  ::std::string* ordertype_;
  ::std::string* guaamt_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static AssureRecordInfo* default_instance_;
};
// -------------------------------------------------------------------

class ZhimaDataFlowReflux_ans : public ::google::protobuf::Message {
 public:
  ZhimaDataFlowReflux_ans();
  virtual ~ZhimaDataFlowReflux_ans();

  ZhimaDataFlowReflux_ans(const ZhimaDataFlowReflux_ans& from);

  inline ZhimaDataFlowReflux_ans& operator=(const ZhimaDataFlowReflux_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZhimaDataFlowReflux_ans& default_instance();

  void Swap(ZhimaDataFlowReflux_ans* other);

  // implements Message ----------------------------------------------

  ZhimaDataFlowReflux_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZhimaDataFlowReflux_ans& from);
  void MergeFrom(const ZhimaDataFlowReflux_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .BUAS_QDP.UserCredentialsType user_credentials_type = 1;
  inline bool has_user_credentials_type() const;
  inline void clear_user_credentials_type();
  static const int kUserCredentialsTypeFieldNumber = 1;
  inline ::BUAS_QDP::UserCredentialsType user_credentials_type() const;
  inline void set_user_credentials_type(::BUAS_QDP::UserCredentialsType value);

  // optional bytes identity_card = 2;
  inline bool has_identity_card() const;
  inline void clear_identity_card();
  static const int kIdentityCardFieldNumber = 2;
  inline const ::std::string& identity_card() const;
  inline void set_identity_card(const ::std::string& value);
  inline void set_identity_card(const char* value);
  inline void set_identity_card(const void* value, size_t size);
  inline ::std::string* mutable_identity_card();
  inline ::std::string* release_identity_card();
  inline void set_allocated_identity_card(::std::string* identity_card);

  // optional bytes real_name = 3;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 3;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const void* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional bytes mobile_phone = 4;
  inline bool has_mobile_phone() const;
  inline void clear_mobile_phone();
  static const int kMobilePhoneFieldNumber = 4;
  inline const ::std::string& mobile_phone() const;
  inline void set_mobile_phone(const ::std::string& value);
  inline void set_mobile_phone(const char* value);
  inline void set_mobile_phone(const void* value, size_t size);
  inline ::std::string* mutable_mobile_phone();
  inline ::std::string* release_mobile_phone();
  inline void set_allocated_mobile_phone(::std::string* mobile_phone);

  // repeated .BUAS_QDP.LoanRecordInfo loan_info = 5;
  inline int loan_info_size() const;
  inline void clear_loan_info();
  static const int kLoanInfoFieldNumber = 5;
  inline const ::BUAS_QDP::LoanRecordInfo& loan_info(int index) const;
  inline ::BUAS_QDP::LoanRecordInfo* mutable_loan_info(int index);
  inline ::BUAS_QDP::LoanRecordInfo* add_loan_info();
  inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LoanRecordInfo >&
      loan_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LoanRecordInfo >*
      mutable_loan_info();

  // repeated .BUAS_QDP.AssureRecordInfo assure_info = 6;
  inline int assure_info_size() const;
  inline void clear_assure_info();
  static const int kAssureInfoFieldNumber = 6;
  inline const ::BUAS_QDP::AssureRecordInfo& assure_info(int index) const;
  inline ::BUAS_QDP::AssureRecordInfo* mutable_assure_info(int index);
  inline ::BUAS_QDP::AssureRecordInfo* add_assure_info();
  inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::AssureRecordInfo >&
      assure_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::AssureRecordInfo >*
      mutable_assure_info();

  // optional bytes remindCnt = 7;
  inline bool has_remindcnt() const;
  inline void clear_remindcnt();
  static const int kRemindCntFieldNumber = 7;
  inline const ::std::string& remindcnt() const;
  inline void set_remindcnt(const ::std::string& value);
  inline void set_remindcnt(const char* value);
  inline void set_remindcnt(const void* value, size_t size);
  inline ::std::string* mutable_remindcnt();
  inline ::std::string* release_remindcnt();
  inline void set_allocated_remindcnt(::std::string* remindcnt);

  // optional bytes amtOverdue = 8;
  inline bool has_amtoverdue() const;
  inline void clear_amtoverdue();
  static const int kAmtOverdueFieldNumber = 8;
  inline const ::std::string& amtoverdue() const;
  inline void set_amtoverdue(const ::std::string& value);
  inline void set_amtoverdue(const char* value);
  inline void set_amtoverdue(const void* value, size_t size);
  inline ::std::string* mutable_amtoverdue();
  inline ::std::string* release_amtoverdue();
  inline void set_allocated_amtoverdue(::std::string* amtoverdue);

  // @@protoc_insertion_point(class_scope:BUAS_QDP.ZhimaDataFlowReflux_ans)
 private:
  inline void set_has_user_credentials_type();
  inline void clear_has_user_credentials_type();
  inline void set_has_identity_card();
  inline void clear_has_identity_card();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_mobile_phone();
  inline void clear_has_mobile_phone();
  inline void set_has_remindcnt();
  inline void clear_has_remindcnt();
  inline void set_has_amtoverdue();
  inline void clear_has_amtoverdue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* identity_card_;
  ::std::string* real_name_;
  ::std::string* mobile_phone_;
  ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LoanRecordInfo > loan_info_;
  ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::AssureRecordInfo > assure_info_;
  ::std::string* remindcnt_;
  ::std::string* amtoverdue_;
  int user_credentials_type_;
  friend void  protobuf_AddDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_AssignDesc_UBAS_5fQDP_2eproto();
  friend void protobuf_ShutdownFile_UBAS_5fQDP_2eproto();

  void InitAsDefaultInstance();
  static ZhimaDataFlowReflux_ans* default_instance_;
};
// ===================================================================


// ===================================================================

// LocationPoint

// optional bytes lng_lat = 1;
inline bool LocationPoint::has_lng_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationPoint::set_has_lng_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationPoint::clear_has_lng_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationPoint::clear_lng_lat() {
  if (lng_lat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_->clear();
  }
  clear_has_lng_lat();
}
inline const ::std::string& LocationPoint::lng_lat() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LocationPoint.lng_lat)
  return *lng_lat_;
}
inline void LocationPoint::set_lng_lat(const ::std::string& value) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LocationPoint.lng_lat)
}
inline void LocationPoint::set_lng_lat(const char* value) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LocationPoint.lng_lat)
}
inline void LocationPoint::set_lng_lat(const void* value, size_t size) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LocationPoint.lng_lat)
}
inline ::std::string* LocationPoint::mutable_lng_lat() {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LocationPoint.lng_lat)
  return lng_lat_;
}
inline ::std::string* LocationPoint::release_lng_lat() {
  clear_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lng_lat_;
    lng_lat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocationPoint::set_allocated_lng_lat(::std::string* lng_lat) {
  if (lng_lat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lng_lat_;
  }
  if (lng_lat) {
    set_has_lng_lat();
    lng_lat_ = lng_lat;
  } else {
    clear_has_lng_lat();
    lng_lat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LocationPoint.lng_lat)
}

// optional bytes localID = 2;
inline bool LocationPoint::has_localid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationPoint::set_has_localid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationPoint::clear_has_localid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationPoint::clear_localid() {
  if (localid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_->clear();
  }
  clear_has_localid();
}
inline const ::std::string& LocationPoint::localid() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LocationPoint.localID)
  return *localid_;
}
inline void LocationPoint::set_localid(const ::std::string& value) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LocationPoint.localID)
}
inline void LocationPoint::set_localid(const char* value) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LocationPoint.localID)
}
inline void LocationPoint::set_localid(const void* value, size_t size) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LocationPoint.localID)
}
inline ::std::string* LocationPoint::mutable_localid() {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LocationPoint.localID)
  return localid_;
}
inline ::std::string* LocationPoint::release_localid() {
  clear_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localid_;
    localid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocationPoint::set_allocated_localid(::std::string* localid) {
  if (localid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localid_;
  }
  if (localid) {
    set_has_localid();
    localid_ = localid;
  } else {
    clear_has_localid();
    localid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LocationPoint.localID)
}

// -------------------------------------------------------------------

// Location2Position_ask

// repeated .BUAS_QDP.LocationPoint lng_lat_list = 1;
inline int Location2Position_ask::lng_lat_list_size() const {
  return lng_lat_list_.size();
}
inline void Location2Position_ask::clear_lng_lat_list() {
  lng_lat_list_.Clear();
}
inline const ::BUAS_QDP::LocationPoint& Location2Position_ask::lng_lat_list(int index) const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.Location2Position_ask.lng_lat_list)
  return lng_lat_list_.Get(index);
}
inline ::BUAS_QDP::LocationPoint* Location2Position_ask::mutable_lng_lat_list(int index) {
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.Location2Position_ask.lng_lat_list)
  return lng_lat_list_.Mutable(index);
}
inline ::BUAS_QDP::LocationPoint* Location2Position_ask::add_lng_lat_list() {
  // @@protoc_insertion_point(field_add:BUAS_QDP.Location2Position_ask.lng_lat_list)
  return lng_lat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationPoint >&
Location2Position_ask::lng_lat_list() const {
  // @@protoc_insertion_point(field_list:BUAS_QDP.Location2Position_ask.lng_lat_list)
  return lng_lat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationPoint >*
Location2Position_ask::mutable_lng_lat_list() {
  // @@protoc_insertion_point(field_mutable_list:BUAS_QDP.Location2Position_ask.lng_lat_list)
  return &lng_lat_list_;
}

// -------------------------------------------------------------------

// LocationInfo

// optional bytes position_info = 1;
inline bool LocationInfo::has_position_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationInfo::set_has_position_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationInfo::clear_has_position_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationInfo::clear_position_info() {
  if (position_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_info_->clear();
  }
  clear_has_position_info();
}
inline const ::std::string& LocationInfo::position_info() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LocationInfo.position_info)
  return *position_info_;
}
inline void LocationInfo::set_position_info(const ::std::string& value) {
  set_has_position_info();
  if (position_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_info_ = new ::std::string;
  }
  position_info_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LocationInfo.position_info)
}
inline void LocationInfo::set_position_info(const char* value) {
  set_has_position_info();
  if (position_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_info_ = new ::std::string;
  }
  position_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LocationInfo.position_info)
}
inline void LocationInfo::set_position_info(const void* value, size_t size) {
  set_has_position_info();
  if (position_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_info_ = new ::std::string;
  }
  position_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LocationInfo.position_info)
}
inline ::std::string* LocationInfo::mutable_position_info() {
  set_has_position_info();
  if (position_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LocationInfo.position_info)
  return position_info_;
}
inline ::std::string* LocationInfo::release_position_info() {
  clear_has_position_info();
  if (position_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_info_;
    position_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocationInfo::set_allocated_position_info(::std::string* position_info) {
  if (position_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_info_;
  }
  if (position_info) {
    set_has_position_info();
    position_info_ = position_info;
  } else {
    clear_has_position_info();
    position_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LocationInfo.position_info)
}

// optional bytes localID = 2;
inline bool LocationInfo::has_localid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationInfo::set_has_localid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationInfo::clear_has_localid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationInfo::clear_localid() {
  if (localid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_->clear();
  }
  clear_has_localid();
}
inline const ::std::string& LocationInfo::localid() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LocationInfo.localID)
  return *localid_;
}
inline void LocationInfo::set_localid(const ::std::string& value) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LocationInfo.localID)
}
inline void LocationInfo::set_localid(const char* value) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LocationInfo.localID)
}
inline void LocationInfo::set_localid(const void* value, size_t size) {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  localid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LocationInfo.localID)
}
inline ::std::string* LocationInfo::mutable_localid() {
  set_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LocationInfo.localID)
  return localid_;
}
inline ::std::string* LocationInfo::release_localid() {
  clear_has_localid();
  if (localid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localid_;
    localid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocationInfo::set_allocated_localid(::std::string* localid) {
  if (localid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localid_;
  }
  if (localid) {
    set_has_localid();
    localid_ = localid;
  } else {
    clear_has_localid();
    localid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LocationInfo.localID)
}

// optional bytes lng_lat = 3;
inline bool LocationInfo::has_lng_lat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationInfo::set_has_lng_lat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationInfo::clear_has_lng_lat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationInfo::clear_lng_lat() {
  if (lng_lat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_->clear();
  }
  clear_has_lng_lat();
}
inline const ::std::string& LocationInfo::lng_lat() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LocationInfo.lng_lat)
  return *lng_lat_;
}
inline void LocationInfo::set_lng_lat(const ::std::string& value) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LocationInfo.lng_lat)
}
inline void LocationInfo::set_lng_lat(const char* value) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LocationInfo.lng_lat)
}
inline void LocationInfo::set_lng_lat(const void* value, size_t size) {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  lng_lat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LocationInfo.lng_lat)
}
inline ::std::string* LocationInfo::mutable_lng_lat() {
  set_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lng_lat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LocationInfo.lng_lat)
  return lng_lat_;
}
inline ::std::string* LocationInfo::release_lng_lat() {
  clear_has_lng_lat();
  if (lng_lat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lng_lat_;
    lng_lat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocationInfo::set_allocated_lng_lat(::std::string* lng_lat) {
  if (lng_lat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lng_lat_;
  }
  if (lng_lat) {
    set_has_lng_lat();
    lng_lat_ = lng_lat;
  } else {
    clear_has_lng_lat();
    lng_lat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LocationInfo.lng_lat)
}

// -------------------------------------------------------------------

// Location2Position_ans

// optional .common.errorinfo error = 1;
inline bool Location2Position_ans::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location2Position_ans::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location2Position_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location2Position_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& Location2Position_ans::error() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.Location2Position_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* Location2Position_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.Location2Position_ans.error)
  return error_;
}
inline ::common::errorinfo* Location2Position_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Location2Position_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.Location2Position_ans.error)
}

// repeated .BUAS_QDP.LocationInfo position_info = 2;
inline int Location2Position_ans::position_info_size() const {
  return position_info_.size();
}
inline void Location2Position_ans::clear_position_info() {
  position_info_.Clear();
}
inline const ::BUAS_QDP::LocationInfo& Location2Position_ans::position_info(int index) const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.Location2Position_ans.position_info)
  return position_info_.Get(index);
}
inline ::BUAS_QDP::LocationInfo* Location2Position_ans::mutable_position_info(int index) {
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.Location2Position_ans.position_info)
  return position_info_.Mutable(index);
}
inline ::BUAS_QDP::LocationInfo* Location2Position_ans::add_position_info() {
  // @@protoc_insertion_point(field_add:BUAS_QDP.Location2Position_ans.position_info)
  return position_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationInfo >&
Location2Position_ans::position_info() const {
  // @@protoc_insertion_point(field_list:BUAS_QDP.Location2Position_ans.position_info)
  return position_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LocationInfo >*
Location2Position_ans::mutable_position_info() {
  // @@protoc_insertion_point(field_mutable_list:BUAS_QDP.Location2Position_ans.position_info)
  return &position_info_;
}

// -------------------------------------------------------------------

// ZhimaDataFlowReflux_ask

// optional .BUAS_QDP.UserCredentialsType user_credentials_type = 1;
inline bool ZhimaDataFlowReflux_ask::has_user_credentials_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZhimaDataFlowReflux_ask::set_has_user_credentials_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZhimaDataFlowReflux_ask::clear_has_user_credentials_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZhimaDataFlowReflux_ask::clear_user_credentials_type() {
  user_credentials_type_ = 0;
  clear_has_user_credentials_type();
}
inline ::BUAS_QDP::UserCredentialsType ZhimaDataFlowReflux_ask::user_credentials_type() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ask.user_credentials_type)
  return static_cast< ::BUAS_QDP::UserCredentialsType >(user_credentials_type_);
}
inline void ZhimaDataFlowReflux_ask::set_user_credentials_type(::BUAS_QDP::UserCredentialsType value) {
  assert(::BUAS_QDP::UserCredentialsType_IsValid(value));
  set_has_user_credentials_type();
  user_credentials_type_ = value;
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ask.user_credentials_type)
}

// optional bytes identity_card = 2;
inline bool ZhimaDataFlowReflux_ask::has_identity_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZhimaDataFlowReflux_ask::set_has_identity_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZhimaDataFlowReflux_ask::clear_has_identity_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZhimaDataFlowReflux_ask::clear_identity_card() {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_->clear();
  }
  clear_has_identity_card();
}
inline const ::std::string& ZhimaDataFlowReflux_ask::identity_card() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
  return *identity_card_;
}
inline void ZhimaDataFlowReflux_ask::set_identity_card(const ::std::string& value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
}
inline void ZhimaDataFlowReflux_ask::set_identity_card(const char* value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
}
inline void ZhimaDataFlowReflux_ask::set_identity_card(const void* value, size_t size) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
}
inline ::std::string* ZhimaDataFlowReflux_ask::mutable_identity_card() {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
  return identity_card_;
}
inline ::std::string* ZhimaDataFlowReflux_ask::release_identity_card() {
  clear_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = identity_card_;
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ask::set_allocated_identity_card(::std::string* identity_card) {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete identity_card_;
  }
  if (identity_card) {
    set_has_identity_card();
    identity_card_ = identity_card;
  } else {
    clear_has_identity_card();
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ask.identity_card)
}

// optional bytes real_name = 3;
inline bool ZhimaDataFlowReflux_ask::has_real_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZhimaDataFlowReflux_ask::set_has_real_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZhimaDataFlowReflux_ask::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZhimaDataFlowReflux_ask::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& ZhimaDataFlowReflux_ask::real_name() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
  return *real_name_;
}
inline void ZhimaDataFlowReflux_ask::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
}
inline void ZhimaDataFlowReflux_ask::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
}
inline void ZhimaDataFlowReflux_ask::set_real_name(const void* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
}
inline ::std::string* ZhimaDataFlowReflux_ask::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
  return real_name_;
}
inline ::std::string* ZhimaDataFlowReflux_ask::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ask::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ask.real_name)
}

// optional bytes mobile_phone = 4;
inline bool ZhimaDataFlowReflux_ask::has_mobile_phone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZhimaDataFlowReflux_ask::set_has_mobile_phone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZhimaDataFlowReflux_ask::clear_has_mobile_phone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZhimaDataFlowReflux_ask::clear_mobile_phone() {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_->clear();
  }
  clear_has_mobile_phone();
}
inline const ::std::string& ZhimaDataFlowReflux_ask::mobile_phone() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
  return *mobile_phone_;
}
inline void ZhimaDataFlowReflux_ask::set_mobile_phone(const ::std::string& value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
}
inline void ZhimaDataFlowReflux_ask::set_mobile_phone(const char* value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
}
inline void ZhimaDataFlowReflux_ask::set_mobile_phone(const void* value, size_t size) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
}
inline ::std::string* ZhimaDataFlowReflux_ask::mutable_mobile_phone() {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
  return mobile_phone_;
}
inline ::std::string* ZhimaDataFlowReflux_ask::release_mobile_phone() {
  clear_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_phone_;
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ask::set_allocated_mobile_phone(::std::string* mobile_phone) {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_phone_;
  }
  if (mobile_phone) {
    set_has_mobile_phone();
    mobile_phone_ = mobile_phone;
  } else {
    clear_has_mobile_phone();
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ask.mobile_phone)
}

// -------------------------------------------------------------------

// LoanRecordInfo

// optional bytes orderNo = 1;
inline bool LoanRecordInfo::has_orderno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoanRecordInfo::set_has_orderno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoanRecordInfo::clear_has_orderno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoanRecordInfo::clear_orderno() {
  if (orderno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_->clear();
  }
  clear_has_orderno();
}
inline const ::std::string& LoanRecordInfo::orderno() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.orderNo)
  return *orderno_;
}
inline void LoanRecordInfo::set_orderno(const ::std::string& value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.orderNo)
}
inline void LoanRecordInfo::set_orderno(const char* value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.orderNo)
}
inline void LoanRecordInfo::set_orderno(const void* value, size_t size) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.orderNo)
}
inline ::std::string* LoanRecordInfo::mutable_orderno() {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.orderNo)
  return orderno_;
}
inline ::std::string* LoanRecordInfo::release_orderno() {
  clear_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderno_;
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_orderno(::std::string* orderno) {
  if (orderno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderno_;
  }
  if (orderno) {
    set_has_orderno();
    orderno_ = orderno;
  } else {
    clear_has_orderno();
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.orderNo)
}

// optional bytes orderType = 2;
inline bool LoanRecordInfo::has_ordertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoanRecordInfo::set_has_ordertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoanRecordInfo::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoanRecordInfo::clear_ordertype() {
  if (ordertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_->clear();
  }
  clear_has_ordertype();
}
inline const ::std::string& LoanRecordInfo::ordertype() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.orderType)
  return *ordertype_;
}
inline void LoanRecordInfo::set_ordertype(const ::std::string& value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.orderType)
}
inline void LoanRecordInfo::set_ordertype(const char* value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.orderType)
}
inline void LoanRecordInfo::set_ordertype(const void* value, size_t size) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.orderType)
}
inline ::std::string* LoanRecordInfo::mutable_ordertype() {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.orderType)
  return ordertype_;
}
inline ::std::string* LoanRecordInfo::release_ordertype() {
  clear_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ordertype_;
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_ordertype(::std::string* ordertype) {
  if (ordertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ordertype_;
  }
  if (ordertype) {
    set_has_ordertype();
    ordertype_ = ordertype;
  } else {
    clear_has_ordertype();
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.orderType)
}

// optional bytes bizType = 3;
inline bool LoanRecordInfo::has_biztype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoanRecordInfo::set_has_biztype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoanRecordInfo::clear_has_biztype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoanRecordInfo::clear_biztype() {
  if (biztype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biztype_->clear();
  }
  clear_has_biztype();
}
inline const ::std::string& LoanRecordInfo::biztype() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.bizType)
  return *biztype_;
}
inline void LoanRecordInfo::set_biztype(const ::std::string& value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.bizType)
}
inline void LoanRecordInfo::set_biztype(const char* value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.bizType)
}
inline void LoanRecordInfo::set_biztype(const void* value, size_t size) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.bizType)
}
inline ::std::string* LoanRecordInfo::mutable_biztype() {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biztype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.bizType)
  return biztype_;
}
inline ::std::string* LoanRecordInfo::release_biztype() {
  clear_has_biztype();
  if (biztype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = biztype_;
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_biztype(::std::string* biztype) {
  if (biztype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete biztype_;
  }
  if (biztype) {
    set_has_biztype();
    biztype_ = biztype;
  } else {
    clear_has_biztype();
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.bizType)
}

// optional bytes gmtOrderStart = 4;
inline bool LoanRecordInfo::has_gmtorderstart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoanRecordInfo::set_has_gmtorderstart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoanRecordInfo::clear_has_gmtorderstart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoanRecordInfo::clear_gmtorderstart() {
  if (gmtorderstart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtorderstart_->clear();
  }
  clear_has_gmtorderstart();
}
inline const ::std::string& LoanRecordInfo::gmtorderstart() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
  return *gmtorderstart_;
}
inline void LoanRecordInfo::set_gmtorderstart(const ::std::string& value) {
  set_has_gmtorderstart();
  if (gmtorderstart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtorderstart_ = new ::std::string;
  }
  gmtorderstart_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
}
inline void LoanRecordInfo::set_gmtorderstart(const char* value) {
  set_has_gmtorderstart();
  if (gmtorderstart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtorderstart_ = new ::std::string;
  }
  gmtorderstart_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
}
inline void LoanRecordInfo::set_gmtorderstart(const void* value, size_t size) {
  set_has_gmtorderstart();
  if (gmtorderstart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtorderstart_ = new ::std::string;
  }
  gmtorderstart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
}
inline ::std::string* LoanRecordInfo::mutable_gmtorderstart() {
  set_has_gmtorderstart();
  if (gmtorderstart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtorderstart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
  return gmtorderstart_;
}
inline ::std::string* LoanRecordInfo::release_gmtorderstart() {
  clear_has_gmtorderstart();
  if (gmtorderstart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gmtorderstart_;
    gmtorderstart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_gmtorderstart(::std::string* gmtorderstart) {
  if (gmtorderstart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gmtorderstart_;
  }
  if (gmtorderstart) {
    set_has_gmtorderstart();
    gmtorderstart_ = gmtorderstart;
  } else {
    clear_has_gmtorderstart();
    gmtorderstart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.gmtOrderStart)
}

// optional bytes gmtDue = 5;
inline bool LoanRecordInfo::has_gmtdue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoanRecordInfo::set_has_gmtdue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoanRecordInfo::clear_has_gmtdue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoanRecordInfo::clear_gmtdue() {
  if (gmtdue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtdue_->clear();
  }
  clear_has_gmtdue();
}
inline const ::std::string& LoanRecordInfo::gmtdue() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.gmtDue)
  return *gmtdue_;
}
inline void LoanRecordInfo::set_gmtdue(const ::std::string& value) {
  set_has_gmtdue();
  if (gmtdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtdue_ = new ::std::string;
  }
  gmtdue_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.gmtDue)
}
inline void LoanRecordInfo::set_gmtdue(const char* value) {
  set_has_gmtdue();
  if (gmtdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtdue_ = new ::std::string;
  }
  gmtdue_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.gmtDue)
}
inline void LoanRecordInfo::set_gmtdue(const void* value, size_t size) {
  set_has_gmtdue();
  if (gmtdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtdue_ = new ::std::string;
  }
  gmtdue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.gmtDue)
}
inline ::std::string* LoanRecordInfo::mutable_gmtdue() {
  set_has_gmtdue();
  if (gmtdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtdue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.gmtDue)
  return gmtdue_;
}
inline ::std::string* LoanRecordInfo::release_gmtdue() {
  clear_has_gmtdue();
  if (gmtdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gmtdue_;
    gmtdue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_gmtdue(::std::string* gmtdue) {
  if (gmtdue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gmtdue_;
  }
  if (gmtdue) {
    set_has_gmtdue();
    gmtdue_ = gmtdue;
  } else {
    clear_has_gmtdue();
    gmtdue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.gmtDue)
}

// optional bytes payFreq = 6;
inline bool LoanRecordInfo::has_payfreq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoanRecordInfo::set_has_payfreq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoanRecordInfo::clear_has_payfreq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoanRecordInfo::clear_payfreq() {
  if (payfreq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payfreq_->clear();
  }
  clear_has_payfreq();
}
inline const ::std::string& LoanRecordInfo::payfreq() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.payFreq)
  return *payfreq_;
}
inline void LoanRecordInfo::set_payfreq(const ::std::string& value) {
  set_has_payfreq();
  if (payfreq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payfreq_ = new ::std::string;
  }
  payfreq_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.payFreq)
}
inline void LoanRecordInfo::set_payfreq(const char* value) {
  set_has_payfreq();
  if (payfreq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payfreq_ = new ::std::string;
  }
  payfreq_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.payFreq)
}
inline void LoanRecordInfo::set_payfreq(const void* value, size_t size) {
  set_has_payfreq();
  if (payfreq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payfreq_ = new ::std::string;
  }
  payfreq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.payFreq)
}
inline ::std::string* LoanRecordInfo::mutable_payfreq() {
  set_has_payfreq();
  if (payfreq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payfreq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.payFreq)
  return payfreq_;
}
inline ::std::string* LoanRecordInfo::release_payfreq() {
  clear_has_payfreq();
  if (payfreq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payfreq_;
    payfreq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_payfreq(::std::string* payfreq) {
  if (payfreq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payfreq_;
  }
  if (payfreq) {
    set_has_payfreq();
    payfreq_ = payfreq;
  } else {
    clear_has_payfreq();
    payfreq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.payFreq)
}

// optional bytes payMonth = 7;
inline bool LoanRecordInfo::has_paymonth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoanRecordInfo::set_has_paymonth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoanRecordInfo::clear_has_paymonth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoanRecordInfo::clear_paymonth() {
  if (paymonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paymonth_->clear();
  }
  clear_has_paymonth();
}
inline const ::std::string& LoanRecordInfo::paymonth() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.payMonth)
  return *paymonth_;
}
inline void LoanRecordInfo::set_paymonth(const ::std::string& value) {
  set_has_paymonth();
  if (paymonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paymonth_ = new ::std::string;
  }
  paymonth_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.payMonth)
}
inline void LoanRecordInfo::set_paymonth(const char* value) {
  set_has_paymonth();
  if (paymonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paymonth_ = new ::std::string;
  }
  paymonth_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.payMonth)
}
inline void LoanRecordInfo::set_paymonth(const void* value, size_t size) {
  set_has_paymonth();
  if (paymonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paymonth_ = new ::std::string;
  }
  paymonth_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.payMonth)
}
inline ::std::string* LoanRecordInfo::mutable_paymonth() {
  set_has_paymonth();
  if (paymonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paymonth_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.payMonth)
  return paymonth_;
}
inline ::std::string* LoanRecordInfo::release_paymonth() {
  clear_has_paymonth();
  if (paymonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paymonth_;
    paymonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_paymonth(::std::string* paymonth) {
  if (paymonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paymonth_;
  }
  if (paymonth) {
    set_has_paymonth();
    paymonth_ = paymonth;
  } else {
    clear_has_paymonth();
    paymonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.payMonth)
}

// optional bytes gmtOvdDate = 8;
inline bool LoanRecordInfo::has_gmtovddate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoanRecordInfo::set_has_gmtovddate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoanRecordInfo::clear_has_gmtovddate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoanRecordInfo::clear_gmtovddate() {
  if (gmtovddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtovddate_->clear();
  }
  clear_has_gmtovddate();
}
inline const ::std::string& LoanRecordInfo::gmtovddate() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
  return *gmtovddate_;
}
inline void LoanRecordInfo::set_gmtovddate(const ::std::string& value) {
  set_has_gmtovddate();
  if (gmtovddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtovddate_ = new ::std::string;
  }
  gmtovddate_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
}
inline void LoanRecordInfo::set_gmtovddate(const char* value) {
  set_has_gmtovddate();
  if (gmtovddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtovddate_ = new ::std::string;
  }
  gmtovddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
}
inline void LoanRecordInfo::set_gmtovddate(const void* value, size_t size) {
  set_has_gmtovddate();
  if (gmtovddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtovddate_ = new ::std::string;
  }
  gmtovddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
}
inline ::std::string* LoanRecordInfo::mutable_gmtovddate() {
  set_has_gmtovddate();
  if (gmtovddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gmtovddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
  return gmtovddate_;
}
inline ::std::string* LoanRecordInfo::release_gmtovddate() {
  clear_has_gmtovddate();
  if (gmtovddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gmtovddate_;
    gmtovddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoanRecordInfo::set_allocated_gmtovddate(::std::string* gmtovddate) {
  if (gmtovddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gmtovddate_;
  }
  if (gmtovddate) {
    set_has_gmtovddate();
    gmtovddate_ = gmtovddate;
  } else {
    clear_has_gmtovddate();
    gmtovddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.LoanRecordInfo.gmtOvdDate)
}

// -------------------------------------------------------------------

// AssureRecordInfo

// optional bytes identity = 1;
inline bool AssureRecordInfo::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssureRecordInfo::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssureRecordInfo::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssureRecordInfo::clear_identity() {
  if (identity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_->clear();
  }
  clear_has_identity();
}
inline const ::std::string& AssureRecordInfo::identity() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.AssureRecordInfo.identity)
  return *identity_;
}
inline void AssureRecordInfo::set_identity(const ::std::string& value) {
  set_has_identity();
  if (identity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_ = new ::std::string;
  }
  identity_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.AssureRecordInfo.identity)
}
inline void AssureRecordInfo::set_identity(const char* value) {
  set_has_identity();
  if (identity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_ = new ::std::string;
  }
  identity_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.AssureRecordInfo.identity)
}
inline void AssureRecordInfo::set_identity(const void* value, size_t size) {
  set_has_identity();
  if (identity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_ = new ::std::string;
  }
  identity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.AssureRecordInfo.identity)
}
inline ::std::string* AssureRecordInfo::mutable_identity() {
  set_has_identity();
  if (identity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.AssureRecordInfo.identity)
  return identity_;
}
inline ::std::string* AssureRecordInfo::release_identity() {
  clear_has_identity();
  if (identity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = identity_;
    identity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssureRecordInfo::set_allocated_identity(::std::string* identity) {
  if (identity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete identity_;
  }
  if (identity) {
    set_has_identity();
    identity_ = identity;
  } else {
    clear_has_identity();
    identity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.AssureRecordInfo.identity)
}

// optional bytes orderNo = 2;
inline bool AssureRecordInfo::has_orderno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssureRecordInfo::set_has_orderno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssureRecordInfo::clear_has_orderno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssureRecordInfo::clear_orderno() {
  if (orderno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_->clear();
  }
  clear_has_orderno();
}
inline const ::std::string& AssureRecordInfo::orderno() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.AssureRecordInfo.orderNo)
  return *orderno_;
}
inline void AssureRecordInfo::set_orderno(const ::std::string& value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.AssureRecordInfo.orderNo)
}
inline void AssureRecordInfo::set_orderno(const char* value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.AssureRecordInfo.orderNo)
}
inline void AssureRecordInfo::set_orderno(const void* value, size_t size) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.AssureRecordInfo.orderNo)
}
inline ::std::string* AssureRecordInfo::mutable_orderno() {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orderno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.AssureRecordInfo.orderNo)
  return orderno_;
}
inline ::std::string* AssureRecordInfo::release_orderno() {
  clear_has_orderno();
  if (orderno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orderno_;
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssureRecordInfo::set_allocated_orderno(::std::string* orderno) {
  if (orderno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orderno_;
  }
  if (orderno) {
    set_has_orderno();
    orderno_ = orderno;
  } else {
    clear_has_orderno();
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.AssureRecordInfo.orderNo)
}

// optional bytes orderType = 3;
inline bool AssureRecordInfo::has_ordertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssureRecordInfo::set_has_ordertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssureRecordInfo::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssureRecordInfo::clear_ordertype() {
  if (ordertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_->clear();
  }
  clear_has_ordertype();
}
inline const ::std::string& AssureRecordInfo::ordertype() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.AssureRecordInfo.orderType)
  return *ordertype_;
}
inline void AssureRecordInfo::set_ordertype(const ::std::string& value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.AssureRecordInfo.orderType)
}
inline void AssureRecordInfo::set_ordertype(const char* value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.AssureRecordInfo.orderType)
}
inline void AssureRecordInfo::set_ordertype(const void* value, size_t size) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.AssureRecordInfo.orderType)
}
inline ::std::string* AssureRecordInfo::mutable_ordertype() {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordertype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.AssureRecordInfo.orderType)
  return ordertype_;
}
inline ::std::string* AssureRecordInfo::release_ordertype() {
  clear_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ordertype_;
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssureRecordInfo::set_allocated_ordertype(::std::string* ordertype) {
  if (ordertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ordertype_;
  }
  if (ordertype) {
    set_has_ordertype();
    ordertype_ = ordertype;
  } else {
    clear_has_ordertype();
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.AssureRecordInfo.orderType)
}

// optional bytes guaAmt = 4;
inline bool AssureRecordInfo::has_guaamt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssureRecordInfo::set_has_guaamt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssureRecordInfo::clear_has_guaamt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssureRecordInfo::clear_guaamt() {
  if (guaamt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guaamt_->clear();
  }
  clear_has_guaamt();
}
inline const ::std::string& AssureRecordInfo::guaamt() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.AssureRecordInfo.guaAmt)
  return *guaamt_;
}
inline void AssureRecordInfo::set_guaamt(const ::std::string& value) {
  set_has_guaamt();
  if (guaamt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guaamt_ = new ::std::string;
  }
  guaamt_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.AssureRecordInfo.guaAmt)
}
inline void AssureRecordInfo::set_guaamt(const char* value) {
  set_has_guaamt();
  if (guaamt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guaamt_ = new ::std::string;
  }
  guaamt_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.AssureRecordInfo.guaAmt)
}
inline void AssureRecordInfo::set_guaamt(const void* value, size_t size) {
  set_has_guaamt();
  if (guaamt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guaamt_ = new ::std::string;
  }
  guaamt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.AssureRecordInfo.guaAmt)
}
inline ::std::string* AssureRecordInfo::mutable_guaamt() {
  set_has_guaamt();
  if (guaamt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guaamt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.AssureRecordInfo.guaAmt)
  return guaamt_;
}
inline ::std::string* AssureRecordInfo::release_guaamt() {
  clear_has_guaamt();
  if (guaamt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guaamt_;
    guaamt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssureRecordInfo::set_allocated_guaamt(::std::string* guaamt) {
  if (guaamt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guaamt_;
  }
  if (guaamt) {
    set_has_guaamt();
    guaamt_ = guaamt;
  } else {
    clear_has_guaamt();
    guaamt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.AssureRecordInfo.guaAmt)
}

// -------------------------------------------------------------------

// ZhimaDataFlowReflux_ans

// optional .BUAS_QDP.UserCredentialsType user_credentials_type = 1;
inline bool ZhimaDataFlowReflux_ans::has_user_credentials_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_user_credentials_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_user_credentials_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZhimaDataFlowReflux_ans::clear_user_credentials_type() {
  user_credentials_type_ = 0;
  clear_has_user_credentials_type();
}
inline ::BUAS_QDP::UserCredentialsType ZhimaDataFlowReflux_ans::user_credentials_type() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.user_credentials_type)
  return static_cast< ::BUAS_QDP::UserCredentialsType >(user_credentials_type_);
}
inline void ZhimaDataFlowReflux_ans::set_user_credentials_type(::BUAS_QDP::UserCredentialsType value) {
  assert(::BUAS_QDP::UserCredentialsType_IsValid(value));
  set_has_user_credentials_type();
  user_credentials_type_ = value;
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.user_credentials_type)
}

// optional bytes identity_card = 2;
inline bool ZhimaDataFlowReflux_ans::has_identity_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_identity_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_identity_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZhimaDataFlowReflux_ans::clear_identity_card() {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_->clear();
  }
  clear_has_identity_card();
}
inline const ::std::string& ZhimaDataFlowReflux_ans::identity_card() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
  return *identity_card_;
}
inline void ZhimaDataFlowReflux_ans::set_identity_card(const ::std::string& value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
}
inline void ZhimaDataFlowReflux_ans::set_identity_card(const char* value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
}
inline void ZhimaDataFlowReflux_ans::set_identity_card(const void* value, size_t size) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
}
inline ::std::string* ZhimaDataFlowReflux_ans::mutable_identity_card() {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
  return identity_card_;
}
inline ::std::string* ZhimaDataFlowReflux_ans::release_identity_card() {
  clear_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = identity_card_;
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ans::set_allocated_identity_card(::std::string* identity_card) {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete identity_card_;
  }
  if (identity_card) {
    set_has_identity_card();
    identity_card_ = identity_card;
  } else {
    clear_has_identity_card();
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ans.identity_card)
}

// optional bytes real_name = 3;
inline bool ZhimaDataFlowReflux_ans::has_real_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_real_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZhimaDataFlowReflux_ans::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& ZhimaDataFlowReflux_ans::real_name() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
  return *real_name_;
}
inline void ZhimaDataFlowReflux_ans::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
}
inline void ZhimaDataFlowReflux_ans::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
}
inline void ZhimaDataFlowReflux_ans::set_real_name(const void* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
}
inline ::std::string* ZhimaDataFlowReflux_ans::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
  return real_name_;
}
inline ::std::string* ZhimaDataFlowReflux_ans::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ans::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ans.real_name)
}

// optional bytes mobile_phone = 4;
inline bool ZhimaDataFlowReflux_ans::has_mobile_phone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_mobile_phone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_mobile_phone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZhimaDataFlowReflux_ans::clear_mobile_phone() {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_->clear();
  }
  clear_has_mobile_phone();
}
inline const ::std::string& ZhimaDataFlowReflux_ans::mobile_phone() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
  return *mobile_phone_;
}
inline void ZhimaDataFlowReflux_ans::set_mobile_phone(const ::std::string& value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
}
inline void ZhimaDataFlowReflux_ans::set_mobile_phone(const char* value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
}
inline void ZhimaDataFlowReflux_ans::set_mobile_phone(const void* value, size_t size) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
}
inline ::std::string* ZhimaDataFlowReflux_ans::mutable_mobile_phone() {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
  return mobile_phone_;
}
inline ::std::string* ZhimaDataFlowReflux_ans::release_mobile_phone() {
  clear_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_phone_;
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ans::set_allocated_mobile_phone(::std::string* mobile_phone) {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_phone_;
  }
  if (mobile_phone) {
    set_has_mobile_phone();
    mobile_phone_ = mobile_phone;
  } else {
    clear_has_mobile_phone();
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ans.mobile_phone)
}

// repeated .BUAS_QDP.LoanRecordInfo loan_info = 5;
inline int ZhimaDataFlowReflux_ans::loan_info_size() const {
  return loan_info_.size();
}
inline void ZhimaDataFlowReflux_ans::clear_loan_info() {
  loan_info_.Clear();
}
inline const ::BUAS_QDP::LoanRecordInfo& ZhimaDataFlowReflux_ans::loan_info(int index) const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.loan_info)
  return loan_info_.Get(index);
}
inline ::BUAS_QDP::LoanRecordInfo* ZhimaDataFlowReflux_ans::mutable_loan_info(int index) {
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.loan_info)
  return loan_info_.Mutable(index);
}
inline ::BUAS_QDP::LoanRecordInfo* ZhimaDataFlowReflux_ans::add_loan_info() {
  // @@protoc_insertion_point(field_add:BUAS_QDP.ZhimaDataFlowReflux_ans.loan_info)
  return loan_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LoanRecordInfo >&
ZhimaDataFlowReflux_ans::loan_info() const {
  // @@protoc_insertion_point(field_list:BUAS_QDP.ZhimaDataFlowReflux_ans.loan_info)
  return loan_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::LoanRecordInfo >*
ZhimaDataFlowReflux_ans::mutable_loan_info() {
  // @@protoc_insertion_point(field_mutable_list:BUAS_QDP.ZhimaDataFlowReflux_ans.loan_info)
  return &loan_info_;
}

// repeated .BUAS_QDP.AssureRecordInfo assure_info = 6;
inline int ZhimaDataFlowReflux_ans::assure_info_size() const {
  return assure_info_.size();
}
inline void ZhimaDataFlowReflux_ans::clear_assure_info() {
  assure_info_.Clear();
}
inline const ::BUAS_QDP::AssureRecordInfo& ZhimaDataFlowReflux_ans::assure_info(int index) const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.assure_info)
  return assure_info_.Get(index);
}
inline ::BUAS_QDP::AssureRecordInfo* ZhimaDataFlowReflux_ans::mutable_assure_info(int index) {
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.assure_info)
  return assure_info_.Mutable(index);
}
inline ::BUAS_QDP::AssureRecordInfo* ZhimaDataFlowReflux_ans::add_assure_info() {
  // @@protoc_insertion_point(field_add:BUAS_QDP.ZhimaDataFlowReflux_ans.assure_info)
  return assure_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::AssureRecordInfo >&
ZhimaDataFlowReflux_ans::assure_info() const {
  // @@protoc_insertion_point(field_list:BUAS_QDP.ZhimaDataFlowReflux_ans.assure_info)
  return assure_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::BUAS_QDP::AssureRecordInfo >*
ZhimaDataFlowReflux_ans::mutable_assure_info() {
  // @@protoc_insertion_point(field_mutable_list:BUAS_QDP.ZhimaDataFlowReflux_ans.assure_info)
  return &assure_info_;
}

// optional bytes remindCnt = 7;
inline bool ZhimaDataFlowReflux_ans::has_remindcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_remindcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_remindcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZhimaDataFlowReflux_ans::clear_remindcnt() {
  if (remindcnt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remindcnt_->clear();
  }
  clear_has_remindcnt();
}
inline const ::std::string& ZhimaDataFlowReflux_ans::remindcnt() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
  return *remindcnt_;
}
inline void ZhimaDataFlowReflux_ans::set_remindcnt(const ::std::string& value) {
  set_has_remindcnt();
  if (remindcnt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remindcnt_ = new ::std::string;
  }
  remindcnt_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
}
inline void ZhimaDataFlowReflux_ans::set_remindcnt(const char* value) {
  set_has_remindcnt();
  if (remindcnt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remindcnt_ = new ::std::string;
  }
  remindcnt_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
}
inline void ZhimaDataFlowReflux_ans::set_remindcnt(const void* value, size_t size) {
  set_has_remindcnt();
  if (remindcnt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remindcnt_ = new ::std::string;
  }
  remindcnt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
}
inline ::std::string* ZhimaDataFlowReflux_ans::mutable_remindcnt() {
  set_has_remindcnt();
  if (remindcnt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remindcnt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
  return remindcnt_;
}
inline ::std::string* ZhimaDataFlowReflux_ans::release_remindcnt() {
  clear_has_remindcnt();
  if (remindcnt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remindcnt_;
    remindcnt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ans::set_allocated_remindcnt(::std::string* remindcnt) {
  if (remindcnt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remindcnt_;
  }
  if (remindcnt) {
    set_has_remindcnt();
    remindcnt_ = remindcnt;
  } else {
    clear_has_remindcnt();
    remindcnt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ans.remindCnt)
}

// optional bytes amtOverdue = 8;
inline bool ZhimaDataFlowReflux_ans::has_amtoverdue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZhimaDataFlowReflux_ans::set_has_amtoverdue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZhimaDataFlowReflux_ans::clear_has_amtoverdue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZhimaDataFlowReflux_ans::clear_amtoverdue() {
  if (amtoverdue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amtoverdue_->clear();
  }
  clear_has_amtoverdue();
}
inline const ::std::string& ZhimaDataFlowReflux_ans::amtoverdue() const {
  // @@protoc_insertion_point(field_get:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
  return *amtoverdue_;
}
inline void ZhimaDataFlowReflux_ans::set_amtoverdue(const ::std::string& value) {
  set_has_amtoverdue();
  if (amtoverdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amtoverdue_ = new ::std::string;
  }
  amtoverdue_->assign(value);
  // @@protoc_insertion_point(field_set:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
}
inline void ZhimaDataFlowReflux_ans::set_amtoverdue(const char* value) {
  set_has_amtoverdue();
  if (amtoverdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amtoverdue_ = new ::std::string;
  }
  amtoverdue_->assign(value);
  // @@protoc_insertion_point(field_set_char:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
}
inline void ZhimaDataFlowReflux_ans::set_amtoverdue(const void* value, size_t size) {
  set_has_amtoverdue();
  if (amtoverdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amtoverdue_ = new ::std::string;
  }
  amtoverdue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
}
inline ::std::string* ZhimaDataFlowReflux_ans::mutable_amtoverdue() {
  set_has_amtoverdue();
  if (amtoverdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amtoverdue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
  return amtoverdue_;
}
inline ::std::string* ZhimaDataFlowReflux_ans::release_amtoverdue() {
  clear_has_amtoverdue();
  if (amtoverdue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = amtoverdue_;
    amtoverdue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ZhimaDataFlowReflux_ans::set_allocated_amtoverdue(::std::string* amtoverdue) {
  if (amtoverdue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete amtoverdue_;
  }
  if (amtoverdue) {
    set_has_amtoverdue();
    amtoverdue_ = amtoverdue;
  } else {
    clear_has_amtoverdue();
    amtoverdue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BUAS_QDP.ZhimaDataFlowReflux_ans.amtOverdue)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BUAS_QDP

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::BUAS_QDP::UserCredentialsType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BUAS_QDP::UserCredentialsType>() {
  return ::BUAS_QDP::UserCredentialsType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UBAS_5fQDP_2eproto__INCLUDED
