// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: QDP_basic_info.proto

#ifndef PROTOBUF_QDP_5fbasic_5finfo_2eproto__INCLUDED
#define PROTOBUF_QDP_5fbasic_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace QDP_basic_info {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_QDP_5fbasic_5finfo_2eproto();
void protobuf_AssignDesc_QDP_5fbasic_5finfo_2eproto();
void protobuf_ShutdownFile_QDP_5fbasic_5finfo_2eproto();

class control_service;
class user_basic_info;

enum degree {
  low = 1,
  major = 2,
  college = 3,
  master = 4,
  doctor = 5
};
bool degree_IsValid(int value);
const degree degree_MIN = low;
const degree degree_MAX = doctor;
const int degree_ARRAYSIZE = degree_MAX + 1;

const ::google::protobuf::EnumDescriptor* degree_descriptor();
inline const ::std::string& degree_Name(degree value) {
  return ::google::protobuf::internal::NameOfEnum(
    degree_descriptor(), value);
}
inline bool degree_Parse(
    const ::std::string& name, degree* value) {
  return ::google::protobuf::internal::ParseNamedEnum<degree>(
    degree_descriptor(), name, value);
}
enum control_code {
  start = 0,
  stop = 1
};
bool control_code_IsValid(int value);
const control_code control_code_MIN = start;
const control_code control_code_MAX = stop;
const int control_code_ARRAYSIZE = control_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* control_code_descriptor();
inline const ::std::string& control_code_Name(control_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    control_code_descriptor(), value);
}
inline bool control_code_Parse(
    const ::std::string& name, control_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<control_code>(
    control_code_descriptor(), name, value);
}
// ===================================================================

class control_service : public ::google::protobuf::Message {
 public:
  control_service();
  virtual ~control_service();

  control_service(const control_service& from);

  inline control_service& operator=(const control_service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control_service& default_instance();

  void Swap(control_service* other);

  // implements Message ----------------------------------------------

  control_service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control_service& from);
  void MergeFrom(const control_service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .QDP_basic_info.control_code control = 1 [default = start];
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 1;
  inline ::QDP_basic_info::control_code control() const;
  inline void set_control(::QDP_basic_info::control_code value);

  // @@protoc_insertion_point(class_scope:QDP_basic_info.control_service)
 private:
  inline void set_has_control();
  inline void clear_has_control();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int control_;
  friend void  protobuf_AddDesc_QDP_5fbasic_5finfo_2eproto();
  friend void protobuf_AssignDesc_QDP_5fbasic_5finfo_2eproto();
  friend void protobuf_ShutdownFile_QDP_5fbasic_5finfo_2eproto();

  void InitAsDefaultInstance();
  static control_service* default_instance_;
};
// -------------------------------------------------------------------

class user_basic_info : public ::google::protobuf::Message {
 public:
  user_basic_info();
  virtual ~user_basic_info();

  user_basic_info(const user_basic_info& from);

  inline user_basic_info& operator=(const user_basic_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_basic_info& default_instance();

  void Swap(user_basic_info* other);

  // implements Message ----------------------------------------------

  user_basic_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_basic_info& from);
  void MergeFrom(const user_basic_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const void* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional bytes identity_card = 2;
  inline bool has_identity_card() const;
  inline void clear_identity_card();
  static const int kIdentityCardFieldNumber = 2;
  inline const ::std::string& identity_card() const;
  inline void set_identity_card(const ::std::string& value);
  inline void set_identity_card(const char* value);
  inline void set_identity_card(const void* value, size_t size);
  inline ::std::string* mutable_identity_card();
  inline ::std::string* release_identity_card();
  inline void set_allocated_identity_card(::std::string* identity_card);

  // optional bytes real_name = 3;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 3;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const void* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional bytes user_nickname = 4;
  inline bool has_user_nickname() const;
  inline void clear_user_nickname();
  static const int kUserNicknameFieldNumber = 4;
  inline const ::std::string& user_nickname() const;
  inline void set_user_nickname(const ::std::string& value);
  inline void set_user_nickname(const char* value);
  inline void set_user_nickname(const void* value, size_t size);
  inline ::std::string* mutable_user_nickname();
  inline ::std::string* release_user_nickname();
  inline void set_allocated_user_nickname(::std::string* user_nickname);

  // optional bytes mobile_phone = 5;
  inline bool has_mobile_phone() const;
  inline void clear_mobile_phone();
  static const int kMobilePhoneFieldNumber = 5;
  inline const ::std::string& mobile_phone() const;
  inline void set_mobile_phone(const ::std::string& value);
  inline void set_mobile_phone(const char* value);
  inline void set_mobile_phone(const void* value, size_t size);
  inline ::std::string* mutable_mobile_phone();
  inline ::std::string* release_mobile_phone();
  inline void set_allocated_mobile_phone(::std::string* mobile_phone);

  // optional bytes email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const void* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional bytes address = 7;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 7;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes bank_cart = 8;
  inline bool has_bank_cart() const;
  inline void clear_bank_cart();
  static const int kBankCartFieldNumber = 8;
  inline const ::std::string& bank_cart() const;
  inline void set_bank_cart(const ::std::string& value);
  inline void set_bank_cart(const char* value);
  inline void set_bank_cart(const void* value, size_t size);
  inline ::std::string* mutable_bank_cart();
  inline ::std::string* release_bank_cart();
  inline void set_allocated_bank_cart(::std::string* bank_cart);

  // optional bytes ip = 9;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 9;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional bytes mac = 10;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 10;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const void* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional bytes imei = 11;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 11;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const void* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional bytes collegeName = 12;
  inline bool has_collegename() const;
  inline void clear_collegename();
  static const int kCollegeNameFieldNumber = 12;
  inline const ::std::string& collegename() const;
  inline void set_collegename(const ::std::string& value);
  inline void set_collegename(const char* value);
  inline void set_collegename(const void* value, size_t size);
  inline ::std::string* mutable_collegename();
  inline ::std::string* release_collegename();
  inline void set_allocated_collegename(::std::string* collegename);

  // optional .QDP_basic_info.degree eductionDegree = 13;
  inline bool has_eductiondegree() const;
  inline void clear_eductiondegree();
  static const int kEductionDegreeFieldNumber = 13;
  inline ::QDP_basic_info::degree eductiondegree() const;
  inline void set_eductiondegree(::QDP_basic_info::degree value);

  // optional bytes educationCategory = 14;
  inline bool has_educationcategory() const;
  inline void clear_educationcategory();
  static const int kEducationCategoryFieldNumber = 14;
  inline const ::std::string& educationcategory() const;
  inline void set_educationcategory(const ::std::string& value);
  inline void set_educationcategory(const char* value);
  inline void set_educationcategory(const void* value, size_t size);
  inline ::std::string* mutable_educationcategory();
  inline ::std::string* release_educationcategory();
  inline void set_allocated_educationcategory(::std::string* educationcategory);

  // optional bytes graduateYear = 15;
  inline bool has_graduateyear() const;
  inline void clear_graduateyear();
  static const int kGraduateYearFieldNumber = 15;
  inline const ::std::string& graduateyear() const;
  inline void set_graduateyear(const ::std::string& value);
  inline void set_graduateyear(const char* value);
  inline void set_graduateyear(const void* value, size_t size);
  inline ::std::string* mutable_graduateyear();
  inline ::std::string* release_graduateyear();
  inline void set_allocated_graduateyear(::std::string* graduateyear);

  // optional bytes enrollmentYear = 16;
  inline bool has_enrollmentyear() const;
  inline void clear_enrollmentyear();
  static const int kEnrollmentYearFieldNumber = 16;
  inline const ::std::string& enrollmentyear() const;
  inline void set_enrollmentyear(const ::std::string& value);
  inline void set_enrollmentyear(const char* value);
  inline void set_enrollmentyear(const void* value, size_t size);
  inline ::std::string* mutable_enrollmentyear();
  inline ::std::string* release_enrollmentyear();
  inline void set_allocated_enrollmentyear(::std::string* enrollmentyear);

  // optional bytes blackBox = 17;
  inline bool has_blackbox() const;
  inline void clear_blackbox();
  static const int kBlackBoxFieldNumber = 17;
  inline const ::std::string& blackbox() const;
  inline void set_blackbox(const ::std::string& value);
  inline void set_blackbox(const char* value);
  inline void set_blackbox(const void* value, size_t size);
  inline ::std::string* mutable_blackbox();
  inline ::std::string* release_blackbox();
  inline void set_allocated_blackbox(::std::string* blackbox);

  // optional bytes password = 18;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 18;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool is_prove = 19;
  inline bool has_is_prove() const;
  inline void clear_is_prove();
  static const int kIsProveFieldNumber = 19;
  inline bool is_prove() const;
  inline void set_is_prove(bool value);

  // optional bytes transDate = 20;
  inline bool has_transdate() const;
  inline void clear_transdate();
  static const int kTransDateFieldNumber = 20;
  inline const ::std::string& transdate() const;
  inline void set_transdate(const ::std::string& value);
  inline void set_transdate(const char* value);
  inline void set_transdate(const void* value, size_t size);
  inline ::std::string* mutable_transdate();
  inline ::std::string* release_transdate();
  inline void set_allocated_transdate(::std::string* transdate);

  // optional bytes currency = 21;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 21;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const void* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes transAmount = 22;
  inline bool has_transamount() const;
  inline void clear_transamount();
  static const int kTransAmountFieldNumber = 22;
  inline const ::std::string& transamount() const;
  inline void set_transamount(const ::std::string& value);
  inline void set_transamount(const char* value);
  inline void set_transamount(const void* value, size_t size);
  inline ::std::string* mutable_transamount();
  inline ::std::string* release_transamount();
  inline void set_allocated_transamount(::std::string* transamount);

  // optional bytes idNo = 23;
  inline bool has_idno() const;
  inline void clear_idno();
  static const int kIdNoFieldNumber = 23;
  inline const ::std::string& idno() const;
  inline void set_idno(const ::std::string& value);
  inline void set_idno(const char* value);
  inline void set_idno(const void* value, size_t size);
  inline ::std::string* mutable_idno();
  inline ::std::string* release_idno();
  inline void set_allocated_idno(::std::string* idno);

  // optional bytes idType = 24;
  inline bool has_idtype() const;
  inline void clear_idtype();
  static const int kIdTypeFieldNumber = 24;
  inline const ::std::string& idtype() const;
  inline void set_idtype(const ::std::string& value);
  inline void set_idtype(const char* value);
  inline void set_idtype(const void* value, size_t size);
  inline ::std::string* mutable_idtype();
  inline ::std::string* release_idtype();
  inline void set_allocated_idtype(::std::string* idtype);

  // optional bytes name = 25;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 25;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes reasonNo = 26;
  inline bool has_reasonno() const;
  inline void clear_reasonno();
  static const int kReasonNoFieldNumber = 26;
  inline const ::std::string& reasonno() const;
  inline void set_reasonno(const ::std::string& value);
  inline void set_reasonno(const char* value);
  inline void set_reasonno(const void* value, size_t size);
  inline ::std::string* mutable_reasonno();
  inline ::std::string* release_reasonno();
  inline void set_allocated_reasonno(::std::string* reasonno);

  // optional bytes weiboNo = 27;
  inline bool has_weibono() const;
  inline void clear_weibono();
  static const int kWeiboNoFieldNumber = 27;
  inline const ::std::string& weibono() const;
  inline void set_weibono(const ::std::string& value);
  inline void set_weibono(const char* value);
  inline void set_weibono(const void* value, size_t size);
  inline ::std::string* mutable_weibono();
  inline ::std::string* release_weibono();
  inline void set_allocated_weibono(::std::string* weibono);

  // optional bytes weixinNo = 28;
  inline bool has_weixinno() const;
  inline void clear_weixinno();
  static const int kWeixinNoFieldNumber = 28;
  inline const ::std::string& weixinno() const;
  inline void set_weixinno(const ::std::string& value);
  inline void set_weixinno(const char* value);
  inline void set_weixinno(const void* value, size_t size);
  inline ::std::string* mutable_weixinno();
  inline ::std::string* release_weixinno();
  inline void set_allocated_weixinno(::std::string* weixinno);

  // optional bytes qqNo = 29;
  inline bool has_qqno() const;
  inline void clear_qqno();
  static const int kQqNoFieldNumber = 29;
  inline const ::std::string& qqno() const;
  inline void set_qqno(const ::std::string& value);
  inline void set_qqno(const char* value);
  inline void set_qqno(const void* value, size_t size);
  inline ::std::string* mutable_qqno();
  inline ::std::string* release_qqno();
  inline void set_allocated_qqno(::std::string* qqno);

  // optional bytes taobaoNo = 30;
  inline bool has_taobaono() const;
  inline void clear_taobaono();
  static const int kTaobaoNoFieldNumber = 30;
  inline const ::std::string& taobaono() const;
  inline void set_taobaono(const ::std::string& value);
  inline void set_taobaono(const char* value);
  inline void set_taobaono(const void* value, size_t size);
  inline ::std::string* mutable_taobaono();
  inline ::std::string* release_taobaono();
  inline void set_allocated_taobaono(::std::string* taobaono);

  // optional bytes jdNo = 31;
  inline bool has_jdno() const;
  inline void clear_jdno();
  static const int kJdNoFieldNumber = 31;
  inline const ::std::string& jdno() const;
  inline void set_jdno(const ::std::string& value);
  inline void set_jdno(const char* value);
  inline void set_jdno(const void* value, size_t size);
  inline ::std::string* mutable_jdno();
  inline ::std::string* release_jdno();
  inline void set_allocated_jdno(::std::string* jdno);

  // optional bytes amazonNo = 32;
  inline bool has_amazonno() const;
  inline void clear_amazonno();
  static const int kAmazonNoFieldNumber = 32;
  inline const ::std::string& amazonno() const;
  inline void set_amazonno(const ::std::string& value);
  inline void set_amazonno(const char* value);
  inline void set_amazonno(const void* value, size_t size);
  inline ::std::string* mutable_amazonno();
  inline ::std::string* release_amazonno();
  inline void set_allocated_amazonno(::std::string* amazonno);

  // optional bytes yhdNo = 33;
  inline bool has_yhdno() const;
  inline void clear_yhdno();
  static const int kYhdNoFieldNumber = 33;
  inline const ::std::string& yhdno() const;
  inline void set_yhdno(const ::std::string& value);
  inline void set_yhdno(const char* value);
  inline void set_yhdno(const void* value, size_t size);
  inline ::std::string* mutable_yhdno();
  inline ::std::string* release_yhdno();
  inline void set_allocated_yhdno(::std::string* yhdno);

  // optional bytes home_addr = 34;
  inline bool has_home_addr() const;
  inline void clear_home_addr();
  static const int kHomeAddrFieldNumber = 34;
  inline const ::std::string& home_addr() const;
  inline void set_home_addr(const ::std::string& value);
  inline void set_home_addr(const char* value);
  inline void set_home_addr(const void* value, size_t size);
  inline ::std::string* mutable_home_addr();
  inline ::std::string* release_home_addr();
  inline void set_allocated_home_addr(::std::string* home_addr);

  // optional bytes biz_addr = 35;
  inline bool has_biz_addr() const;
  inline void clear_biz_addr();
  static const int kBizAddrFieldNumber = 35;
  inline const ::std::string& biz_addr() const;
  inline void set_biz_addr(const ::std::string& value);
  inline void set_biz_addr(const char* value);
  inline void set_biz_addr(const void* value, size_t size);
  inline ::std::string* mutable_biz_addr();
  inline ::std::string* release_biz_addr();
  inline void set_allocated_biz_addr(::std::string* biz_addr);

  // optional bytes per_addr = 36;
  inline bool has_per_addr() const;
  inline void clear_per_addr();
  static const int kPerAddrFieldNumber = 36;
  inline const ::std::string& per_addr() const;
  inline void set_per_addr(const ::std::string& value);
  inline void set_per_addr(const char* value);
  inline void set_per_addr(const void* value, size_t size);
  inline ::std::string* mutable_per_addr();
  inline ::std::string* release_per_addr();
  inline void set_allocated_per_addr(::std::string* per_addr);

  // optional bytes apply_addr = 37;
  inline bool has_apply_addr() const;
  inline void clear_apply_addr();
  static const int kApplyAddrFieldNumber = 37;
  inline const ::std::string& apply_addr() const;
  inline void set_apply_addr(const ::std::string& value);
  inline void set_apply_addr(const char* value);
  inline void set_apply_addr(const void* value, size_t size);
  inline ::std::string* mutable_apply_addr();
  inline ::std::string* release_apply_addr();
  inline void set_allocated_apply_addr(::std::string* apply_addr);

  // optional bytes tel_biz = 38;
  inline bool has_tel_biz() const;
  inline void clear_tel_biz();
  static const int kTelBizFieldNumber = 38;
  inline const ::std::string& tel_biz() const;
  inline void set_tel_biz(const ::std::string& value);
  inline void set_tel_biz(const char* value);
  inline void set_tel_biz(const void* value, size_t size);
  inline ::std::string* mutable_tel_biz();
  inline ::std::string* release_tel_biz();
  inline void set_allocated_tel_biz(::std::string* tel_biz);

  // optional bytes tel_home = 39;
  inline bool has_tel_home() const;
  inline void clear_tel_home();
  static const int kTelHomeFieldNumber = 39;
  inline const ::std::string& tel_home() const;
  inline void set_tel_home(const ::std::string& value);
  inline void set_tel_home(const char* value);
  inline void set_tel_home(const void* value, size_t size);
  inline ::std::string* mutable_tel_home();
  inline ::std::string* release_tel_home();
  inline void set_allocated_tel_home(::std::string* tel_home);

  // optional bytes educationallevel = 40;
  inline bool has_educationallevel() const;
  inline void clear_educationallevel();
  static const int kEducationallevelFieldNumber = 40;
  inline const ::std::string& educationallevel() const;
  inline void set_educationallevel(const ::std::string& value);
  inline void set_educationallevel(const char* value);
  inline void set_educationallevel(const void* value, size_t size);
  inline ::std::string* mutable_educationallevel();
  inline ::std::string* release_educationallevel();
  inline void set_allocated_educationallevel(::std::string* educationallevel);

  // optional bytes marriage = 41;
  inline bool has_marriage() const;
  inline void clear_marriage();
  static const int kMarriageFieldNumber = 41;
  inline const ::std::string& marriage() const;
  inline void set_marriage(const ::std::string& value);
  inline void set_marriage(const char* value);
  inline void set_marriage(const void* value, size_t size);
  inline ::std::string* mutable_marriage();
  inline ::std::string* release_marriage();
  inline void set_allocated_marriage(::std::string* marriage);

  // optional bytes income = 42;
  inline bool has_income() const;
  inline void clear_income();
  static const int kIncomeFieldNumber = 42;
  inline const ::std::string& income() const;
  inline void set_income(const ::std::string& value);
  inline void set_income(const char* value);
  inline void set_income(const void* value, size_t size);
  inline ::std::string* mutable_income();
  inline ::std::string* release_income();
  inline void set_allocated_income(::std::string* income);

  // optional bytes biz_workfor = 43;
  inline bool has_biz_workfor() const;
  inline void clear_biz_workfor();
  static const int kBizWorkforFieldNumber = 43;
  inline const ::std::string& biz_workfor() const;
  inline void set_biz_workfor(const ::std::string& value);
  inline void set_biz_workfor(const char* value);
  inline void set_biz_workfor(const void* value, size_t size);
  inline ::std::string* mutable_biz_workfor();
  inline ::std::string* release_biz_workfor();
  inline void set_allocated_biz_workfor(::std::string* biz_workfor);

  // optional bytes apply_source = 44;
  inline bool has_apply_source() const;
  inline void clear_apply_source();
  static const int kApplySourceFieldNumber = 44;
  inline const ::std::string& apply_source() const;
  inline void set_apply_source(const ::std::string& value);
  inline void set_apply_source(const char* value);
  inline void set_apply_source(const void* value, size_t size);
  inline ::std::string* mutable_apply_source();
  inline ::std::string* release_apply_source();
  inline void set_allocated_apply_source(::std::string* apply_source);

  // optional bytes apply_product = 45;
  inline bool has_apply_product() const;
  inline void clear_apply_product();
  static const int kApplyProductFieldNumber = 45;
  inline const ::std::string& apply_product() const;
  inline void set_apply_product(const ::std::string& value);
  inline void set_apply_product(const char* value);
  inline void set_apply_product(const void* value, size_t size);
  inline ::std::string* mutable_apply_product();
  inline ::std::string* release_apply_product();
  inline void set_allocated_apply_product(::std::string* apply_product);

  // optional bytes refund_type = 46;
  inline bool has_refund_type() const;
  inline void clear_refund_type();
  static const int kRefundTypeFieldNumber = 46;
  inline const ::std::string& refund_type() const;
  inline void set_refund_type(const ::std::string& value);
  inline void set_refund_type(const char* value);
  inline void set_refund_type(const void* value, size_t size);
  inline ::std::string* mutable_refund_type();
  inline ::std::string* release_refund_type();
  inline void set_allocated_refund_type(::std::string* refund_type);

  // optional bytes applyQuota = 47;
  inline bool has_applyquota() const;
  inline void clear_applyquota();
  static const int kApplyQuotaFieldNumber = 47;
  inline const ::std::string& applyquota() const;
  inline void set_applyquota(const ::std::string& value);
  inline void set_applyquota(const char* value);
  inline void set_applyquota(const void* value, size_t size);
  inline ::std::string* mutable_applyquota();
  inline ::std::string* release_applyquota();
  inline void set_allocated_applyquota(::std::string* applyquota);

  // optional bytes apply_time = 48;
  inline bool has_apply_time() const;
  inline void clear_apply_time();
  static const int kApplyTimeFieldNumber = 48;
  inline const ::std::string& apply_time() const;
  inline void set_apply_time(const ::std::string& value);
  inline void set_apply_time(const char* value);
  inline void set_apply_time(const void* value, size_t size);
  inline ::std::string* mutable_apply_time();
  inline ::std::string* release_apply_time();
  inline void set_allocated_apply_time(::std::string* apply_time);

  // optional bytes loanPeriod = 49;
  inline bool has_loanperiod() const;
  inline void clear_loanperiod();
  static const int kLoanPeriodFieldNumber = 49;
  inline const ::std::string& loanperiod() const;
  inline void set_loanperiod(const ::std::string& value);
  inline void set_loanperiod(const char* value);
  inline void set_loanperiod(const void* value, size_t size);
  inline ::std::string* mutable_loanperiod();
  inline ::std::string* release_loanperiod();
  inline void set_allocated_loanperiod(::std::string* loanperiod);

  // optional bytes bank_id = 50;
  inline bool has_bank_id() const;
  inline void clear_bank_id();
  static const int kBankIdFieldNumber = 50;
  inline const ::std::string& bank_id() const;
  inline void set_bank_id(const ::std::string& value);
  inline void set_bank_id(const char* value);
  inline void set_bank_id(const void* value, size_t size);
  inline ::std::string* mutable_bank_id();
  inline ::std::string* release_bank_id();
  inline void set_allocated_bank_id(::std::string* bank_id);

  // optional bytes linkman_name = 51;
  inline bool has_linkman_name() const;
  inline void clear_linkman_name();
  static const int kLinkmanNameFieldNumber = 51;
  inline const ::std::string& linkman_name() const;
  inline void set_linkman_name(const ::std::string& value);
  inline void set_linkman_name(const char* value);
  inline void set_linkman_name(const void* value, size_t size);
  inline ::std::string* mutable_linkman_name();
  inline ::std::string* release_linkman_name();
  inline void set_allocated_linkman_name(::std::string* linkman_name);

  // optional bytes linkman_cell = 52;
  inline bool has_linkman_cell() const;
  inline void clear_linkman_cell();
  static const int kLinkmanCellFieldNumber = 52;
  inline const ::std::string& linkman_cell() const;
  inline void set_linkman_cell(const ::std::string& value);
  inline void set_linkman_cell(const char* value);
  inline void set_linkman_cell(const void* value, size_t size);
  inline ::std::string* mutable_linkman_cell();
  inline ::std::string* release_linkman_cell();
  inline void set_allocated_linkman_cell(::std::string* linkman_cell);

  // optional bytes linkman_rela = 53;
  inline bool has_linkman_rela() const;
  inline void clear_linkman_rela();
  static const int kLinkmanRelaFieldNumber = 53;
  inline const ::std::string& linkman_rela() const;
  inline void set_linkman_rela(const ::std::string& value);
  inline void set_linkman_rela(const char* value);
  inline void set_linkman_rela(const void* value, size_t size);
  inline ::std::string* mutable_linkman_rela();
  inline ::std::string* release_linkman_rela();
  inline void set_allocated_linkman_rela(::std::string* linkman_rela);

  // optional bytes token_id = 54;
  inline bool has_token_id() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 54;
  inline const ::std::string& token_id() const;
  inline void set_token_id(const ::std::string& value);
  inline void set_token_id(const char* value);
  inline void set_token_id(const void* value, size_t size);
  inline ::std::string* mutable_token_id();
  inline ::std::string* release_token_id();
  inline void set_allocated_token_id(::std::string* token_id);

  // optional bytes user_agent_cust = 55;
  inline bool has_user_agent_cust() const;
  inline void clear_user_agent_cust();
  static const int kUserAgentCustFieldNumber = 55;
  inline const ::std::string& user_agent_cust() const;
  inline void set_user_agent_cust(const ::std::string& value);
  inline void set_user_agent_cust(const char* value);
  inline void set_user_agent_cust(const void* value, size_t size);
  inline ::std::string* mutable_user_agent_cust();
  inline ::std::string* release_user_agent_cust();
  inline void set_allocated_user_agent_cust(::std::string* user_agent_cust);

  // optional bytes refer_cust = 56;
  inline bool has_refer_cust() const;
  inline void clear_refer_cust();
  static const int kReferCustFieldNumber = 56;
  inline const ::std::string& refer_cust() const;
  inline void set_refer_cust(const ::std::string& value);
  inline void set_refer_cust(const char* value);
  inline void set_refer_cust(const void* value, size_t size);
  inline ::std::string* mutable_refer_cust();
  inline ::std::string* release_refer_cust();
  inline void set_allocated_refer_cust(::std::string* refer_cust);

  // optional bytes state = 57;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 57;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const void* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional bytes card_number = 58;
  inline bool has_card_number() const;
  inline void clear_card_number();
  static const int kCardNumberFieldNumber = 58;
  inline const ::std::string& card_number() const;
  inline void set_card_number(const ::std::string& value);
  inline void set_card_number(const char* value);
  inline void set_card_number(const void* value, size_t size);
  inline ::std::string* mutable_card_number();
  inline ::std::string* release_card_number();
  inline void set_allocated_card_number(::std::string* card_number);

  // optional bytes cc_bin = 59;
  inline bool has_cc_bin() const;
  inline void clear_cc_bin();
  static const int kCcBinFieldNumber = 59;
  inline const ::std::string& cc_bin() const;
  inline void set_cc_bin(const ::std::string& value);
  inline void set_cc_bin(const char* value);
  inline void set_cc_bin(const void* value, size_t size);
  inline ::std::string* mutable_cc_bin();
  inline ::std::string* release_cc_bin();
  inline void set_allocated_cc_bin(::std::string* cc_bin);

  // optional bytes pay_amount = 60;
  inline bool has_pay_amount() const;
  inline void clear_pay_amount();
  static const int kPayAmountFieldNumber = 60;
  inline const ::std::string& pay_amount() const;
  inline void set_pay_amount(const ::std::string& value);
  inline void set_pay_amount(const char* value);
  inline void set_pay_amount(const void* value, size_t size);
  inline ::std::string* mutable_pay_amount();
  inline ::std::string* release_pay_amount();
  inline void set_allocated_pay_amount(::std::string* pay_amount);

  // optional bytes pay_method = 61;
  inline bool has_pay_method() const;
  inline void clear_pay_method();
  static const int kPayMethodFieldNumber = 61;
  inline const ::std::string& pay_method() const;
  inline void set_pay_method(const ::std::string& value);
  inline void set_pay_method(const char* value);
  inline void set_pay_method(const void* value, size_t size);
  inline ::std::string* mutable_pay_method();
  inline ::std::string* release_pay_method();
  inline void set_allocated_pay_method(::std::string* pay_method);

  // optional bytes account_login = 62;
  inline bool has_account_login() const;
  inline void clear_account_login();
  static const int kAccountLoginFieldNumber = 62;
  inline const ::std::string& account_login() const;
  inline void set_account_login(const ::std::string& value);
  inline void set_account_login(const char* value);
  inline void set_account_login(const void* value, size_t size);
  inline ::std::string* mutable_account_login();
  inline ::std::string* release_account_login();
  inline void set_allocated_account_login(::std::string* account_login);

  // optional bytes customerName = 63;
  inline bool has_customername() const;
  inline void clear_customername();
  static const int kCustomerNameFieldNumber = 63;
  inline const ::std::string& customername() const;
  inline void set_customername(const ::std::string& value);
  inline void set_customername(const char* value);
  inline void set_customername(const void* value, size_t size);
  inline ::std::string* mutable_customername();
  inline ::std::string* release_customername();
  inline void set_allocated_customername(::std::string* customername);

  // optional bytes paperNumber = 64;
  inline bool has_papernumber() const;
  inline void clear_papernumber();
  static const int kPaperNumberFieldNumber = 64;
  inline const ::std::string& papernumber() const;
  inline void set_papernumber(const ::std::string& value);
  inline void set_papernumber(const char* value);
  inline void set_papernumber(const void* value, size_t size);
  inline ::std::string* mutable_papernumber();
  inline ::std::string* release_papernumber();
  inline void set_allocated_papernumber(::std::string* papernumber);

  // optional bytes applyId = 65;
  inline bool has_applyid() const;
  inline void clear_applyid();
  static const int kApplyIdFieldNumber = 65;
  inline const ::std::string& applyid() const;
  inline void set_applyid(const ::std::string& value);
  inline void set_applyid(const char* value);
  inline void set_applyid(const void* value, size_t size);
  inline ::std::string* mutable_applyid();
  inline ::std::string* release_applyid();
  inline void set_allocated_applyid(::std::string* applyid);

  // optional bytes loanType = 66;
  inline bool has_loantype() const;
  inline void clear_loantype();
  static const int kLoanTypeFieldNumber = 66;
  inline const ::std::string& loantype() const;
  inline void set_loantype(const ::std::string& value);
  inline void set_loantype(const char* value);
  inline void set_loantype(const void* value, size_t size);
  inline ::std::string* mutable_loantype();
  inline ::std::string* release_loantype();
  inline void set_allocated_loantype(::std::string* loantype);

  // optional double loanMoney = 67;
  inline bool has_loanmoney() const;
  inline void clear_loanmoney();
  static const int kLoanMoneyFieldNumber = 67;
  inline double loanmoney() const;
  inline void set_loanmoney(double value);

  // optional bytes currencyAnRong = 68;
  inline bool has_currencyanrong() const;
  inline void clear_currencyanrong();
  static const int kCurrencyAnRongFieldNumber = 68;
  inline const ::std::string& currencyanrong() const;
  inline void set_currencyanrong(const ::std::string& value);
  inline void set_currencyanrong(const char* value);
  inline void set_currencyanrong(const void* value, size_t size);
  inline ::std::string* mutable_currencyanrong();
  inline ::std::string* release_currencyanrong();
  inline void set_allocated_currencyanrong(::std::string* currencyanrong);

  // optional int32 loanTimeLimit = 69;
  inline bool has_loantimelimit() const;
  inline void clear_loantimelimit();
  static const int kLoanTimeLimitFieldNumber = 69;
  inline ::google::protobuf::int32 loantimelimit() const;
  inline void set_loantimelimit(::google::protobuf::int32 value);

  // optional bytes assureType = 70;
  inline bool has_assuretype() const;
  inline void clear_assuretype();
  static const int kAssureTypeFieldNumber = 70;
  inline const ::std::string& assuretype() const;
  inline void set_assuretype(const ::std::string& value);
  inline void set_assuretype(const char* value);
  inline void set_assuretype(const void* value, size_t size);
  inline ::std::string* mutable_assuretype();
  inline ::std::string* release_assuretype();
  inline void set_allocated_assuretype(::std::string* assuretype);

  // optional bytes applyDate = 71;
  inline bool has_applydate() const;
  inline void clear_applydate();
  static const int kApplyDateFieldNumber = 71;
  inline const ::std::string& applydate() const;
  inline void set_applydate(const ::std::string& value);
  inline void set_applydate(const char* value);
  inline void set_applydate(const void* value, size_t size);
  inline ::std::string* mutable_applydate();
  inline ::std::string* release_applydate();
  inline void set_allocated_applydate(::std::string* applydate);

  // optional bytes creditAddress = 72;
  inline bool has_creditaddress() const;
  inline void clear_creditaddress();
  static const int kCreditAddressFieldNumber = 72;
  inline const ::std::string& creditaddress() const;
  inline void set_creditaddress(const ::std::string& value);
  inline void set_creditaddress(const char* value);
  inline void set_creditaddress(const void* value, size_t size);
  inline ::std::string* mutable_creditaddress();
  inline ::std::string* release_creditaddress();
  inline void set_allocated_creditaddress(::std::string* creditaddress);

  // optional bytes applyResult = 73;
  inline bool has_applyresult() const;
  inline void clear_applyresult();
  static const int kApplyResultFieldNumber = 73;
  inline const ::std::string& applyresult() const;
  inline void set_applyresult(const ::std::string& value);
  inline void set_applyresult(const char* value);
  inline void set_applyresult(const void* value, size_t size);
  inline ::std::string* mutable_applyresult();
  inline ::std::string* release_applyresult();
  inline void set_allocated_applyresult(::std::string* applyresult);

  // optional bytes applyResultTime = 74;
  inline bool has_applyresulttime() const;
  inline void clear_applyresulttime();
  static const int kApplyResultTimeFieldNumber = 74;
  inline const ::std::string& applyresulttime() const;
  inline void set_applyresulttime(const ::std::string& value);
  inline void set_applyresulttime(const char* value);
  inline void set_applyresulttime(const void* value, size_t size);
  inline ::std::string* mutable_applyresulttime();
  inline ::std::string* release_applyresulttime();
  inline void set_allocated_applyresulttime(::std::string* applyresulttime);

  // optional bytes loanAccount = 75;
  inline bool has_loanaccount() const;
  inline void clear_loanaccount();
  static const int kLoanAccountFieldNumber = 75;
  inline const ::std::string& loanaccount() const;
  inline void set_loanaccount(const ::std::string& value);
  inline void set_loanaccount(const char* value);
  inline void set_loanaccount(const void* value, size_t size);
  inline ::std::string* mutable_loanaccount();
  inline ::std::string* release_loanaccount();
  inline void set_allocated_loanaccount(::std::string* loanaccount);

  // optional bytes creditStartDate = 76;
  inline bool has_creditstartdate() const;
  inline void clear_creditstartdate();
  static const int kCreditStartDateFieldNumber = 76;
  inline const ::std::string& creditstartdate() const;
  inline void set_creditstartdate(const ::std::string& value);
  inline void set_creditstartdate(const char* value);
  inline void set_creditstartdate(const void* value, size_t size);
  inline ::std::string* mutable_creditstartdate();
  inline ::std::string* release_creditstartdate();
  inline void set_allocated_creditstartdate(::std::string* creditstartdate);

  // optional bytes creditEndDate = 77;
  inline bool has_creditenddate() const;
  inline void clear_creditenddate();
  static const int kCreditEndDateFieldNumber = 77;
  inline const ::std::string& creditenddate() const;
  inline void set_creditenddate(const ::std::string& value);
  inline void set_creditenddate(const char* value);
  inline void set_creditenddate(const void* value, size_t size);
  inline ::std::string* mutable_creditenddate();
  inline ::std::string* release_creditenddate();
  inline void set_allocated_creditenddate(::std::string* creditenddate);

  // optional int32 loanPeriods = 78;
  inline bool has_loanperiods() const;
  inline void clear_loanperiods();
  static const int kLoanPeriodsFieldNumber = 78;
  inline ::google::protobuf::int32 loanperiods() const;
  inline void set_loanperiods(::google::protobuf::int32 value);

  // optional double backMoney = 79;
  inline bool has_backmoney() const;
  inline void clear_backmoney();
  static const int kBackMoneyFieldNumber = 79;
  inline double backmoney() const;
  inline void set_backmoney(double value);

  // optional bytes isClear = 80;
  inline bool has_isclear() const;
  inline void clear_isclear();
  static const int kIsClearFieldNumber = 80;
  inline const ::std::string& isclear() const;
  inline void set_isclear(const ::std::string& value);
  inline void set_isclear(const char* value);
  inline void set_isclear(const void* value, size_t size);
  inline ::std::string* mutable_isclear();
  inline ::std::string* release_isclear();
  inline void set_allocated_isclear(::std::string* isclear);

  // optional double nbsMoney = 81;
  inline bool has_nbsmoney() const;
  inline void clear_nbsmoney();
  static const int kNbsMoneyFieldNumber = 81;
  inline double nbsmoney() const;
  inline void set_nbsmoney(double value);

  // optional double nbMoney = 82;
  inline bool has_nbmoney() const;
  inline void clear_nbmoney();
  static const int kNbMoneyFieldNumber = 82;
  inline double nbmoney() const;
  inline void set_nbmoney(double value);

  // optional bytes cleanDate = 83;
  inline bool has_cleandate() const;
  inline void clear_cleandate();
  static const int kCleanDateFieldNumber = 83;
  inline const ::std::string& cleandate() const;
  inline void set_cleandate(const ::std::string& value);
  inline void set_cleandate(const char* value);
  inline void set_cleandate(const void* value, size_t size);
  inline ::std::string* mutable_cleandate();
  inline ::std::string* release_cleandate();
  inline void set_allocated_cleandate(::std::string* cleandate);

  // optional bytes overdueStartDate = 84;
  inline bool has_overduestartdate() const;
  inline void clear_overduestartdate();
  static const int kOverdueStartDateFieldNumber = 84;
  inline const ::std::string& overduestartdate() const;
  inline void set_overduestartdate(const ::std::string& value);
  inline void set_overduestartdate(const char* value);
  inline void set_overduestartdate(const void* value, size_t size);
  inline ::std::string* mutable_overduestartdate();
  inline ::std::string* release_overduestartdate();
  inline void set_allocated_overduestartdate(::std::string* overduestartdate);

  // optional bytes overdueEndDate = 85;
  inline bool has_overdueenddate() const;
  inline void clear_overdueenddate();
  static const int kOverdueEndDateFieldNumber = 85;
  inline const ::std::string& overdueenddate() const;
  inline void set_overdueenddate(const ::std::string& value);
  inline void set_overdueenddate(const char* value);
  inline void set_overdueenddate(const void* value, size_t size);
  inline ::std::string* mutable_overdueenddate();
  inline ::std::string* release_overdueenddate();
  inline void set_allocated_overdueenddate(::std::string* overdueenddate);

  // optional bytes overdueReason = 86;
  inline bool has_overduereason() const;
  inline void clear_overduereason();
  static const int kOverdueReasonFieldNumber = 86;
  inline const ::std::string& overduereason() const;
  inline void set_overduereason(const ::std::string& value);
  inline void set_overduereason(const char* value);
  inline void set_overduereason(const void* value, size_t size);
  inline ::std::string* mutable_overduereason();
  inline ::std::string* release_overduereason();
  inline void set_allocated_overduereason(::std::string* overduereason);

  // optional bytes overdueState = 87;
  inline bool has_overduestate() const;
  inline void clear_overduestate();
  static const int kOverdueStateFieldNumber = 87;
  inline const ::std::string& overduestate() const;
  inline void set_overduestate(const ::std::string& value);
  inline void set_overduestate(const char* value);
  inline void set_overduestate(const void* value, size_t size);
  inline ::std::string* mutable_overduestate();
  inline ::std::string* release_overduestate();
  inline void set_allocated_overduestate(::std::string* overduestate);

  // optional bytes relation_name = 88;
  inline bool has_relation_name() const;
  inline void clear_relation_name();
  static const int kRelationNameFieldNumber = 88;
  inline const ::std::string& relation_name() const;
  inline void set_relation_name(const ::std::string& value);
  inline void set_relation_name(const char* value);
  inline void set_relation_name(const void* value, size_t size);
  inline ::std::string* mutable_relation_name();
  inline ::std::string* release_relation_name();
  inline void set_allocated_relation_name(::std::string* relation_name);

  // optional bytes relation_phone = 89;
  inline bool has_relation_phone() const;
  inline void clear_relation_phone();
  static const int kRelationPhoneFieldNumber = 89;
  inline const ::std::string& relation_phone() const;
  inline void set_relation_phone(const ::std::string& value);
  inline void set_relation_phone(const char* value);
  inline void set_relation_phone(const void* value, size_t size);
  inline ::std::string* mutable_relation_phone();
  inline ::std::string* release_relation_phone();
  inline void set_allocated_relation_phone(::std::string* relation_phone);

  // optional bytes trading_address = 90;
  inline bool has_trading_address() const;
  inline void clear_trading_address();
  static const int kTradingAddressFieldNumber = 90;
  inline const ::std::string& trading_address() const;
  inline void set_trading_address(const ::std::string& value);
  inline void set_trading_address(const char* value);
  inline void set_trading_address(const void* value, size_t size);
  inline ::std::string* mutable_trading_address();
  inline ::std::string* release_trading_address();
  inline void set_allocated_trading_address(::std::string* trading_address);

  // optional bytes business = 91;
  inline bool has_business() const;
  inline void clear_business();
  static const int kBusinessFieldNumber = 91;
  inline const ::std::string& business() const;
  inline void set_business(const ::std::string& value);
  inline void set_business(const char* value);
  inline void set_business(const void* value, size_t size);
  inline ::std::string* mutable_business();
  inline ::std::string* release_business();
  inline void set_allocated_business(::std::string* business);

  // optional bytes levelNo = 92;
  inline bool has_levelno() const;
  inline void clear_levelno();
  static const int kLevelNoFieldNumber = 92;
  inline const ::std::string& levelno() const;
  inline void set_levelno(const ::std::string& value);
  inline void set_levelno(const char* value);
  inline void set_levelno(const void* value, size_t size);
  inline ::std::string* mutable_levelno();
  inline ::std::string* release_levelno();
  inline void set_allocated_levelno(::std::string* levelno);

  // optional bytes requestFileList = 93;
  inline bool has_requestfilelist() const;
  inline void clear_requestfilelist();
  static const int kRequestFileListFieldNumber = 93;
  inline const ::std::string& requestfilelist() const;
  inline void set_requestfilelist(const ::std::string& value);
  inline void set_requestfilelist(const char* value);
  inline void set_requestfilelist(const void* value, size_t size);
  inline ::std::string* mutable_requestfilelist();
  inline ::std::string* release_requestfilelist();
  inline void set_allocated_requestfilelist(::std::string* requestfilelist);

  // @@protoc_insertion_point(class_scope:QDP_basic_info.user_basic_info)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_identity_card();
  inline void clear_has_identity_card();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_user_nickname();
  inline void clear_has_user_nickname();
  inline void set_has_mobile_phone();
  inline void clear_has_mobile_phone();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_bank_cart();
  inline void clear_has_bank_cart();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_collegename();
  inline void clear_has_collegename();
  inline void set_has_eductiondegree();
  inline void clear_has_eductiondegree();
  inline void set_has_educationcategory();
  inline void clear_has_educationcategory();
  inline void set_has_graduateyear();
  inline void clear_has_graduateyear();
  inline void set_has_enrollmentyear();
  inline void clear_has_enrollmentyear();
  inline void set_has_blackbox();
  inline void clear_has_blackbox();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_is_prove();
  inline void clear_has_is_prove();
  inline void set_has_transdate();
  inline void clear_has_transdate();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_transamount();
  inline void clear_has_transamount();
  inline void set_has_idno();
  inline void clear_has_idno();
  inline void set_has_idtype();
  inline void clear_has_idtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_reasonno();
  inline void clear_has_reasonno();
  inline void set_has_weibono();
  inline void clear_has_weibono();
  inline void set_has_weixinno();
  inline void clear_has_weixinno();
  inline void set_has_qqno();
  inline void clear_has_qqno();
  inline void set_has_taobaono();
  inline void clear_has_taobaono();
  inline void set_has_jdno();
  inline void clear_has_jdno();
  inline void set_has_amazonno();
  inline void clear_has_amazonno();
  inline void set_has_yhdno();
  inline void clear_has_yhdno();
  inline void set_has_home_addr();
  inline void clear_has_home_addr();
  inline void set_has_biz_addr();
  inline void clear_has_biz_addr();
  inline void set_has_per_addr();
  inline void clear_has_per_addr();
  inline void set_has_apply_addr();
  inline void clear_has_apply_addr();
  inline void set_has_tel_biz();
  inline void clear_has_tel_biz();
  inline void set_has_tel_home();
  inline void clear_has_tel_home();
  inline void set_has_educationallevel();
  inline void clear_has_educationallevel();
  inline void set_has_marriage();
  inline void clear_has_marriage();
  inline void set_has_income();
  inline void clear_has_income();
  inline void set_has_biz_workfor();
  inline void clear_has_biz_workfor();
  inline void set_has_apply_source();
  inline void clear_has_apply_source();
  inline void set_has_apply_product();
  inline void clear_has_apply_product();
  inline void set_has_refund_type();
  inline void clear_has_refund_type();
  inline void set_has_applyquota();
  inline void clear_has_applyquota();
  inline void set_has_apply_time();
  inline void clear_has_apply_time();
  inline void set_has_loanperiod();
  inline void clear_has_loanperiod();
  inline void set_has_bank_id();
  inline void clear_has_bank_id();
  inline void set_has_linkman_name();
  inline void clear_has_linkman_name();
  inline void set_has_linkman_cell();
  inline void clear_has_linkman_cell();
  inline void set_has_linkman_rela();
  inline void clear_has_linkman_rela();
  inline void set_has_token_id();
  inline void clear_has_token_id();
  inline void set_has_user_agent_cust();
  inline void clear_has_user_agent_cust();
  inline void set_has_refer_cust();
  inline void clear_has_refer_cust();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_card_number();
  inline void clear_has_card_number();
  inline void set_has_cc_bin();
  inline void clear_has_cc_bin();
  inline void set_has_pay_amount();
  inline void clear_has_pay_amount();
  inline void set_has_pay_method();
  inline void clear_has_pay_method();
  inline void set_has_account_login();
  inline void clear_has_account_login();
  inline void set_has_customername();
  inline void clear_has_customername();
  inline void set_has_papernumber();
  inline void clear_has_papernumber();
  inline void set_has_applyid();
  inline void clear_has_applyid();
  inline void set_has_loantype();
  inline void clear_has_loantype();
  inline void set_has_loanmoney();
  inline void clear_has_loanmoney();
  inline void set_has_currencyanrong();
  inline void clear_has_currencyanrong();
  inline void set_has_loantimelimit();
  inline void clear_has_loantimelimit();
  inline void set_has_assuretype();
  inline void clear_has_assuretype();
  inline void set_has_applydate();
  inline void clear_has_applydate();
  inline void set_has_creditaddress();
  inline void clear_has_creditaddress();
  inline void set_has_applyresult();
  inline void clear_has_applyresult();
  inline void set_has_applyresulttime();
  inline void clear_has_applyresulttime();
  inline void set_has_loanaccount();
  inline void clear_has_loanaccount();
  inline void set_has_creditstartdate();
  inline void clear_has_creditstartdate();
  inline void set_has_creditenddate();
  inline void clear_has_creditenddate();
  inline void set_has_loanperiods();
  inline void clear_has_loanperiods();
  inline void set_has_backmoney();
  inline void clear_has_backmoney();
  inline void set_has_isclear();
  inline void clear_has_isclear();
  inline void set_has_nbsmoney();
  inline void clear_has_nbsmoney();
  inline void set_has_nbmoney();
  inline void clear_has_nbmoney();
  inline void set_has_cleandate();
  inline void clear_has_cleandate();
  inline void set_has_overduestartdate();
  inline void clear_has_overduestartdate();
  inline void set_has_overdueenddate();
  inline void clear_has_overdueenddate();
  inline void set_has_overduereason();
  inline void clear_has_overduereason();
  inline void set_has_overduestate();
  inline void clear_has_overduestate();
  inline void set_has_relation_name();
  inline void clear_has_relation_name();
  inline void set_has_relation_phone();
  inline void clear_has_relation_phone();
  inline void set_has_trading_address();
  inline void clear_has_trading_address();
  inline void set_has_business();
  inline void clear_has_business();
  inline void set_has_levelno();
  inline void clear_has_levelno();
  inline void set_has_requestfilelist();
  inline void clear_has_requestfilelist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[3];
  mutable int _cached_size_;
  ::std::string* user_id_;
  ::std::string* identity_card_;
  ::std::string* real_name_;
  ::std::string* user_nickname_;
  ::std::string* mobile_phone_;
  ::std::string* email_;
  ::std::string* address_;
  ::std::string* bank_cart_;
  ::std::string* ip_;
  ::std::string* mac_;
  ::std::string* imei_;
  ::std::string* collegename_;
  ::std::string* educationcategory_;
  ::std::string* graduateyear_;
  ::std::string* enrollmentyear_;
  int eductiondegree_;
  bool is_prove_;
  ::std::string* blackbox_;
  ::std::string* password_;
  ::std::string* transdate_;
  ::std::string* currency_;
  ::std::string* transamount_;
  ::std::string* idno_;
  ::std::string* idtype_;
  ::std::string* name_;
  ::std::string* reasonno_;
  ::std::string* weibono_;
  ::std::string* weixinno_;
  ::std::string* qqno_;
  ::std::string* taobaono_;
  ::std::string* jdno_;
  ::std::string* amazonno_;
  ::std::string* yhdno_;
  ::std::string* home_addr_;
  ::std::string* biz_addr_;
  ::std::string* per_addr_;
  ::std::string* apply_addr_;
  ::std::string* tel_biz_;
  ::std::string* tel_home_;
  ::std::string* educationallevel_;
  ::std::string* marriage_;
  ::std::string* income_;
  ::std::string* biz_workfor_;
  ::std::string* apply_source_;
  ::std::string* apply_product_;
  ::std::string* refund_type_;
  ::std::string* applyquota_;
  ::std::string* apply_time_;
  ::std::string* loanperiod_;
  ::std::string* bank_id_;
  ::std::string* linkman_name_;
  ::std::string* linkman_cell_;
  ::std::string* linkman_rela_;
  ::std::string* token_id_;
  ::std::string* user_agent_cust_;
  ::std::string* refer_cust_;
  ::std::string* state_;
  ::std::string* card_number_;
  ::std::string* cc_bin_;
  ::std::string* pay_amount_;
  ::std::string* pay_method_;
  ::std::string* account_login_;
  ::std::string* customername_;
  ::std::string* papernumber_;
  ::std::string* applyid_;
  ::std::string* loantype_;
  double loanmoney_;
  ::std::string* currencyanrong_;
  ::std::string* assuretype_;
  ::std::string* applydate_;
  ::std::string* creditaddress_;
  ::std::string* applyresult_;
  ::google::protobuf::int32 loantimelimit_;
  ::google::protobuf::int32 loanperiods_;
  ::std::string* applyresulttime_;
  ::std::string* loanaccount_;
  ::std::string* creditstartdate_;
  ::std::string* creditenddate_;
  double backmoney_;
  ::std::string* isclear_;
  double nbsmoney_;
  double nbmoney_;
  ::std::string* cleandate_;
  ::std::string* overduestartdate_;
  ::std::string* overdueenddate_;
  ::std::string* overduereason_;
  ::std::string* overduestate_;
  ::std::string* relation_name_;
  ::std::string* relation_phone_;
  ::std::string* trading_address_;
  ::std::string* business_;
  ::std::string* levelno_;
  ::std::string* requestfilelist_;
  friend void  protobuf_AddDesc_QDP_5fbasic_5finfo_2eproto();
  friend void protobuf_AssignDesc_QDP_5fbasic_5finfo_2eproto();
  friend void protobuf_ShutdownFile_QDP_5fbasic_5finfo_2eproto();

  void InitAsDefaultInstance();
  static user_basic_info* default_instance_;
};
// ===================================================================


// ===================================================================

// control_service

// optional .QDP_basic_info.control_code control = 1 [default = start];
inline bool control_service::has_control() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control_service::set_has_control() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control_service::clear_has_control() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control_service::clear_control() {
  control_ = 0;
  clear_has_control();
}
inline ::QDP_basic_info::control_code control_service::control() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.control_service.control)
  return static_cast< ::QDP_basic_info::control_code >(control_);
}
inline void control_service::set_control(::QDP_basic_info::control_code value) {
  assert(::QDP_basic_info::control_code_IsValid(value));
  set_has_control();
  control_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.control_service.control)
}

// -------------------------------------------------------------------

// user_basic_info

// optional bytes user_id = 1;
inline bool user_basic_info::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_basic_info::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_basic_info::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_basic_info::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& user_basic_info::user_id() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.user_id)
  return *user_id_;
}
inline void user_basic_info::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.user_id)
}
inline void user_basic_info::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.user_id)
}
inline void user_basic_info::set_user_id(const void* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.user_id)
}
inline ::std::string* user_basic_info::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.user_id)
  return user_id_;
}
inline ::std::string* user_basic_info::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.user_id)
}

// optional bytes identity_card = 2;
inline bool user_basic_info::has_identity_card() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_basic_info::set_has_identity_card() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_basic_info::clear_has_identity_card() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_basic_info::clear_identity_card() {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_->clear();
  }
  clear_has_identity_card();
}
inline const ::std::string& user_basic_info::identity_card() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.identity_card)
  return *identity_card_;
}
inline void user_basic_info::set_identity_card(const ::std::string& value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.identity_card)
}
inline void user_basic_info::set_identity_card(const char* value) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.identity_card)
}
inline void user_basic_info::set_identity_card(const void* value, size_t size) {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  identity_card_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.identity_card)
}
inline ::std::string* user_basic_info::mutable_identity_card() {
  set_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    identity_card_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.identity_card)
  return identity_card_;
}
inline ::std::string* user_basic_info::release_identity_card() {
  clear_has_identity_card();
  if (identity_card_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = identity_card_;
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_identity_card(::std::string* identity_card) {
  if (identity_card_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete identity_card_;
  }
  if (identity_card) {
    set_has_identity_card();
    identity_card_ = identity_card;
  } else {
    clear_has_identity_card();
    identity_card_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.identity_card)
}

// optional bytes real_name = 3;
inline bool user_basic_info::has_real_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_basic_info::set_has_real_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_basic_info::clear_has_real_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_basic_info::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& user_basic_info::real_name() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.real_name)
  return *real_name_;
}
inline void user_basic_info::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.real_name)
}
inline void user_basic_info::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.real_name)
}
inline void user_basic_info::set_real_name(const void* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.real_name)
}
inline ::std::string* user_basic_info::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.real_name)
  return real_name_;
}
inline ::std::string* user_basic_info::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.real_name)
}

// optional bytes user_nickname = 4;
inline bool user_basic_info::has_user_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_basic_info::set_has_user_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_basic_info::clear_has_user_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_basic_info::clear_user_nickname() {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_->clear();
  }
  clear_has_user_nickname();
}
inline const ::std::string& user_basic_info::user_nickname() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.user_nickname)
  return *user_nickname_;
}
inline void user_basic_info::set_user_nickname(const ::std::string& value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.user_nickname)
}
inline void user_basic_info::set_user_nickname(const char* value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.user_nickname)
}
inline void user_basic_info::set_user_nickname(const void* value, size_t size) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.user_nickname)
}
inline ::std::string* user_basic_info::mutable_user_nickname() {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.user_nickname)
  return user_nickname_;
}
inline ::std::string* user_basic_info::release_user_nickname() {
  clear_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_nickname_;
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_user_nickname(::std::string* user_nickname) {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nickname_;
  }
  if (user_nickname) {
    set_has_user_nickname();
    user_nickname_ = user_nickname;
  } else {
    clear_has_user_nickname();
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.user_nickname)
}

// optional bytes mobile_phone = 5;
inline bool user_basic_info::has_mobile_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_basic_info::set_has_mobile_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_basic_info::clear_has_mobile_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_basic_info::clear_mobile_phone() {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_->clear();
  }
  clear_has_mobile_phone();
}
inline const ::std::string& user_basic_info::mobile_phone() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.mobile_phone)
  return *mobile_phone_;
}
inline void user_basic_info::set_mobile_phone(const ::std::string& value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.mobile_phone)
}
inline void user_basic_info::set_mobile_phone(const char* value) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.mobile_phone)
}
inline void user_basic_info::set_mobile_phone(const void* value, size_t size) {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  mobile_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.mobile_phone)
}
inline ::std::string* user_basic_info::mutable_mobile_phone() {
  set_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.mobile_phone)
  return mobile_phone_;
}
inline ::std::string* user_basic_info::release_mobile_phone() {
  clear_has_mobile_phone();
  if (mobile_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_phone_;
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_mobile_phone(::std::string* mobile_phone) {
  if (mobile_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_phone_;
  }
  if (mobile_phone) {
    set_has_mobile_phone();
    mobile_phone_ = mobile_phone;
  } else {
    clear_has_mobile_phone();
    mobile_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.mobile_phone)
}

// optional bytes email = 6;
inline bool user_basic_info::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_basic_info::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_basic_info::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_basic_info::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& user_basic_info::email() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.email)
  return *email_;
}
inline void user_basic_info::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.email)
}
inline void user_basic_info::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.email)
}
inline void user_basic_info::set_email(const void* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.email)
}
inline ::std::string* user_basic_info::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.email)
  return email_;
}
inline ::std::string* user_basic_info::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.email)
}

// optional bytes address = 7;
inline bool user_basic_info::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_basic_info::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_basic_info::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_basic_info::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& user_basic_info::address() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.address)
  return *address_;
}
inline void user_basic_info::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.address)
}
inline void user_basic_info::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.address)
}
inline void user_basic_info::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.address)
}
inline ::std::string* user_basic_info::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.address)
  return address_;
}
inline ::std::string* user_basic_info::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.address)
}

// optional bytes bank_cart = 8;
inline bool user_basic_info::has_bank_cart() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_basic_info::set_has_bank_cart() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_basic_info::clear_has_bank_cart() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_basic_info::clear_bank_cart() {
  if (bank_cart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_->clear();
  }
  clear_has_bank_cart();
}
inline const ::std::string& user_basic_info::bank_cart() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.bank_cart)
  return *bank_cart_;
}
inline void user_basic_info::set_bank_cart(const ::std::string& value) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.bank_cart)
}
inline void user_basic_info::set_bank_cart(const char* value) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.bank_cart)
}
inline void user_basic_info::set_bank_cart(const void* value, size_t size) {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  bank_cart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.bank_cart)
}
inline ::std::string* user_basic_info::mutable_bank_cart() {
  set_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_cart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.bank_cart)
  return bank_cart_;
}
inline ::std::string* user_basic_info::release_bank_cart() {
  clear_has_bank_cart();
  if (bank_cart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bank_cart_;
    bank_cart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_bank_cart(::std::string* bank_cart) {
  if (bank_cart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bank_cart_;
  }
  if (bank_cart) {
    set_has_bank_cart();
    bank_cart_ = bank_cart;
  } else {
    clear_has_bank_cart();
    bank_cart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.bank_cart)
}

// optional bytes ip = 9;
inline bool user_basic_info::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_basic_info::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_basic_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_basic_info::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& user_basic_info::ip() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.ip)
  return *ip_;
}
inline void user_basic_info::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.ip)
}
inline void user_basic_info::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.ip)
}
inline void user_basic_info::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.ip)
}
inline ::std::string* user_basic_info::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.ip)
  return ip_;
}
inline ::std::string* user_basic_info::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.ip)
}

// optional bytes mac = 10;
inline bool user_basic_info::has_mac() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void user_basic_info::set_has_mac() {
  _has_bits_[0] |= 0x00000200u;
}
inline void user_basic_info::clear_has_mac() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void user_basic_info::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& user_basic_info::mac() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.mac)
  return *mac_;
}
inline void user_basic_info::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.mac)
}
inline void user_basic_info::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.mac)
}
inline void user_basic_info::set_mac(const void* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.mac)
}
inline ::std::string* user_basic_info::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.mac)
  return mac_;
}
inline ::std::string* user_basic_info::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.mac)
}

// optional bytes imei = 11;
inline bool user_basic_info::has_imei() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void user_basic_info::set_has_imei() {
  _has_bits_[0] |= 0x00000400u;
}
inline void user_basic_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void user_basic_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& user_basic_info::imei() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.imei)
  return *imei_;
}
inline void user_basic_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.imei)
}
inline void user_basic_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.imei)
}
inline void user_basic_info::set_imei(const void* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.imei)
}
inline ::std::string* user_basic_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.imei)
  return imei_;
}
inline ::std::string* user_basic_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.imei)
}

// optional bytes collegeName = 12;
inline bool user_basic_info::has_collegename() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void user_basic_info::set_has_collegename() {
  _has_bits_[0] |= 0x00000800u;
}
inline void user_basic_info::clear_has_collegename() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void user_basic_info::clear_collegename() {
  if (collegename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_->clear();
  }
  clear_has_collegename();
}
inline const ::std::string& user_basic_info::collegename() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.collegeName)
  return *collegename_;
}
inline void user_basic_info::set_collegename(const ::std::string& value) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.collegeName)
}
inline void user_basic_info::set_collegename(const char* value) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.collegeName)
}
inline void user_basic_info::set_collegename(const void* value, size_t size) {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  collegename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.collegeName)
}
inline ::std::string* user_basic_info::mutable_collegename() {
  set_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    collegename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.collegeName)
  return collegename_;
}
inline ::std::string* user_basic_info::release_collegename() {
  clear_has_collegename();
  if (collegename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = collegename_;
    collegename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_collegename(::std::string* collegename) {
  if (collegename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete collegename_;
  }
  if (collegename) {
    set_has_collegename();
    collegename_ = collegename;
  } else {
    clear_has_collegename();
    collegename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.collegeName)
}

// optional .QDP_basic_info.degree eductionDegree = 13;
inline bool user_basic_info::has_eductiondegree() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void user_basic_info::set_has_eductiondegree() {
  _has_bits_[0] |= 0x00001000u;
}
inline void user_basic_info::clear_has_eductiondegree() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void user_basic_info::clear_eductiondegree() {
  eductiondegree_ = 1;
  clear_has_eductiondegree();
}
inline ::QDP_basic_info::degree user_basic_info::eductiondegree() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.eductionDegree)
  return static_cast< ::QDP_basic_info::degree >(eductiondegree_);
}
inline void user_basic_info::set_eductiondegree(::QDP_basic_info::degree value) {
  assert(::QDP_basic_info::degree_IsValid(value));
  set_has_eductiondegree();
  eductiondegree_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.eductionDegree)
}

// optional bytes educationCategory = 14;
inline bool user_basic_info::has_educationcategory() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void user_basic_info::set_has_educationcategory() {
  _has_bits_[0] |= 0x00002000u;
}
inline void user_basic_info::clear_has_educationcategory() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void user_basic_info::clear_educationcategory() {
  if (educationcategory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_->clear();
  }
  clear_has_educationcategory();
}
inline const ::std::string& user_basic_info::educationcategory() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.educationCategory)
  return *educationcategory_;
}
inline void user_basic_info::set_educationcategory(const ::std::string& value) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.educationCategory)
}
inline void user_basic_info::set_educationcategory(const char* value) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.educationCategory)
}
inline void user_basic_info::set_educationcategory(const void* value, size_t size) {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  educationcategory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.educationCategory)
}
inline ::std::string* user_basic_info::mutable_educationcategory() {
  set_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationcategory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.educationCategory)
  return educationcategory_;
}
inline ::std::string* user_basic_info::release_educationcategory() {
  clear_has_educationcategory();
  if (educationcategory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = educationcategory_;
    educationcategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_educationcategory(::std::string* educationcategory) {
  if (educationcategory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete educationcategory_;
  }
  if (educationcategory) {
    set_has_educationcategory();
    educationcategory_ = educationcategory;
  } else {
    clear_has_educationcategory();
    educationcategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.educationCategory)
}

// optional bytes graduateYear = 15;
inline bool user_basic_info::has_graduateyear() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void user_basic_info::set_has_graduateyear() {
  _has_bits_[0] |= 0x00004000u;
}
inline void user_basic_info::clear_has_graduateyear() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void user_basic_info::clear_graduateyear() {
  if (graduateyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_->clear();
  }
  clear_has_graduateyear();
}
inline const ::std::string& user_basic_info::graduateyear() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.graduateYear)
  return *graduateyear_;
}
inline void user_basic_info::set_graduateyear(const ::std::string& value) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.graduateYear)
}
inline void user_basic_info::set_graduateyear(const char* value) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.graduateYear)
}
inline void user_basic_info::set_graduateyear(const void* value, size_t size) {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  graduateyear_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.graduateYear)
}
inline ::std::string* user_basic_info::mutable_graduateyear() {
  set_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    graduateyear_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.graduateYear)
  return graduateyear_;
}
inline ::std::string* user_basic_info::release_graduateyear() {
  clear_has_graduateyear();
  if (graduateyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = graduateyear_;
    graduateyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_graduateyear(::std::string* graduateyear) {
  if (graduateyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete graduateyear_;
  }
  if (graduateyear) {
    set_has_graduateyear();
    graduateyear_ = graduateyear;
  } else {
    clear_has_graduateyear();
    graduateyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.graduateYear)
}

// optional bytes enrollmentYear = 16;
inline bool user_basic_info::has_enrollmentyear() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void user_basic_info::set_has_enrollmentyear() {
  _has_bits_[0] |= 0x00008000u;
}
inline void user_basic_info::clear_has_enrollmentyear() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void user_basic_info::clear_enrollmentyear() {
  if (enrollmentyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_->clear();
  }
  clear_has_enrollmentyear();
}
inline const ::std::string& user_basic_info::enrollmentyear() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.enrollmentYear)
  return *enrollmentyear_;
}
inline void user_basic_info::set_enrollmentyear(const ::std::string& value) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.enrollmentYear)
}
inline void user_basic_info::set_enrollmentyear(const char* value) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.enrollmentYear)
}
inline void user_basic_info::set_enrollmentyear(const void* value, size_t size) {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  enrollmentyear_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.enrollmentYear)
}
inline ::std::string* user_basic_info::mutable_enrollmentyear() {
  set_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enrollmentyear_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.enrollmentYear)
  return enrollmentyear_;
}
inline ::std::string* user_basic_info::release_enrollmentyear() {
  clear_has_enrollmentyear();
  if (enrollmentyear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enrollmentyear_;
    enrollmentyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_enrollmentyear(::std::string* enrollmentyear) {
  if (enrollmentyear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enrollmentyear_;
  }
  if (enrollmentyear) {
    set_has_enrollmentyear();
    enrollmentyear_ = enrollmentyear;
  } else {
    clear_has_enrollmentyear();
    enrollmentyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.enrollmentYear)
}

// optional bytes blackBox = 17;
inline bool user_basic_info::has_blackbox() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void user_basic_info::set_has_blackbox() {
  _has_bits_[0] |= 0x00010000u;
}
inline void user_basic_info::clear_has_blackbox() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void user_basic_info::clear_blackbox() {
  if (blackbox_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_->clear();
  }
  clear_has_blackbox();
}
inline const ::std::string& user_basic_info::blackbox() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.blackBox)
  return *blackbox_;
}
inline void user_basic_info::set_blackbox(const ::std::string& value) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.blackBox)
}
inline void user_basic_info::set_blackbox(const char* value) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.blackBox)
}
inline void user_basic_info::set_blackbox(const void* value, size_t size) {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  blackbox_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.blackBox)
}
inline ::std::string* user_basic_info::mutable_blackbox() {
  set_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blackbox_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.blackBox)
  return blackbox_;
}
inline ::std::string* user_basic_info::release_blackbox() {
  clear_has_blackbox();
  if (blackbox_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blackbox_;
    blackbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_blackbox(::std::string* blackbox) {
  if (blackbox_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blackbox_;
  }
  if (blackbox) {
    set_has_blackbox();
    blackbox_ = blackbox;
  } else {
    clear_has_blackbox();
    blackbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.blackBox)
}

// optional bytes password = 18;
inline bool user_basic_info::has_password() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void user_basic_info::set_has_password() {
  _has_bits_[0] |= 0x00020000u;
}
inline void user_basic_info::clear_has_password() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void user_basic_info::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& user_basic_info::password() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.password)
  return *password_;
}
inline void user_basic_info::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.password)
}
inline void user_basic_info::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.password)
}
inline void user_basic_info::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.password)
}
inline ::std::string* user_basic_info::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.password)
  return password_;
}
inline ::std::string* user_basic_info::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.password)
}

// optional bool is_prove = 19;
inline bool user_basic_info::has_is_prove() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void user_basic_info::set_has_is_prove() {
  _has_bits_[0] |= 0x00040000u;
}
inline void user_basic_info::clear_has_is_prove() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void user_basic_info::clear_is_prove() {
  is_prove_ = false;
  clear_has_is_prove();
}
inline bool user_basic_info::is_prove() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.is_prove)
  return is_prove_;
}
inline void user_basic_info::set_is_prove(bool value) {
  set_has_is_prove();
  is_prove_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.is_prove)
}

// optional bytes transDate = 20;
inline bool user_basic_info::has_transdate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void user_basic_info::set_has_transdate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void user_basic_info::clear_has_transdate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void user_basic_info::clear_transdate() {
  if (transdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transdate_->clear();
  }
  clear_has_transdate();
}
inline const ::std::string& user_basic_info::transdate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.transDate)
  return *transdate_;
}
inline void user_basic_info::set_transdate(const ::std::string& value) {
  set_has_transdate();
  if (transdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transdate_ = new ::std::string;
  }
  transdate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.transDate)
}
inline void user_basic_info::set_transdate(const char* value) {
  set_has_transdate();
  if (transdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transdate_ = new ::std::string;
  }
  transdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.transDate)
}
inline void user_basic_info::set_transdate(const void* value, size_t size) {
  set_has_transdate();
  if (transdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transdate_ = new ::std::string;
  }
  transdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.transDate)
}
inline ::std::string* user_basic_info::mutable_transdate() {
  set_has_transdate();
  if (transdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.transDate)
  return transdate_;
}
inline ::std::string* user_basic_info::release_transdate() {
  clear_has_transdate();
  if (transdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transdate_;
    transdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_transdate(::std::string* transdate) {
  if (transdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transdate_;
  }
  if (transdate) {
    set_has_transdate();
    transdate_ = transdate;
  } else {
    clear_has_transdate();
    transdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.transDate)
}

// optional bytes currency = 21;
inline bool user_basic_info::has_currency() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void user_basic_info::set_has_currency() {
  _has_bits_[0] |= 0x00100000u;
}
inline void user_basic_info::clear_has_currency() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void user_basic_info::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& user_basic_info::currency() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.currency)
  return *currency_;
}
inline void user_basic_info::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.currency)
}
inline void user_basic_info::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.currency)
}
inline void user_basic_info::set_currency(const void* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.currency)
}
inline ::std::string* user_basic_info::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.currency)
  return currency_;
}
inline ::std::string* user_basic_info::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.currency)
}

// optional bytes transAmount = 22;
inline bool user_basic_info::has_transamount() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void user_basic_info::set_has_transamount() {
  _has_bits_[0] |= 0x00200000u;
}
inline void user_basic_info::clear_has_transamount() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void user_basic_info::clear_transamount() {
  if (transamount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transamount_->clear();
  }
  clear_has_transamount();
}
inline const ::std::string& user_basic_info::transamount() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.transAmount)
  return *transamount_;
}
inline void user_basic_info::set_transamount(const ::std::string& value) {
  set_has_transamount();
  if (transamount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transamount_ = new ::std::string;
  }
  transamount_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.transAmount)
}
inline void user_basic_info::set_transamount(const char* value) {
  set_has_transamount();
  if (transamount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transamount_ = new ::std::string;
  }
  transamount_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.transAmount)
}
inline void user_basic_info::set_transamount(const void* value, size_t size) {
  set_has_transamount();
  if (transamount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transamount_ = new ::std::string;
  }
  transamount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.transAmount)
}
inline ::std::string* user_basic_info::mutable_transamount() {
  set_has_transamount();
  if (transamount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transamount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.transAmount)
  return transamount_;
}
inline ::std::string* user_basic_info::release_transamount() {
  clear_has_transamount();
  if (transamount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transamount_;
    transamount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_transamount(::std::string* transamount) {
  if (transamount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transamount_;
  }
  if (transamount) {
    set_has_transamount();
    transamount_ = transamount;
  } else {
    clear_has_transamount();
    transamount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.transAmount)
}

// optional bytes idNo = 23;
inline bool user_basic_info::has_idno() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void user_basic_info::set_has_idno() {
  _has_bits_[0] |= 0x00400000u;
}
inline void user_basic_info::clear_has_idno() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void user_basic_info::clear_idno() {
  if (idno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idno_->clear();
  }
  clear_has_idno();
}
inline const ::std::string& user_basic_info::idno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.idNo)
  return *idno_;
}
inline void user_basic_info::set_idno(const ::std::string& value) {
  set_has_idno();
  if (idno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idno_ = new ::std::string;
  }
  idno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.idNo)
}
inline void user_basic_info::set_idno(const char* value) {
  set_has_idno();
  if (idno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idno_ = new ::std::string;
  }
  idno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.idNo)
}
inline void user_basic_info::set_idno(const void* value, size_t size) {
  set_has_idno();
  if (idno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idno_ = new ::std::string;
  }
  idno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.idNo)
}
inline ::std::string* user_basic_info::mutable_idno() {
  set_has_idno();
  if (idno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.idNo)
  return idno_;
}
inline ::std::string* user_basic_info::release_idno() {
  clear_has_idno();
  if (idno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = idno_;
    idno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_idno(::std::string* idno) {
  if (idno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete idno_;
  }
  if (idno) {
    set_has_idno();
    idno_ = idno;
  } else {
    clear_has_idno();
    idno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.idNo)
}

// optional bytes idType = 24;
inline bool user_basic_info::has_idtype() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void user_basic_info::set_has_idtype() {
  _has_bits_[0] |= 0x00800000u;
}
inline void user_basic_info::clear_has_idtype() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void user_basic_info::clear_idtype() {
  if (idtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idtype_->clear();
  }
  clear_has_idtype();
}
inline const ::std::string& user_basic_info::idtype() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.idType)
  return *idtype_;
}
inline void user_basic_info::set_idtype(const ::std::string& value) {
  set_has_idtype();
  if (idtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idtype_ = new ::std::string;
  }
  idtype_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.idType)
}
inline void user_basic_info::set_idtype(const char* value) {
  set_has_idtype();
  if (idtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idtype_ = new ::std::string;
  }
  idtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.idType)
}
inline void user_basic_info::set_idtype(const void* value, size_t size) {
  set_has_idtype();
  if (idtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idtype_ = new ::std::string;
  }
  idtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.idType)
}
inline ::std::string* user_basic_info::mutable_idtype() {
  set_has_idtype();
  if (idtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.idType)
  return idtype_;
}
inline ::std::string* user_basic_info::release_idtype() {
  clear_has_idtype();
  if (idtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = idtype_;
    idtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_idtype(::std::string* idtype) {
  if (idtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete idtype_;
  }
  if (idtype) {
    set_has_idtype();
    idtype_ = idtype;
  } else {
    clear_has_idtype();
    idtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.idType)
}

// optional bytes name = 25;
inline bool user_basic_info::has_name() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void user_basic_info::set_has_name() {
  _has_bits_[0] |= 0x01000000u;
}
inline void user_basic_info::clear_has_name() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void user_basic_info::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& user_basic_info::name() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.name)
  return *name_;
}
inline void user_basic_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.name)
}
inline void user_basic_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.name)
}
inline void user_basic_info::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.name)
}
inline ::std::string* user_basic_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.name)
  return name_;
}
inline ::std::string* user_basic_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.name)
}

// optional bytes reasonNo = 26;
inline bool user_basic_info::has_reasonno() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void user_basic_info::set_has_reasonno() {
  _has_bits_[0] |= 0x02000000u;
}
inline void user_basic_info::clear_has_reasonno() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void user_basic_info::clear_reasonno() {
  if (reasonno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reasonno_->clear();
  }
  clear_has_reasonno();
}
inline const ::std::string& user_basic_info::reasonno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.reasonNo)
  return *reasonno_;
}
inline void user_basic_info::set_reasonno(const ::std::string& value) {
  set_has_reasonno();
  if (reasonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reasonno_ = new ::std::string;
  }
  reasonno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.reasonNo)
}
inline void user_basic_info::set_reasonno(const char* value) {
  set_has_reasonno();
  if (reasonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reasonno_ = new ::std::string;
  }
  reasonno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.reasonNo)
}
inline void user_basic_info::set_reasonno(const void* value, size_t size) {
  set_has_reasonno();
  if (reasonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reasonno_ = new ::std::string;
  }
  reasonno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.reasonNo)
}
inline ::std::string* user_basic_info::mutable_reasonno() {
  set_has_reasonno();
  if (reasonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reasonno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.reasonNo)
  return reasonno_;
}
inline ::std::string* user_basic_info::release_reasonno() {
  clear_has_reasonno();
  if (reasonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reasonno_;
    reasonno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_reasonno(::std::string* reasonno) {
  if (reasonno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reasonno_;
  }
  if (reasonno) {
    set_has_reasonno();
    reasonno_ = reasonno;
  } else {
    clear_has_reasonno();
    reasonno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.reasonNo)
}

// optional bytes weiboNo = 27;
inline bool user_basic_info::has_weibono() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void user_basic_info::set_has_weibono() {
  _has_bits_[0] |= 0x04000000u;
}
inline void user_basic_info::clear_has_weibono() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void user_basic_info::clear_weibono() {
  if (weibono_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weibono_->clear();
  }
  clear_has_weibono();
}
inline const ::std::string& user_basic_info::weibono() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.weiboNo)
  return *weibono_;
}
inline void user_basic_info::set_weibono(const ::std::string& value) {
  set_has_weibono();
  if (weibono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weibono_ = new ::std::string;
  }
  weibono_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.weiboNo)
}
inline void user_basic_info::set_weibono(const char* value) {
  set_has_weibono();
  if (weibono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weibono_ = new ::std::string;
  }
  weibono_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.weiboNo)
}
inline void user_basic_info::set_weibono(const void* value, size_t size) {
  set_has_weibono();
  if (weibono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weibono_ = new ::std::string;
  }
  weibono_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.weiboNo)
}
inline ::std::string* user_basic_info::mutable_weibono() {
  set_has_weibono();
  if (weibono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weibono_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.weiboNo)
  return weibono_;
}
inline ::std::string* user_basic_info::release_weibono() {
  clear_has_weibono();
  if (weibono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = weibono_;
    weibono_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_weibono(::std::string* weibono) {
  if (weibono_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete weibono_;
  }
  if (weibono) {
    set_has_weibono();
    weibono_ = weibono;
  } else {
    clear_has_weibono();
    weibono_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.weiboNo)
}

// optional bytes weixinNo = 28;
inline bool user_basic_info::has_weixinno() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void user_basic_info::set_has_weixinno() {
  _has_bits_[0] |= 0x08000000u;
}
inline void user_basic_info::clear_has_weixinno() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void user_basic_info::clear_weixinno() {
  if (weixinno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinno_->clear();
  }
  clear_has_weixinno();
}
inline const ::std::string& user_basic_info::weixinno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.weixinNo)
  return *weixinno_;
}
inline void user_basic_info::set_weixinno(const ::std::string& value) {
  set_has_weixinno();
  if (weixinno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinno_ = new ::std::string;
  }
  weixinno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.weixinNo)
}
inline void user_basic_info::set_weixinno(const char* value) {
  set_has_weixinno();
  if (weixinno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinno_ = new ::std::string;
  }
  weixinno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.weixinNo)
}
inline void user_basic_info::set_weixinno(const void* value, size_t size) {
  set_has_weixinno();
  if (weixinno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinno_ = new ::std::string;
  }
  weixinno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.weixinNo)
}
inline ::std::string* user_basic_info::mutable_weixinno() {
  set_has_weixinno();
  if (weixinno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixinno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.weixinNo)
  return weixinno_;
}
inline ::std::string* user_basic_info::release_weixinno() {
  clear_has_weixinno();
  if (weixinno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = weixinno_;
    weixinno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_weixinno(::std::string* weixinno) {
  if (weixinno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete weixinno_;
  }
  if (weixinno) {
    set_has_weixinno();
    weixinno_ = weixinno;
  } else {
    clear_has_weixinno();
    weixinno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.weixinNo)
}

// optional bytes qqNo = 29;
inline bool user_basic_info::has_qqno() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void user_basic_info::set_has_qqno() {
  _has_bits_[0] |= 0x10000000u;
}
inline void user_basic_info::clear_has_qqno() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void user_basic_info::clear_qqno() {
  if (qqno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qqno_->clear();
  }
  clear_has_qqno();
}
inline const ::std::string& user_basic_info::qqno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.qqNo)
  return *qqno_;
}
inline void user_basic_info::set_qqno(const ::std::string& value) {
  set_has_qqno();
  if (qqno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qqno_ = new ::std::string;
  }
  qqno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.qqNo)
}
inline void user_basic_info::set_qqno(const char* value) {
  set_has_qqno();
  if (qqno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qqno_ = new ::std::string;
  }
  qqno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.qqNo)
}
inline void user_basic_info::set_qqno(const void* value, size_t size) {
  set_has_qqno();
  if (qqno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qqno_ = new ::std::string;
  }
  qqno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.qqNo)
}
inline ::std::string* user_basic_info::mutable_qqno() {
  set_has_qqno();
  if (qqno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qqno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.qqNo)
  return qqno_;
}
inline ::std::string* user_basic_info::release_qqno() {
  clear_has_qqno();
  if (qqno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = qqno_;
    qqno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_qqno(::std::string* qqno) {
  if (qqno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete qqno_;
  }
  if (qqno) {
    set_has_qqno();
    qqno_ = qqno;
  } else {
    clear_has_qqno();
    qqno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.qqNo)
}

// optional bytes taobaoNo = 30;
inline bool user_basic_info::has_taobaono() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void user_basic_info::set_has_taobaono() {
  _has_bits_[0] |= 0x20000000u;
}
inline void user_basic_info::clear_has_taobaono() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void user_basic_info::clear_taobaono() {
  if (taobaono_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taobaono_->clear();
  }
  clear_has_taobaono();
}
inline const ::std::string& user_basic_info::taobaono() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.taobaoNo)
  return *taobaono_;
}
inline void user_basic_info::set_taobaono(const ::std::string& value) {
  set_has_taobaono();
  if (taobaono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taobaono_ = new ::std::string;
  }
  taobaono_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.taobaoNo)
}
inline void user_basic_info::set_taobaono(const char* value) {
  set_has_taobaono();
  if (taobaono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taobaono_ = new ::std::string;
  }
  taobaono_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.taobaoNo)
}
inline void user_basic_info::set_taobaono(const void* value, size_t size) {
  set_has_taobaono();
  if (taobaono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taobaono_ = new ::std::string;
  }
  taobaono_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.taobaoNo)
}
inline ::std::string* user_basic_info::mutable_taobaono() {
  set_has_taobaono();
  if (taobaono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taobaono_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.taobaoNo)
  return taobaono_;
}
inline ::std::string* user_basic_info::release_taobaono() {
  clear_has_taobaono();
  if (taobaono_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = taobaono_;
    taobaono_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_taobaono(::std::string* taobaono) {
  if (taobaono_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete taobaono_;
  }
  if (taobaono) {
    set_has_taobaono();
    taobaono_ = taobaono;
  } else {
    clear_has_taobaono();
    taobaono_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.taobaoNo)
}

// optional bytes jdNo = 31;
inline bool user_basic_info::has_jdno() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void user_basic_info::set_has_jdno() {
  _has_bits_[0] |= 0x40000000u;
}
inline void user_basic_info::clear_has_jdno() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void user_basic_info::clear_jdno() {
  if (jdno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jdno_->clear();
  }
  clear_has_jdno();
}
inline const ::std::string& user_basic_info::jdno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.jdNo)
  return *jdno_;
}
inline void user_basic_info::set_jdno(const ::std::string& value) {
  set_has_jdno();
  if (jdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jdno_ = new ::std::string;
  }
  jdno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.jdNo)
}
inline void user_basic_info::set_jdno(const char* value) {
  set_has_jdno();
  if (jdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jdno_ = new ::std::string;
  }
  jdno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.jdNo)
}
inline void user_basic_info::set_jdno(const void* value, size_t size) {
  set_has_jdno();
  if (jdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jdno_ = new ::std::string;
  }
  jdno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.jdNo)
}
inline ::std::string* user_basic_info::mutable_jdno() {
  set_has_jdno();
  if (jdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jdno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.jdNo)
  return jdno_;
}
inline ::std::string* user_basic_info::release_jdno() {
  clear_has_jdno();
  if (jdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jdno_;
    jdno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_jdno(::std::string* jdno) {
  if (jdno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jdno_;
  }
  if (jdno) {
    set_has_jdno();
    jdno_ = jdno;
  } else {
    clear_has_jdno();
    jdno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.jdNo)
}

// optional bytes amazonNo = 32;
inline bool user_basic_info::has_amazonno() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void user_basic_info::set_has_amazonno() {
  _has_bits_[0] |= 0x80000000u;
}
inline void user_basic_info::clear_has_amazonno() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void user_basic_info::clear_amazonno() {
  if (amazonno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amazonno_->clear();
  }
  clear_has_amazonno();
}
inline const ::std::string& user_basic_info::amazonno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.amazonNo)
  return *amazonno_;
}
inline void user_basic_info::set_amazonno(const ::std::string& value) {
  set_has_amazonno();
  if (amazonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amazonno_ = new ::std::string;
  }
  amazonno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.amazonNo)
}
inline void user_basic_info::set_amazonno(const char* value) {
  set_has_amazonno();
  if (amazonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amazonno_ = new ::std::string;
  }
  amazonno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.amazonNo)
}
inline void user_basic_info::set_amazonno(const void* value, size_t size) {
  set_has_amazonno();
  if (amazonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amazonno_ = new ::std::string;
  }
  amazonno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.amazonNo)
}
inline ::std::string* user_basic_info::mutable_amazonno() {
  set_has_amazonno();
  if (amazonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amazonno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.amazonNo)
  return amazonno_;
}
inline ::std::string* user_basic_info::release_amazonno() {
  clear_has_amazonno();
  if (amazonno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = amazonno_;
    amazonno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_amazonno(::std::string* amazonno) {
  if (amazonno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete amazonno_;
  }
  if (amazonno) {
    set_has_amazonno();
    amazonno_ = amazonno;
  } else {
    clear_has_amazonno();
    amazonno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.amazonNo)
}

// optional bytes yhdNo = 33;
inline bool user_basic_info::has_yhdno() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void user_basic_info::set_has_yhdno() {
  _has_bits_[1] |= 0x00000001u;
}
inline void user_basic_info::clear_has_yhdno() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void user_basic_info::clear_yhdno() {
  if (yhdno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yhdno_->clear();
  }
  clear_has_yhdno();
}
inline const ::std::string& user_basic_info::yhdno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.yhdNo)
  return *yhdno_;
}
inline void user_basic_info::set_yhdno(const ::std::string& value) {
  set_has_yhdno();
  if (yhdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yhdno_ = new ::std::string;
  }
  yhdno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.yhdNo)
}
inline void user_basic_info::set_yhdno(const char* value) {
  set_has_yhdno();
  if (yhdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yhdno_ = new ::std::string;
  }
  yhdno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.yhdNo)
}
inline void user_basic_info::set_yhdno(const void* value, size_t size) {
  set_has_yhdno();
  if (yhdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yhdno_ = new ::std::string;
  }
  yhdno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.yhdNo)
}
inline ::std::string* user_basic_info::mutable_yhdno() {
  set_has_yhdno();
  if (yhdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    yhdno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.yhdNo)
  return yhdno_;
}
inline ::std::string* user_basic_info::release_yhdno() {
  clear_has_yhdno();
  if (yhdno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = yhdno_;
    yhdno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_yhdno(::std::string* yhdno) {
  if (yhdno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete yhdno_;
  }
  if (yhdno) {
    set_has_yhdno();
    yhdno_ = yhdno;
  } else {
    clear_has_yhdno();
    yhdno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.yhdNo)
}

// optional bytes home_addr = 34;
inline bool user_basic_info::has_home_addr() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void user_basic_info::set_has_home_addr() {
  _has_bits_[1] |= 0x00000002u;
}
inline void user_basic_info::clear_has_home_addr() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void user_basic_info::clear_home_addr() {
  if (home_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_addr_->clear();
  }
  clear_has_home_addr();
}
inline const ::std::string& user_basic_info::home_addr() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.home_addr)
  return *home_addr_;
}
inline void user_basic_info::set_home_addr(const ::std::string& value) {
  set_has_home_addr();
  if (home_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_addr_ = new ::std::string;
  }
  home_addr_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.home_addr)
}
inline void user_basic_info::set_home_addr(const char* value) {
  set_has_home_addr();
  if (home_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_addr_ = new ::std::string;
  }
  home_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.home_addr)
}
inline void user_basic_info::set_home_addr(const void* value, size_t size) {
  set_has_home_addr();
  if (home_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_addr_ = new ::std::string;
  }
  home_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.home_addr)
}
inline ::std::string* user_basic_info::mutable_home_addr() {
  set_has_home_addr();
  if (home_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    home_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.home_addr)
  return home_addr_;
}
inline ::std::string* user_basic_info::release_home_addr() {
  clear_has_home_addr();
  if (home_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = home_addr_;
    home_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_home_addr(::std::string* home_addr) {
  if (home_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete home_addr_;
  }
  if (home_addr) {
    set_has_home_addr();
    home_addr_ = home_addr;
  } else {
    clear_has_home_addr();
    home_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.home_addr)
}

// optional bytes biz_addr = 35;
inline bool user_basic_info::has_biz_addr() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void user_basic_info::set_has_biz_addr() {
  _has_bits_[1] |= 0x00000004u;
}
inline void user_basic_info::clear_has_biz_addr() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void user_basic_info::clear_biz_addr() {
  if (biz_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_addr_->clear();
  }
  clear_has_biz_addr();
}
inline const ::std::string& user_basic_info::biz_addr() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.biz_addr)
  return *biz_addr_;
}
inline void user_basic_info::set_biz_addr(const ::std::string& value) {
  set_has_biz_addr();
  if (biz_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_addr_ = new ::std::string;
  }
  biz_addr_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.biz_addr)
}
inline void user_basic_info::set_biz_addr(const char* value) {
  set_has_biz_addr();
  if (biz_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_addr_ = new ::std::string;
  }
  biz_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.biz_addr)
}
inline void user_basic_info::set_biz_addr(const void* value, size_t size) {
  set_has_biz_addr();
  if (biz_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_addr_ = new ::std::string;
  }
  biz_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.biz_addr)
}
inline ::std::string* user_basic_info::mutable_biz_addr() {
  set_has_biz_addr();
  if (biz_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.biz_addr)
  return biz_addr_;
}
inline ::std::string* user_basic_info::release_biz_addr() {
  clear_has_biz_addr();
  if (biz_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = biz_addr_;
    biz_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_biz_addr(::std::string* biz_addr) {
  if (biz_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete biz_addr_;
  }
  if (biz_addr) {
    set_has_biz_addr();
    biz_addr_ = biz_addr;
  } else {
    clear_has_biz_addr();
    biz_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.biz_addr)
}

// optional bytes per_addr = 36;
inline bool user_basic_info::has_per_addr() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void user_basic_info::set_has_per_addr() {
  _has_bits_[1] |= 0x00000008u;
}
inline void user_basic_info::clear_has_per_addr() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void user_basic_info::clear_per_addr() {
  if (per_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    per_addr_->clear();
  }
  clear_has_per_addr();
}
inline const ::std::string& user_basic_info::per_addr() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.per_addr)
  return *per_addr_;
}
inline void user_basic_info::set_per_addr(const ::std::string& value) {
  set_has_per_addr();
  if (per_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    per_addr_ = new ::std::string;
  }
  per_addr_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.per_addr)
}
inline void user_basic_info::set_per_addr(const char* value) {
  set_has_per_addr();
  if (per_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    per_addr_ = new ::std::string;
  }
  per_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.per_addr)
}
inline void user_basic_info::set_per_addr(const void* value, size_t size) {
  set_has_per_addr();
  if (per_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    per_addr_ = new ::std::string;
  }
  per_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.per_addr)
}
inline ::std::string* user_basic_info::mutable_per_addr() {
  set_has_per_addr();
  if (per_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    per_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.per_addr)
  return per_addr_;
}
inline ::std::string* user_basic_info::release_per_addr() {
  clear_has_per_addr();
  if (per_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = per_addr_;
    per_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_per_addr(::std::string* per_addr) {
  if (per_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete per_addr_;
  }
  if (per_addr) {
    set_has_per_addr();
    per_addr_ = per_addr;
  } else {
    clear_has_per_addr();
    per_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.per_addr)
}

// optional bytes apply_addr = 37;
inline bool user_basic_info::has_apply_addr() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void user_basic_info::set_has_apply_addr() {
  _has_bits_[1] |= 0x00000010u;
}
inline void user_basic_info::clear_has_apply_addr() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void user_basic_info::clear_apply_addr() {
  if (apply_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_addr_->clear();
  }
  clear_has_apply_addr();
}
inline const ::std::string& user_basic_info::apply_addr() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.apply_addr)
  return *apply_addr_;
}
inline void user_basic_info::set_apply_addr(const ::std::string& value) {
  set_has_apply_addr();
  if (apply_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_addr_ = new ::std::string;
  }
  apply_addr_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.apply_addr)
}
inline void user_basic_info::set_apply_addr(const char* value) {
  set_has_apply_addr();
  if (apply_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_addr_ = new ::std::string;
  }
  apply_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.apply_addr)
}
inline void user_basic_info::set_apply_addr(const void* value, size_t size) {
  set_has_apply_addr();
  if (apply_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_addr_ = new ::std::string;
  }
  apply_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.apply_addr)
}
inline ::std::string* user_basic_info::mutable_apply_addr() {
  set_has_apply_addr();
  if (apply_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.apply_addr)
  return apply_addr_;
}
inline ::std::string* user_basic_info::release_apply_addr() {
  clear_has_apply_addr();
  if (apply_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = apply_addr_;
    apply_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_apply_addr(::std::string* apply_addr) {
  if (apply_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete apply_addr_;
  }
  if (apply_addr) {
    set_has_apply_addr();
    apply_addr_ = apply_addr;
  } else {
    clear_has_apply_addr();
    apply_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.apply_addr)
}

// optional bytes tel_biz = 38;
inline bool user_basic_info::has_tel_biz() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void user_basic_info::set_has_tel_biz() {
  _has_bits_[1] |= 0x00000020u;
}
inline void user_basic_info::clear_has_tel_biz() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void user_basic_info::clear_tel_biz() {
  if (tel_biz_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_biz_->clear();
  }
  clear_has_tel_biz();
}
inline const ::std::string& user_basic_info::tel_biz() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.tel_biz)
  return *tel_biz_;
}
inline void user_basic_info::set_tel_biz(const ::std::string& value) {
  set_has_tel_biz();
  if (tel_biz_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_biz_ = new ::std::string;
  }
  tel_biz_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.tel_biz)
}
inline void user_basic_info::set_tel_biz(const char* value) {
  set_has_tel_biz();
  if (tel_biz_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_biz_ = new ::std::string;
  }
  tel_biz_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.tel_biz)
}
inline void user_basic_info::set_tel_biz(const void* value, size_t size) {
  set_has_tel_biz();
  if (tel_biz_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_biz_ = new ::std::string;
  }
  tel_biz_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.tel_biz)
}
inline ::std::string* user_basic_info::mutable_tel_biz() {
  set_has_tel_biz();
  if (tel_biz_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_biz_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.tel_biz)
  return tel_biz_;
}
inline ::std::string* user_basic_info::release_tel_biz() {
  clear_has_tel_biz();
  if (tel_biz_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tel_biz_;
    tel_biz_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_tel_biz(::std::string* tel_biz) {
  if (tel_biz_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tel_biz_;
  }
  if (tel_biz) {
    set_has_tel_biz();
    tel_biz_ = tel_biz;
  } else {
    clear_has_tel_biz();
    tel_biz_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.tel_biz)
}

// optional bytes tel_home = 39;
inline bool user_basic_info::has_tel_home() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void user_basic_info::set_has_tel_home() {
  _has_bits_[1] |= 0x00000040u;
}
inline void user_basic_info::clear_has_tel_home() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void user_basic_info::clear_tel_home() {
  if (tel_home_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_home_->clear();
  }
  clear_has_tel_home();
}
inline const ::std::string& user_basic_info::tel_home() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.tel_home)
  return *tel_home_;
}
inline void user_basic_info::set_tel_home(const ::std::string& value) {
  set_has_tel_home();
  if (tel_home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_home_ = new ::std::string;
  }
  tel_home_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.tel_home)
}
inline void user_basic_info::set_tel_home(const char* value) {
  set_has_tel_home();
  if (tel_home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_home_ = new ::std::string;
  }
  tel_home_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.tel_home)
}
inline void user_basic_info::set_tel_home(const void* value, size_t size) {
  set_has_tel_home();
  if (tel_home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_home_ = new ::std::string;
  }
  tel_home_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.tel_home)
}
inline ::std::string* user_basic_info::mutable_tel_home() {
  set_has_tel_home();
  if (tel_home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tel_home_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.tel_home)
  return tel_home_;
}
inline ::std::string* user_basic_info::release_tel_home() {
  clear_has_tel_home();
  if (tel_home_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tel_home_;
    tel_home_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_tel_home(::std::string* tel_home) {
  if (tel_home_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tel_home_;
  }
  if (tel_home) {
    set_has_tel_home();
    tel_home_ = tel_home;
  } else {
    clear_has_tel_home();
    tel_home_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.tel_home)
}

// optional bytes educationallevel = 40;
inline bool user_basic_info::has_educationallevel() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void user_basic_info::set_has_educationallevel() {
  _has_bits_[1] |= 0x00000080u;
}
inline void user_basic_info::clear_has_educationallevel() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void user_basic_info::clear_educationallevel() {
  if (educationallevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationallevel_->clear();
  }
  clear_has_educationallevel();
}
inline const ::std::string& user_basic_info::educationallevel() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.educationallevel)
  return *educationallevel_;
}
inline void user_basic_info::set_educationallevel(const ::std::string& value) {
  set_has_educationallevel();
  if (educationallevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationallevel_ = new ::std::string;
  }
  educationallevel_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.educationallevel)
}
inline void user_basic_info::set_educationallevel(const char* value) {
  set_has_educationallevel();
  if (educationallevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationallevel_ = new ::std::string;
  }
  educationallevel_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.educationallevel)
}
inline void user_basic_info::set_educationallevel(const void* value, size_t size) {
  set_has_educationallevel();
  if (educationallevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationallevel_ = new ::std::string;
  }
  educationallevel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.educationallevel)
}
inline ::std::string* user_basic_info::mutable_educationallevel() {
  set_has_educationallevel();
  if (educationallevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    educationallevel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.educationallevel)
  return educationallevel_;
}
inline ::std::string* user_basic_info::release_educationallevel() {
  clear_has_educationallevel();
  if (educationallevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = educationallevel_;
    educationallevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_educationallevel(::std::string* educationallevel) {
  if (educationallevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete educationallevel_;
  }
  if (educationallevel) {
    set_has_educationallevel();
    educationallevel_ = educationallevel;
  } else {
    clear_has_educationallevel();
    educationallevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.educationallevel)
}

// optional bytes marriage = 41;
inline bool user_basic_info::has_marriage() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void user_basic_info::set_has_marriage() {
  _has_bits_[1] |= 0x00000100u;
}
inline void user_basic_info::clear_has_marriage() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void user_basic_info::clear_marriage() {
  if (marriage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marriage_->clear();
  }
  clear_has_marriage();
}
inline const ::std::string& user_basic_info::marriage() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.marriage)
  return *marriage_;
}
inline void user_basic_info::set_marriage(const ::std::string& value) {
  set_has_marriage();
  if (marriage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marriage_ = new ::std::string;
  }
  marriage_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.marriage)
}
inline void user_basic_info::set_marriage(const char* value) {
  set_has_marriage();
  if (marriage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marriage_ = new ::std::string;
  }
  marriage_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.marriage)
}
inline void user_basic_info::set_marriage(const void* value, size_t size) {
  set_has_marriage();
  if (marriage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marriage_ = new ::std::string;
  }
  marriage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.marriage)
}
inline ::std::string* user_basic_info::mutable_marriage() {
  set_has_marriage();
  if (marriage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marriage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.marriage)
  return marriage_;
}
inline ::std::string* user_basic_info::release_marriage() {
  clear_has_marriage();
  if (marriage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = marriage_;
    marriage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_marriage(::std::string* marriage) {
  if (marriage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete marriage_;
  }
  if (marriage) {
    set_has_marriage();
    marriage_ = marriage;
  } else {
    clear_has_marriage();
    marriage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.marriage)
}

// optional bytes income = 42;
inline bool user_basic_info::has_income() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void user_basic_info::set_has_income() {
  _has_bits_[1] |= 0x00000200u;
}
inline void user_basic_info::clear_has_income() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void user_basic_info::clear_income() {
  if (income_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_->clear();
  }
  clear_has_income();
}
inline const ::std::string& user_basic_info::income() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.income)
  return *income_;
}
inline void user_basic_info::set_income(const ::std::string& value) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.income)
}
inline void user_basic_info::set_income(const char* value) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.income)
}
inline void user_basic_info::set_income(const void* value, size_t size) {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  income_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.income)
}
inline ::std::string* user_basic_info::mutable_income() {
  set_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    income_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.income)
  return income_;
}
inline ::std::string* user_basic_info::release_income() {
  clear_has_income();
  if (income_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = income_;
    income_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_income(::std::string* income) {
  if (income_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete income_;
  }
  if (income) {
    set_has_income();
    income_ = income;
  } else {
    clear_has_income();
    income_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.income)
}

// optional bytes biz_workfor = 43;
inline bool user_basic_info::has_biz_workfor() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void user_basic_info::set_has_biz_workfor() {
  _has_bits_[1] |= 0x00000400u;
}
inline void user_basic_info::clear_has_biz_workfor() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void user_basic_info::clear_biz_workfor() {
  if (biz_workfor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_workfor_->clear();
  }
  clear_has_biz_workfor();
}
inline const ::std::string& user_basic_info::biz_workfor() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.biz_workfor)
  return *biz_workfor_;
}
inline void user_basic_info::set_biz_workfor(const ::std::string& value) {
  set_has_biz_workfor();
  if (biz_workfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_workfor_ = new ::std::string;
  }
  biz_workfor_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.biz_workfor)
}
inline void user_basic_info::set_biz_workfor(const char* value) {
  set_has_biz_workfor();
  if (biz_workfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_workfor_ = new ::std::string;
  }
  biz_workfor_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.biz_workfor)
}
inline void user_basic_info::set_biz_workfor(const void* value, size_t size) {
  set_has_biz_workfor();
  if (biz_workfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_workfor_ = new ::std::string;
  }
  biz_workfor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.biz_workfor)
}
inline ::std::string* user_basic_info::mutable_biz_workfor() {
  set_has_biz_workfor();
  if (biz_workfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    biz_workfor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.biz_workfor)
  return biz_workfor_;
}
inline ::std::string* user_basic_info::release_biz_workfor() {
  clear_has_biz_workfor();
  if (biz_workfor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = biz_workfor_;
    biz_workfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_biz_workfor(::std::string* biz_workfor) {
  if (biz_workfor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete biz_workfor_;
  }
  if (biz_workfor) {
    set_has_biz_workfor();
    biz_workfor_ = biz_workfor;
  } else {
    clear_has_biz_workfor();
    biz_workfor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.biz_workfor)
}

// optional bytes apply_source = 44;
inline bool user_basic_info::has_apply_source() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void user_basic_info::set_has_apply_source() {
  _has_bits_[1] |= 0x00000800u;
}
inline void user_basic_info::clear_has_apply_source() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void user_basic_info::clear_apply_source() {
  if (apply_source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_source_->clear();
  }
  clear_has_apply_source();
}
inline const ::std::string& user_basic_info::apply_source() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.apply_source)
  return *apply_source_;
}
inline void user_basic_info::set_apply_source(const ::std::string& value) {
  set_has_apply_source();
  if (apply_source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_source_ = new ::std::string;
  }
  apply_source_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.apply_source)
}
inline void user_basic_info::set_apply_source(const char* value) {
  set_has_apply_source();
  if (apply_source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_source_ = new ::std::string;
  }
  apply_source_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.apply_source)
}
inline void user_basic_info::set_apply_source(const void* value, size_t size) {
  set_has_apply_source();
  if (apply_source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_source_ = new ::std::string;
  }
  apply_source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.apply_source)
}
inline ::std::string* user_basic_info::mutable_apply_source() {
  set_has_apply_source();
  if (apply_source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.apply_source)
  return apply_source_;
}
inline ::std::string* user_basic_info::release_apply_source() {
  clear_has_apply_source();
  if (apply_source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = apply_source_;
    apply_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_apply_source(::std::string* apply_source) {
  if (apply_source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete apply_source_;
  }
  if (apply_source) {
    set_has_apply_source();
    apply_source_ = apply_source;
  } else {
    clear_has_apply_source();
    apply_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.apply_source)
}

// optional bytes apply_product = 45;
inline bool user_basic_info::has_apply_product() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void user_basic_info::set_has_apply_product() {
  _has_bits_[1] |= 0x00001000u;
}
inline void user_basic_info::clear_has_apply_product() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void user_basic_info::clear_apply_product() {
  if (apply_product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_product_->clear();
  }
  clear_has_apply_product();
}
inline const ::std::string& user_basic_info::apply_product() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.apply_product)
  return *apply_product_;
}
inline void user_basic_info::set_apply_product(const ::std::string& value) {
  set_has_apply_product();
  if (apply_product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_product_ = new ::std::string;
  }
  apply_product_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.apply_product)
}
inline void user_basic_info::set_apply_product(const char* value) {
  set_has_apply_product();
  if (apply_product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_product_ = new ::std::string;
  }
  apply_product_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.apply_product)
}
inline void user_basic_info::set_apply_product(const void* value, size_t size) {
  set_has_apply_product();
  if (apply_product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_product_ = new ::std::string;
  }
  apply_product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.apply_product)
}
inline ::std::string* user_basic_info::mutable_apply_product() {
  set_has_apply_product();
  if (apply_product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.apply_product)
  return apply_product_;
}
inline ::std::string* user_basic_info::release_apply_product() {
  clear_has_apply_product();
  if (apply_product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = apply_product_;
    apply_product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_apply_product(::std::string* apply_product) {
  if (apply_product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete apply_product_;
  }
  if (apply_product) {
    set_has_apply_product();
    apply_product_ = apply_product;
  } else {
    clear_has_apply_product();
    apply_product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.apply_product)
}

// optional bytes refund_type = 46;
inline bool user_basic_info::has_refund_type() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void user_basic_info::set_has_refund_type() {
  _has_bits_[1] |= 0x00002000u;
}
inline void user_basic_info::clear_has_refund_type() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void user_basic_info::clear_refund_type() {
  if (refund_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refund_type_->clear();
  }
  clear_has_refund_type();
}
inline const ::std::string& user_basic_info::refund_type() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.refund_type)
  return *refund_type_;
}
inline void user_basic_info::set_refund_type(const ::std::string& value) {
  set_has_refund_type();
  if (refund_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refund_type_ = new ::std::string;
  }
  refund_type_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.refund_type)
}
inline void user_basic_info::set_refund_type(const char* value) {
  set_has_refund_type();
  if (refund_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refund_type_ = new ::std::string;
  }
  refund_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.refund_type)
}
inline void user_basic_info::set_refund_type(const void* value, size_t size) {
  set_has_refund_type();
  if (refund_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refund_type_ = new ::std::string;
  }
  refund_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.refund_type)
}
inline ::std::string* user_basic_info::mutable_refund_type() {
  set_has_refund_type();
  if (refund_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refund_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.refund_type)
  return refund_type_;
}
inline ::std::string* user_basic_info::release_refund_type() {
  clear_has_refund_type();
  if (refund_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = refund_type_;
    refund_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_refund_type(::std::string* refund_type) {
  if (refund_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete refund_type_;
  }
  if (refund_type) {
    set_has_refund_type();
    refund_type_ = refund_type;
  } else {
    clear_has_refund_type();
    refund_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.refund_type)
}

// optional bytes applyQuota = 47;
inline bool user_basic_info::has_applyquota() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void user_basic_info::set_has_applyquota() {
  _has_bits_[1] |= 0x00004000u;
}
inline void user_basic_info::clear_has_applyquota() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void user_basic_info::clear_applyquota() {
  if (applyquota_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyquota_->clear();
  }
  clear_has_applyquota();
}
inline const ::std::string& user_basic_info::applyquota() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.applyQuota)
  return *applyquota_;
}
inline void user_basic_info::set_applyquota(const ::std::string& value) {
  set_has_applyquota();
  if (applyquota_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyquota_ = new ::std::string;
  }
  applyquota_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.applyQuota)
}
inline void user_basic_info::set_applyquota(const char* value) {
  set_has_applyquota();
  if (applyquota_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyquota_ = new ::std::string;
  }
  applyquota_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.applyQuota)
}
inline void user_basic_info::set_applyquota(const void* value, size_t size) {
  set_has_applyquota();
  if (applyquota_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyquota_ = new ::std::string;
  }
  applyquota_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.applyQuota)
}
inline ::std::string* user_basic_info::mutable_applyquota() {
  set_has_applyquota();
  if (applyquota_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyquota_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.applyQuota)
  return applyquota_;
}
inline ::std::string* user_basic_info::release_applyquota() {
  clear_has_applyquota();
  if (applyquota_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applyquota_;
    applyquota_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_applyquota(::std::string* applyquota) {
  if (applyquota_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applyquota_;
  }
  if (applyquota) {
    set_has_applyquota();
    applyquota_ = applyquota;
  } else {
    clear_has_applyquota();
    applyquota_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.applyQuota)
}

// optional bytes apply_time = 48;
inline bool user_basic_info::has_apply_time() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void user_basic_info::set_has_apply_time() {
  _has_bits_[1] |= 0x00008000u;
}
inline void user_basic_info::clear_has_apply_time() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void user_basic_info::clear_apply_time() {
  if (apply_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_time_->clear();
  }
  clear_has_apply_time();
}
inline const ::std::string& user_basic_info::apply_time() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.apply_time)
  return *apply_time_;
}
inline void user_basic_info::set_apply_time(const ::std::string& value) {
  set_has_apply_time();
  if (apply_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_time_ = new ::std::string;
  }
  apply_time_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.apply_time)
}
inline void user_basic_info::set_apply_time(const char* value) {
  set_has_apply_time();
  if (apply_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_time_ = new ::std::string;
  }
  apply_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.apply_time)
}
inline void user_basic_info::set_apply_time(const void* value, size_t size) {
  set_has_apply_time();
  if (apply_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_time_ = new ::std::string;
  }
  apply_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.apply_time)
}
inline ::std::string* user_basic_info::mutable_apply_time() {
  set_has_apply_time();
  if (apply_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    apply_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.apply_time)
  return apply_time_;
}
inline ::std::string* user_basic_info::release_apply_time() {
  clear_has_apply_time();
  if (apply_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = apply_time_;
    apply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_apply_time(::std::string* apply_time) {
  if (apply_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete apply_time_;
  }
  if (apply_time) {
    set_has_apply_time();
    apply_time_ = apply_time;
  } else {
    clear_has_apply_time();
    apply_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.apply_time)
}

// optional bytes loanPeriod = 49;
inline bool user_basic_info::has_loanperiod() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void user_basic_info::set_has_loanperiod() {
  _has_bits_[1] |= 0x00010000u;
}
inline void user_basic_info::clear_has_loanperiod() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void user_basic_info::clear_loanperiod() {
  if (loanperiod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanperiod_->clear();
  }
  clear_has_loanperiod();
}
inline const ::std::string& user_basic_info::loanperiod() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanPeriod)
  return *loanperiod_;
}
inline void user_basic_info::set_loanperiod(const ::std::string& value) {
  set_has_loanperiod();
  if (loanperiod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanperiod_ = new ::std::string;
  }
  loanperiod_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanPeriod)
}
inline void user_basic_info::set_loanperiod(const char* value) {
  set_has_loanperiod();
  if (loanperiod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanperiod_ = new ::std::string;
  }
  loanperiod_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.loanPeriod)
}
inline void user_basic_info::set_loanperiod(const void* value, size_t size) {
  set_has_loanperiod();
  if (loanperiod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanperiod_ = new ::std::string;
  }
  loanperiod_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.loanPeriod)
}
inline ::std::string* user_basic_info::mutable_loanperiod() {
  set_has_loanperiod();
  if (loanperiod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanperiod_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.loanPeriod)
  return loanperiod_;
}
inline ::std::string* user_basic_info::release_loanperiod() {
  clear_has_loanperiod();
  if (loanperiod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loanperiod_;
    loanperiod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_loanperiod(::std::string* loanperiod) {
  if (loanperiod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loanperiod_;
  }
  if (loanperiod) {
    set_has_loanperiod();
    loanperiod_ = loanperiod;
  } else {
    clear_has_loanperiod();
    loanperiod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.loanPeriod)
}

// optional bytes bank_id = 50;
inline bool user_basic_info::has_bank_id() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void user_basic_info::set_has_bank_id() {
  _has_bits_[1] |= 0x00020000u;
}
inline void user_basic_info::clear_has_bank_id() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void user_basic_info::clear_bank_id() {
  if (bank_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_id_->clear();
  }
  clear_has_bank_id();
}
inline const ::std::string& user_basic_info::bank_id() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.bank_id)
  return *bank_id_;
}
inline void user_basic_info::set_bank_id(const ::std::string& value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.bank_id)
}
inline void user_basic_info::set_bank_id(const char* value) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.bank_id)
}
inline void user_basic_info::set_bank_id(const void* value, size_t size) {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_id_ = new ::std::string;
  }
  bank_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.bank_id)
}
inline ::std::string* user_basic_info::mutable_bank_id() {
  set_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bank_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.bank_id)
  return bank_id_;
}
inline ::std::string* user_basic_info::release_bank_id() {
  clear_has_bank_id();
  if (bank_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bank_id_;
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_bank_id(::std::string* bank_id) {
  if (bank_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bank_id_;
  }
  if (bank_id) {
    set_has_bank_id();
    bank_id_ = bank_id;
  } else {
    clear_has_bank_id();
    bank_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.bank_id)
}

// optional bytes linkman_name = 51;
inline bool user_basic_info::has_linkman_name() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void user_basic_info::set_has_linkman_name() {
  _has_bits_[1] |= 0x00040000u;
}
inline void user_basic_info::clear_has_linkman_name() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void user_basic_info::clear_linkman_name() {
  if (linkman_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_name_->clear();
  }
  clear_has_linkman_name();
}
inline const ::std::string& user_basic_info::linkman_name() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.linkman_name)
  return *linkman_name_;
}
inline void user_basic_info::set_linkman_name(const ::std::string& value) {
  set_has_linkman_name();
  if (linkman_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_name_ = new ::std::string;
  }
  linkman_name_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.linkman_name)
}
inline void user_basic_info::set_linkman_name(const char* value) {
  set_has_linkman_name();
  if (linkman_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_name_ = new ::std::string;
  }
  linkman_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.linkman_name)
}
inline void user_basic_info::set_linkman_name(const void* value, size_t size) {
  set_has_linkman_name();
  if (linkman_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_name_ = new ::std::string;
  }
  linkman_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.linkman_name)
}
inline ::std::string* user_basic_info::mutable_linkman_name() {
  set_has_linkman_name();
  if (linkman_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.linkman_name)
  return linkman_name_;
}
inline ::std::string* user_basic_info::release_linkman_name() {
  clear_has_linkman_name();
  if (linkman_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = linkman_name_;
    linkman_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_linkman_name(::std::string* linkman_name) {
  if (linkman_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete linkman_name_;
  }
  if (linkman_name) {
    set_has_linkman_name();
    linkman_name_ = linkman_name;
  } else {
    clear_has_linkman_name();
    linkman_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.linkman_name)
}

// optional bytes linkman_cell = 52;
inline bool user_basic_info::has_linkman_cell() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void user_basic_info::set_has_linkman_cell() {
  _has_bits_[1] |= 0x00080000u;
}
inline void user_basic_info::clear_has_linkman_cell() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void user_basic_info::clear_linkman_cell() {
  if (linkman_cell_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_cell_->clear();
  }
  clear_has_linkman_cell();
}
inline const ::std::string& user_basic_info::linkman_cell() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.linkman_cell)
  return *linkman_cell_;
}
inline void user_basic_info::set_linkman_cell(const ::std::string& value) {
  set_has_linkman_cell();
  if (linkman_cell_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_cell_ = new ::std::string;
  }
  linkman_cell_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.linkman_cell)
}
inline void user_basic_info::set_linkman_cell(const char* value) {
  set_has_linkman_cell();
  if (linkman_cell_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_cell_ = new ::std::string;
  }
  linkman_cell_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.linkman_cell)
}
inline void user_basic_info::set_linkman_cell(const void* value, size_t size) {
  set_has_linkman_cell();
  if (linkman_cell_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_cell_ = new ::std::string;
  }
  linkman_cell_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.linkman_cell)
}
inline ::std::string* user_basic_info::mutable_linkman_cell() {
  set_has_linkman_cell();
  if (linkman_cell_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_cell_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.linkman_cell)
  return linkman_cell_;
}
inline ::std::string* user_basic_info::release_linkman_cell() {
  clear_has_linkman_cell();
  if (linkman_cell_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = linkman_cell_;
    linkman_cell_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_linkman_cell(::std::string* linkman_cell) {
  if (linkman_cell_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete linkman_cell_;
  }
  if (linkman_cell) {
    set_has_linkman_cell();
    linkman_cell_ = linkman_cell;
  } else {
    clear_has_linkman_cell();
    linkman_cell_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.linkman_cell)
}

// optional bytes linkman_rela = 53;
inline bool user_basic_info::has_linkman_rela() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void user_basic_info::set_has_linkman_rela() {
  _has_bits_[1] |= 0x00100000u;
}
inline void user_basic_info::clear_has_linkman_rela() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void user_basic_info::clear_linkman_rela() {
  if (linkman_rela_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_rela_->clear();
  }
  clear_has_linkman_rela();
}
inline const ::std::string& user_basic_info::linkman_rela() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.linkman_rela)
  return *linkman_rela_;
}
inline void user_basic_info::set_linkman_rela(const ::std::string& value) {
  set_has_linkman_rela();
  if (linkman_rela_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_rela_ = new ::std::string;
  }
  linkman_rela_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.linkman_rela)
}
inline void user_basic_info::set_linkman_rela(const char* value) {
  set_has_linkman_rela();
  if (linkman_rela_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_rela_ = new ::std::string;
  }
  linkman_rela_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.linkman_rela)
}
inline void user_basic_info::set_linkman_rela(const void* value, size_t size) {
  set_has_linkman_rela();
  if (linkman_rela_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_rela_ = new ::std::string;
  }
  linkman_rela_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.linkman_rela)
}
inline ::std::string* user_basic_info::mutable_linkman_rela() {
  set_has_linkman_rela();
  if (linkman_rela_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    linkman_rela_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.linkman_rela)
  return linkman_rela_;
}
inline ::std::string* user_basic_info::release_linkman_rela() {
  clear_has_linkman_rela();
  if (linkman_rela_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = linkman_rela_;
    linkman_rela_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_linkman_rela(::std::string* linkman_rela) {
  if (linkman_rela_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete linkman_rela_;
  }
  if (linkman_rela) {
    set_has_linkman_rela();
    linkman_rela_ = linkman_rela;
  } else {
    clear_has_linkman_rela();
    linkman_rela_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.linkman_rela)
}

// optional bytes token_id = 54;
inline bool user_basic_info::has_token_id() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void user_basic_info::set_has_token_id() {
  _has_bits_[1] |= 0x00200000u;
}
inline void user_basic_info::clear_has_token_id() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void user_basic_info::clear_token_id() {
  if (token_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_id_->clear();
  }
  clear_has_token_id();
}
inline const ::std::string& user_basic_info::token_id() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.token_id)
  return *token_id_;
}
inline void user_basic_info::set_token_id(const ::std::string& value) {
  set_has_token_id();
  if (token_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_id_ = new ::std::string;
  }
  token_id_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.token_id)
}
inline void user_basic_info::set_token_id(const char* value) {
  set_has_token_id();
  if (token_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_id_ = new ::std::string;
  }
  token_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.token_id)
}
inline void user_basic_info::set_token_id(const void* value, size_t size) {
  set_has_token_id();
  if (token_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_id_ = new ::std::string;
  }
  token_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.token_id)
}
inline ::std::string* user_basic_info::mutable_token_id() {
  set_has_token_id();
  if (token_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.token_id)
  return token_id_;
}
inline ::std::string* user_basic_info::release_token_id() {
  clear_has_token_id();
  if (token_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_id_;
    token_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_token_id(::std::string* token_id) {
  if (token_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_id_;
  }
  if (token_id) {
    set_has_token_id();
    token_id_ = token_id;
  } else {
    clear_has_token_id();
    token_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.token_id)
}

// optional bytes user_agent_cust = 55;
inline bool user_basic_info::has_user_agent_cust() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void user_basic_info::set_has_user_agent_cust() {
  _has_bits_[1] |= 0x00400000u;
}
inline void user_basic_info::clear_has_user_agent_cust() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void user_basic_info::clear_user_agent_cust() {
  if (user_agent_cust_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_cust_->clear();
  }
  clear_has_user_agent_cust();
}
inline const ::std::string& user_basic_info::user_agent_cust() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.user_agent_cust)
  return *user_agent_cust_;
}
inline void user_basic_info::set_user_agent_cust(const ::std::string& value) {
  set_has_user_agent_cust();
  if (user_agent_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_cust_ = new ::std::string;
  }
  user_agent_cust_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.user_agent_cust)
}
inline void user_basic_info::set_user_agent_cust(const char* value) {
  set_has_user_agent_cust();
  if (user_agent_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_cust_ = new ::std::string;
  }
  user_agent_cust_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.user_agent_cust)
}
inline void user_basic_info::set_user_agent_cust(const void* value, size_t size) {
  set_has_user_agent_cust();
  if (user_agent_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_cust_ = new ::std::string;
  }
  user_agent_cust_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.user_agent_cust)
}
inline ::std::string* user_basic_info::mutable_user_agent_cust() {
  set_has_user_agent_cust();
  if (user_agent_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_cust_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.user_agent_cust)
  return user_agent_cust_;
}
inline ::std::string* user_basic_info::release_user_agent_cust() {
  clear_has_user_agent_cust();
  if (user_agent_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_agent_cust_;
    user_agent_cust_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_user_agent_cust(::std::string* user_agent_cust) {
  if (user_agent_cust_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_agent_cust_;
  }
  if (user_agent_cust) {
    set_has_user_agent_cust();
    user_agent_cust_ = user_agent_cust;
  } else {
    clear_has_user_agent_cust();
    user_agent_cust_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.user_agent_cust)
}

// optional bytes refer_cust = 56;
inline bool user_basic_info::has_refer_cust() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void user_basic_info::set_has_refer_cust() {
  _has_bits_[1] |= 0x00800000u;
}
inline void user_basic_info::clear_has_refer_cust() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void user_basic_info::clear_refer_cust() {
  if (refer_cust_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refer_cust_->clear();
  }
  clear_has_refer_cust();
}
inline const ::std::string& user_basic_info::refer_cust() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.refer_cust)
  return *refer_cust_;
}
inline void user_basic_info::set_refer_cust(const ::std::string& value) {
  set_has_refer_cust();
  if (refer_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refer_cust_ = new ::std::string;
  }
  refer_cust_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.refer_cust)
}
inline void user_basic_info::set_refer_cust(const char* value) {
  set_has_refer_cust();
  if (refer_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refer_cust_ = new ::std::string;
  }
  refer_cust_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.refer_cust)
}
inline void user_basic_info::set_refer_cust(const void* value, size_t size) {
  set_has_refer_cust();
  if (refer_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refer_cust_ = new ::std::string;
  }
  refer_cust_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.refer_cust)
}
inline ::std::string* user_basic_info::mutable_refer_cust() {
  set_has_refer_cust();
  if (refer_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    refer_cust_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.refer_cust)
  return refer_cust_;
}
inline ::std::string* user_basic_info::release_refer_cust() {
  clear_has_refer_cust();
  if (refer_cust_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = refer_cust_;
    refer_cust_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_refer_cust(::std::string* refer_cust) {
  if (refer_cust_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete refer_cust_;
  }
  if (refer_cust) {
    set_has_refer_cust();
    refer_cust_ = refer_cust;
  } else {
    clear_has_refer_cust();
    refer_cust_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.refer_cust)
}

// optional bytes state = 57;
inline bool user_basic_info::has_state() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void user_basic_info::set_has_state() {
  _has_bits_[1] |= 0x01000000u;
}
inline void user_basic_info::clear_has_state() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void user_basic_info::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& user_basic_info::state() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.state)
  return *state_;
}
inline void user_basic_info::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.state)
}
inline void user_basic_info::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.state)
}
inline void user_basic_info::set_state(const void* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.state)
}
inline ::std::string* user_basic_info::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.state)
  return state_;
}
inline ::std::string* user_basic_info::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.state)
}

// optional bytes card_number = 58;
inline bool user_basic_info::has_card_number() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void user_basic_info::set_has_card_number() {
  _has_bits_[1] |= 0x02000000u;
}
inline void user_basic_info::clear_has_card_number() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void user_basic_info::clear_card_number() {
  if (card_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_number_->clear();
  }
  clear_has_card_number();
}
inline const ::std::string& user_basic_info::card_number() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.card_number)
  return *card_number_;
}
inline void user_basic_info::set_card_number(const ::std::string& value) {
  set_has_card_number();
  if (card_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_number_ = new ::std::string;
  }
  card_number_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.card_number)
}
inline void user_basic_info::set_card_number(const char* value) {
  set_has_card_number();
  if (card_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_number_ = new ::std::string;
  }
  card_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.card_number)
}
inline void user_basic_info::set_card_number(const void* value, size_t size) {
  set_has_card_number();
  if (card_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_number_ = new ::std::string;
  }
  card_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.card_number)
}
inline ::std::string* user_basic_info::mutable_card_number() {
  set_has_card_number();
  if (card_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.card_number)
  return card_number_;
}
inline ::std::string* user_basic_info::release_card_number() {
  clear_has_card_number();
  if (card_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = card_number_;
    card_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_card_number(::std::string* card_number) {
  if (card_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete card_number_;
  }
  if (card_number) {
    set_has_card_number();
    card_number_ = card_number;
  } else {
    clear_has_card_number();
    card_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.card_number)
}

// optional bytes cc_bin = 59;
inline bool user_basic_info::has_cc_bin() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void user_basic_info::set_has_cc_bin() {
  _has_bits_[1] |= 0x04000000u;
}
inline void user_basic_info::clear_has_cc_bin() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void user_basic_info::clear_cc_bin() {
  if (cc_bin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cc_bin_->clear();
  }
  clear_has_cc_bin();
}
inline const ::std::string& user_basic_info::cc_bin() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.cc_bin)
  return *cc_bin_;
}
inline void user_basic_info::set_cc_bin(const ::std::string& value) {
  set_has_cc_bin();
  if (cc_bin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cc_bin_ = new ::std::string;
  }
  cc_bin_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.cc_bin)
}
inline void user_basic_info::set_cc_bin(const char* value) {
  set_has_cc_bin();
  if (cc_bin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cc_bin_ = new ::std::string;
  }
  cc_bin_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.cc_bin)
}
inline void user_basic_info::set_cc_bin(const void* value, size_t size) {
  set_has_cc_bin();
  if (cc_bin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cc_bin_ = new ::std::string;
  }
  cc_bin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.cc_bin)
}
inline ::std::string* user_basic_info::mutable_cc_bin() {
  set_has_cc_bin();
  if (cc_bin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cc_bin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.cc_bin)
  return cc_bin_;
}
inline ::std::string* user_basic_info::release_cc_bin() {
  clear_has_cc_bin();
  if (cc_bin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cc_bin_;
    cc_bin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_cc_bin(::std::string* cc_bin) {
  if (cc_bin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cc_bin_;
  }
  if (cc_bin) {
    set_has_cc_bin();
    cc_bin_ = cc_bin;
  } else {
    clear_has_cc_bin();
    cc_bin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.cc_bin)
}

// optional bytes pay_amount = 60;
inline bool user_basic_info::has_pay_amount() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void user_basic_info::set_has_pay_amount() {
  _has_bits_[1] |= 0x08000000u;
}
inline void user_basic_info::clear_has_pay_amount() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void user_basic_info::clear_pay_amount() {
  if (pay_amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_amount_->clear();
  }
  clear_has_pay_amount();
}
inline const ::std::string& user_basic_info::pay_amount() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.pay_amount)
  return *pay_amount_;
}
inline void user_basic_info::set_pay_amount(const ::std::string& value) {
  set_has_pay_amount();
  if (pay_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_amount_ = new ::std::string;
  }
  pay_amount_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.pay_amount)
}
inline void user_basic_info::set_pay_amount(const char* value) {
  set_has_pay_amount();
  if (pay_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_amount_ = new ::std::string;
  }
  pay_amount_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.pay_amount)
}
inline void user_basic_info::set_pay_amount(const void* value, size_t size) {
  set_has_pay_amount();
  if (pay_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_amount_ = new ::std::string;
  }
  pay_amount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.pay_amount)
}
inline ::std::string* user_basic_info::mutable_pay_amount() {
  set_has_pay_amount();
  if (pay_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_amount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.pay_amount)
  return pay_amount_;
}
inline ::std::string* user_basic_info::release_pay_amount() {
  clear_has_pay_amount();
  if (pay_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pay_amount_;
    pay_amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_pay_amount(::std::string* pay_amount) {
  if (pay_amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pay_amount_;
  }
  if (pay_amount) {
    set_has_pay_amount();
    pay_amount_ = pay_amount;
  } else {
    clear_has_pay_amount();
    pay_amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.pay_amount)
}

// optional bytes pay_method = 61;
inline bool user_basic_info::has_pay_method() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void user_basic_info::set_has_pay_method() {
  _has_bits_[1] |= 0x10000000u;
}
inline void user_basic_info::clear_has_pay_method() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void user_basic_info::clear_pay_method() {
  if (pay_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_method_->clear();
  }
  clear_has_pay_method();
}
inline const ::std::string& user_basic_info::pay_method() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.pay_method)
  return *pay_method_;
}
inline void user_basic_info::set_pay_method(const ::std::string& value) {
  set_has_pay_method();
  if (pay_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_method_ = new ::std::string;
  }
  pay_method_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.pay_method)
}
inline void user_basic_info::set_pay_method(const char* value) {
  set_has_pay_method();
  if (pay_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_method_ = new ::std::string;
  }
  pay_method_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.pay_method)
}
inline void user_basic_info::set_pay_method(const void* value, size_t size) {
  set_has_pay_method();
  if (pay_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_method_ = new ::std::string;
  }
  pay_method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.pay_method)
}
inline ::std::string* user_basic_info::mutable_pay_method() {
  set_has_pay_method();
  if (pay_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pay_method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.pay_method)
  return pay_method_;
}
inline ::std::string* user_basic_info::release_pay_method() {
  clear_has_pay_method();
  if (pay_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pay_method_;
    pay_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_pay_method(::std::string* pay_method) {
  if (pay_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pay_method_;
  }
  if (pay_method) {
    set_has_pay_method();
    pay_method_ = pay_method;
  } else {
    clear_has_pay_method();
    pay_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.pay_method)
}

// optional bytes account_login = 62;
inline bool user_basic_info::has_account_login() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void user_basic_info::set_has_account_login() {
  _has_bits_[1] |= 0x20000000u;
}
inline void user_basic_info::clear_has_account_login() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void user_basic_info::clear_account_login() {
  if (account_login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_login_->clear();
  }
  clear_has_account_login();
}
inline const ::std::string& user_basic_info::account_login() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.account_login)
  return *account_login_;
}
inline void user_basic_info::set_account_login(const ::std::string& value) {
  set_has_account_login();
  if (account_login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_login_ = new ::std::string;
  }
  account_login_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.account_login)
}
inline void user_basic_info::set_account_login(const char* value) {
  set_has_account_login();
  if (account_login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_login_ = new ::std::string;
  }
  account_login_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.account_login)
}
inline void user_basic_info::set_account_login(const void* value, size_t size) {
  set_has_account_login();
  if (account_login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_login_ = new ::std::string;
  }
  account_login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.account_login)
}
inline ::std::string* user_basic_info::mutable_account_login() {
  set_has_account_login();
  if (account_login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    account_login_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.account_login)
  return account_login_;
}
inline ::std::string* user_basic_info::release_account_login() {
  clear_has_account_login();
  if (account_login_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = account_login_;
    account_login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_account_login(::std::string* account_login) {
  if (account_login_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete account_login_;
  }
  if (account_login) {
    set_has_account_login();
    account_login_ = account_login;
  } else {
    clear_has_account_login();
    account_login_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.account_login)
}

// optional bytes customerName = 63;
inline bool user_basic_info::has_customername() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void user_basic_info::set_has_customername() {
  _has_bits_[1] |= 0x40000000u;
}
inline void user_basic_info::clear_has_customername() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void user_basic_info::clear_customername() {
  if (customername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customername_->clear();
  }
  clear_has_customername();
}
inline const ::std::string& user_basic_info::customername() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.customerName)
  return *customername_;
}
inline void user_basic_info::set_customername(const ::std::string& value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.customerName)
}
inline void user_basic_info::set_customername(const char* value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.customerName)
}
inline void user_basic_info::set_customername(const void* value, size_t size) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customername_ = new ::std::string;
  }
  customername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.customerName)
}
inline ::std::string* user_basic_info::mutable_customername() {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.customerName)
  return customername_;
}
inline ::std::string* user_basic_info::release_customername() {
  clear_has_customername();
  if (customername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = customername_;
    customername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_customername(::std::string* customername) {
  if (customername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete customername_;
  }
  if (customername) {
    set_has_customername();
    customername_ = customername;
  } else {
    clear_has_customername();
    customername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.customerName)
}

// optional bytes paperNumber = 64;
inline bool user_basic_info::has_papernumber() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void user_basic_info::set_has_papernumber() {
  _has_bits_[1] |= 0x80000000u;
}
inline void user_basic_info::clear_has_papernumber() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void user_basic_info::clear_papernumber() {
  if (papernumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    papernumber_->clear();
  }
  clear_has_papernumber();
}
inline const ::std::string& user_basic_info::papernumber() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.paperNumber)
  return *papernumber_;
}
inline void user_basic_info::set_papernumber(const ::std::string& value) {
  set_has_papernumber();
  if (papernumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    papernumber_ = new ::std::string;
  }
  papernumber_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.paperNumber)
}
inline void user_basic_info::set_papernumber(const char* value) {
  set_has_papernumber();
  if (papernumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    papernumber_ = new ::std::string;
  }
  papernumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.paperNumber)
}
inline void user_basic_info::set_papernumber(const void* value, size_t size) {
  set_has_papernumber();
  if (papernumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    papernumber_ = new ::std::string;
  }
  papernumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.paperNumber)
}
inline ::std::string* user_basic_info::mutable_papernumber() {
  set_has_papernumber();
  if (papernumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    papernumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.paperNumber)
  return papernumber_;
}
inline ::std::string* user_basic_info::release_papernumber() {
  clear_has_papernumber();
  if (papernumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = papernumber_;
    papernumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_papernumber(::std::string* papernumber) {
  if (papernumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete papernumber_;
  }
  if (papernumber) {
    set_has_papernumber();
    papernumber_ = papernumber;
  } else {
    clear_has_papernumber();
    papernumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.paperNumber)
}

// optional bytes applyId = 65;
inline bool user_basic_info::has_applyid() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void user_basic_info::set_has_applyid() {
  _has_bits_[2] |= 0x00000001u;
}
inline void user_basic_info::clear_has_applyid() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void user_basic_info::clear_applyid() {
  if (applyid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyid_->clear();
  }
  clear_has_applyid();
}
inline const ::std::string& user_basic_info::applyid() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.applyId)
  return *applyid_;
}
inline void user_basic_info::set_applyid(const ::std::string& value) {
  set_has_applyid();
  if (applyid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyid_ = new ::std::string;
  }
  applyid_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.applyId)
}
inline void user_basic_info::set_applyid(const char* value) {
  set_has_applyid();
  if (applyid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyid_ = new ::std::string;
  }
  applyid_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.applyId)
}
inline void user_basic_info::set_applyid(const void* value, size_t size) {
  set_has_applyid();
  if (applyid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyid_ = new ::std::string;
  }
  applyid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.applyId)
}
inline ::std::string* user_basic_info::mutable_applyid() {
  set_has_applyid();
  if (applyid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.applyId)
  return applyid_;
}
inline ::std::string* user_basic_info::release_applyid() {
  clear_has_applyid();
  if (applyid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applyid_;
    applyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_applyid(::std::string* applyid) {
  if (applyid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applyid_;
  }
  if (applyid) {
    set_has_applyid();
    applyid_ = applyid;
  } else {
    clear_has_applyid();
    applyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.applyId)
}

// optional bytes loanType = 66;
inline bool user_basic_info::has_loantype() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void user_basic_info::set_has_loantype() {
  _has_bits_[2] |= 0x00000002u;
}
inline void user_basic_info::clear_has_loantype() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void user_basic_info::clear_loantype() {
  if (loantype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loantype_->clear();
  }
  clear_has_loantype();
}
inline const ::std::string& user_basic_info::loantype() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanType)
  return *loantype_;
}
inline void user_basic_info::set_loantype(const ::std::string& value) {
  set_has_loantype();
  if (loantype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loantype_ = new ::std::string;
  }
  loantype_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanType)
}
inline void user_basic_info::set_loantype(const char* value) {
  set_has_loantype();
  if (loantype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loantype_ = new ::std::string;
  }
  loantype_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.loanType)
}
inline void user_basic_info::set_loantype(const void* value, size_t size) {
  set_has_loantype();
  if (loantype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loantype_ = new ::std::string;
  }
  loantype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.loanType)
}
inline ::std::string* user_basic_info::mutable_loantype() {
  set_has_loantype();
  if (loantype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loantype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.loanType)
  return loantype_;
}
inline ::std::string* user_basic_info::release_loantype() {
  clear_has_loantype();
  if (loantype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loantype_;
    loantype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_loantype(::std::string* loantype) {
  if (loantype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loantype_;
  }
  if (loantype) {
    set_has_loantype();
    loantype_ = loantype;
  } else {
    clear_has_loantype();
    loantype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.loanType)
}

// optional double loanMoney = 67;
inline bool user_basic_info::has_loanmoney() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void user_basic_info::set_has_loanmoney() {
  _has_bits_[2] |= 0x00000004u;
}
inline void user_basic_info::clear_has_loanmoney() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void user_basic_info::clear_loanmoney() {
  loanmoney_ = 0;
  clear_has_loanmoney();
}
inline double user_basic_info::loanmoney() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanMoney)
  return loanmoney_;
}
inline void user_basic_info::set_loanmoney(double value) {
  set_has_loanmoney();
  loanmoney_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanMoney)
}

// optional bytes currencyAnRong = 68;
inline bool user_basic_info::has_currencyanrong() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void user_basic_info::set_has_currencyanrong() {
  _has_bits_[2] |= 0x00000008u;
}
inline void user_basic_info::clear_has_currencyanrong() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void user_basic_info::clear_currencyanrong() {
  if (currencyanrong_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyanrong_->clear();
  }
  clear_has_currencyanrong();
}
inline const ::std::string& user_basic_info::currencyanrong() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.currencyAnRong)
  return *currencyanrong_;
}
inline void user_basic_info::set_currencyanrong(const ::std::string& value) {
  set_has_currencyanrong();
  if (currencyanrong_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyanrong_ = new ::std::string;
  }
  currencyanrong_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.currencyAnRong)
}
inline void user_basic_info::set_currencyanrong(const char* value) {
  set_has_currencyanrong();
  if (currencyanrong_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyanrong_ = new ::std::string;
  }
  currencyanrong_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.currencyAnRong)
}
inline void user_basic_info::set_currencyanrong(const void* value, size_t size) {
  set_has_currencyanrong();
  if (currencyanrong_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyanrong_ = new ::std::string;
  }
  currencyanrong_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.currencyAnRong)
}
inline ::std::string* user_basic_info::mutable_currencyanrong() {
  set_has_currencyanrong();
  if (currencyanrong_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyanrong_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.currencyAnRong)
  return currencyanrong_;
}
inline ::std::string* user_basic_info::release_currencyanrong() {
  clear_has_currencyanrong();
  if (currencyanrong_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currencyanrong_;
    currencyanrong_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_currencyanrong(::std::string* currencyanrong) {
  if (currencyanrong_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currencyanrong_;
  }
  if (currencyanrong) {
    set_has_currencyanrong();
    currencyanrong_ = currencyanrong;
  } else {
    clear_has_currencyanrong();
    currencyanrong_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.currencyAnRong)
}

// optional int32 loanTimeLimit = 69;
inline bool user_basic_info::has_loantimelimit() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void user_basic_info::set_has_loantimelimit() {
  _has_bits_[2] |= 0x00000010u;
}
inline void user_basic_info::clear_has_loantimelimit() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void user_basic_info::clear_loantimelimit() {
  loantimelimit_ = 0;
  clear_has_loantimelimit();
}
inline ::google::protobuf::int32 user_basic_info::loantimelimit() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanTimeLimit)
  return loantimelimit_;
}
inline void user_basic_info::set_loantimelimit(::google::protobuf::int32 value) {
  set_has_loantimelimit();
  loantimelimit_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanTimeLimit)
}

// optional bytes assureType = 70;
inline bool user_basic_info::has_assuretype() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void user_basic_info::set_has_assuretype() {
  _has_bits_[2] |= 0x00000020u;
}
inline void user_basic_info::clear_has_assuretype() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void user_basic_info::clear_assuretype() {
  if (assuretype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assuretype_->clear();
  }
  clear_has_assuretype();
}
inline const ::std::string& user_basic_info::assuretype() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.assureType)
  return *assuretype_;
}
inline void user_basic_info::set_assuretype(const ::std::string& value) {
  set_has_assuretype();
  if (assuretype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assuretype_ = new ::std::string;
  }
  assuretype_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.assureType)
}
inline void user_basic_info::set_assuretype(const char* value) {
  set_has_assuretype();
  if (assuretype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assuretype_ = new ::std::string;
  }
  assuretype_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.assureType)
}
inline void user_basic_info::set_assuretype(const void* value, size_t size) {
  set_has_assuretype();
  if (assuretype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assuretype_ = new ::std::string;
  }
  assuretype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.assureType)
}
inline ::std::string* user_basic_info::mutable_assuretype() {
  set_has_assuretype();
  if (assuretype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    assuretype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.assureType)
  return assuretype_;
}
inline ::std::string* user_basic_info::release_assuretype() {
  clear_has_assuretype();
  if (assuretype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = assuretype_;
    assuretype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_assuretype(::std::string* assuretype) {
  if (assuretype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete assuretype_;
  }
  if (assuretype) {
    set_has_assuretype();
    assuretype_ = assuretype;
  } else {
    clear_has_assuretype();
    assuretype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.assureType)
}

// optional bytes applyDate = 71;
inline bool user_basic_info::has_applydate() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void user_basic_info::set_has_applydate() {
  _has_bits_[2] |= 0x00000040u;
}
inline void user_basic_info::clear_has_applydate() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void user_basic_info::clear_applydate() {
  if (applydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_->clear();
  }
  clear_has_applydate();
}
inline const ::std::string& user_basic_info::applydate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.applyDate)
  return *applydate_;
}
inline void user_basic_info::set_applydate(const ::std::string& value) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.applyDate)
}
inline void user_basic_info::set_applydate(const char* value) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.applyDate)
}
inline void user_basic_info::set_applydate(const void* value, size_t size) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.applyDate)
}
inline ::std::string* user_basic_info::mutable_applydate() {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.applyDate)
  return applydate_;
}
inline ::std::string* user_basic_info::release_applydate() {
  clear_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applydate_;
    applydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_applydate(::std::string* applydate) {
  if (applydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applydate_;
  }
  if (applydate) {
    set_has_applydate();
    applydate_ = applydate;
  } else {
    clear_has_applydate();
    applydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.applyDate)
}

// optional bytes creditAddress = 72;
inline bool user_basic_info::has_creditaddress() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void user_basic_info::set_has_creditaddress() {
  _has_bits_[2] |= 0x00000080u;
}
inline void user_basic_info::clear_has_creditaddress() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void user_basic_info::clear_creditaddress() {
  if (creditaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditaddress_->clear();
  }
  clear_has_creditaddress();
}
inline const ::std::string& user_basic_info::creditaddress() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.creditAddress)
  return *creditaddress_;
}
inline void user_basic_info::set_creditaddress(const ::std::string& value) {
  set_has_creditaddress();
  if (creditaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditaddress_ = new ::std::string;
  }
  creditaddress_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.creditAddress)
}
inline void user_basic_info::set_creditaddress(const char* value) {
  set_has_creditaddress();
  if (creditaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditaddress_ = new ::std::string;
  }
  creditaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.creditAddress)
}
inline void user_basic_info::set_creditaddress(const void* value, size_t size) {
  set_has_creditaddress();
  if (creditaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditaddress_ = new ::std::string;
  }
  creditaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.creditAddress)
}
inline ::std::string* user_basic_info::mutable_creditaddress() {
  set_has_creditaddress();
  if (creditaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.creditAddress)
  return creditaddress_;
}
inline ::std::string* user_basic_info::release_creditaddress() {
  clear_has_creditaddress();
  if (creditaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = creditaddress_;
    creditaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_creditaddress(::std::string* creditaddress) {
  if (creditaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete creditaddress_;
  }
  if (creditaddress) {
    set_has_creditaddress();
    creditaddress_ = creditaddress;
  } else {
    clear_has_creditaddress();
    creditaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.creditAddress)
}

// optional bytes applyResult = 73;
inline bool user_basic_info::has_applyresult() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void user_basic_info::set_has_applyresult() {
  _has_bits_[2] |= 0x00000100u;
}
inline void user_basic_info::clear_has_applyresult() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void user_basic_info::clear_applyresult() {
  if (applyresult_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresult_->clear();
  }
  clear_has_applyresult();
}
inline const ::std::string& user_basic_info::applyresult() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.applyResult)
  return *applyresult_;
}
inline void user_basic_info::set_applyresult(const ::std::string& value) {
  set_has_applyresult();
  if (applyresult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresult_ = new ::std::string;
  }
  applyresult_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.applyResult)
}
inline void user_basic_info::set_applyresult(const char* value) {
  set_has_applyresult();
  if (applyresult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresult_ = new ::std::string;
  }
  applyresult_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.applyResult)
}
inline void user_basic_info::set_applyresult(const void* value, size_t size) {
  set_has_applyresult();
  if (applyresult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresult_ = new ::std::string;
  }
  applyresult_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.applyResult)
}
inline ::std::string* user_basic_info::mutable_applyresult() {
  set_has_applyresult();
  if (applyresult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresult_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.applyResult)
  return applyresult_;
}
inline ::std::string* user_basic_info::release_applyresult() {
  clear_has_applyresult();
  if (applyresult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applyresult_;
    applyresult_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_applyresult(::std::string* applyresult) {
  if (applyresult_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applyresult_;
  }
  if (applyresult) {
    set_has_applyresult();
    applyresult_ = applyresult;
  } else {
    clear_has_applyresult();
    applyresult_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.applyResult)
}

// optional bytes applyResultTime = 74;
inline bool user_basic_info::has_applyresulttime() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void user_basic_info::set_has_applyresulttime() {
  _has_bits_[2] |= 0x00000200u;
}
inline void user_basic_info::clear_has_applyresulttime() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void user_basic_info::clear_applyresulttime() {
  if (applyresulttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresulttime_->clear();
  }
  clear_has_applyresulttime();
}
inline const ::std::string& user_basic_info::applyresulttime() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.applyResultTime)
  return *applyresulttime_;
}
inline void user_basic_info::set_applyresulttime(const ::std::string& value) {
  set_has_applyresulttime();
  if (applyresulttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresulttime_ = new ::std::string;
  }
  applyresulttime_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.applyResultTime)
}
inline void user_basic_info::set_applyresulttime(const char* value) {
  set_has_applyresulttime();
  if (applyresulttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresulttime_ = new ::std::string;
  }
  applyresulttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.applyResultTime)
}
inline void user_basic_info::set_applyresulttime(const void* value, size_t size) {
  set_has_applyresulttime();
  if (applyresulttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresulttime_ = new ::std::string;
  }
  applyresulttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.applyResultTime)
}
inline ::std::string* user_basic_info::mutable_applyresulttime() {
  set_has_applyresulttime();
  if (applyresulttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applyresulttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.applyResultTime)
  return applyresulttime_;
}
inline ::std::string* user_basic_info::release_applyresulttime() {
  clear_has_applyresulttime();
  if (applyresulttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applyresulttime_;
    applyresulttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_applyresulttime(::std::string* applyresulttime) {
  if (applyresulttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applyresulttime_;
  }
  if (applyresulttime) {
    set_has_applyresulttime();
    applyresulttime_ = applyresulttime;
  } else {
    clear_has_applyresulttime();
    applyresulttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.applyResultTime)
}

// optional bytes loanAccount = 75;
inline bool user_basic_info::has_loanaccount() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void user_basic_info::set_has_loanaccount() {
  _has_bits_[2] |= 0x00000400u;
}
inline void user_basic_info::clear_has_loanaccount() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void user_basic_info::clear_loanaccount() {
  if (loanaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanaccount_->clear();
  }
  clear_has_loanaccount();
}
inline const ::std::string& user_basic_info::loanaccount() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanAccount)
  return *loanaccount_;
}
inline void user_basic_info::set_loanaccount(const ::std::string& value) {
  set_has_loanaccount();
  if (loanaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanaccount_ = new ::std::string;
  }
  loanaccount_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanAccount)
}
inline void user_basic_info::set_loanaccount(const char* value) {
  set_has_loanaccount();
  if (loanaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanaccount_ = new ::std::string;
  }
  loanaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.loanAccount)
}
inline void user_basic_info::set_loanaccount(const void* value, size_t size) {
  set_has_loanaccount();
  if (loanaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanaccount_ = new ::std::string;
  }
  loanaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.loanAccount)
}
inline ::std::string* user_basic_info::mutable_loanaccount() {
  set_has_loanaccount();
  if (loanaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loanaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.loanAccount)
  return loanaccount_;
}
inline ::std::string* user_basic_info::release_loanaccount() {
  clear_has_loanaccount();
  if (loanaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loanaccount_;
    loanaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_loanaccount(::std::string* loanaccount) {
  if (loanaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loanaccount_;
  }
  if (loanaccount) {
    set_has_loanaccount();
    loanaccount_ = loanaccount;
  } else {
    clear_has_loanaccount();
    loanaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.loanAccount)
}

// optional bytes creditStartDate = 76;
inline bool user_basic_info::has_creditstartdate() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void user_basic_info::set_has_creditstartdate() {
  _has_bits_[2] |= 0x00000800u;
}
inline void user_basic_info::clear_has_creditstartdate() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void user_basic_info::clear_creditstartdate() {
  if (creditstartdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditstartdate_->clear();
  }
  clear_has_creditstartdate();
}
inline const ::std::string& user_basic_info::creditstartdate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.creditStartDate)
  return *creditstartdate_;
}
inline void user_basic_info::set_creditstartdate(const ::std::string& value) {
  set_has_creditstartdate();
  if (creditstartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditstartdate_ = new ::std::string;
  }
  creditstartdate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.creditStartDate)
}
inline void user_basic_info::set_creditstartdate(const char* value) {
  set_has_creditstartdate();
  if (creditstartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditstartdate_ = new ::std::string;
  }
  creditstartdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.creditStartDate)
}
inline void user_basic_info::set_creditstartdate(const void* value, size_t size) {
  set_has_creditstartdate();
  if (creditstartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditstartdate_ = new ::std::string;
  }
  creditstartdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.creditStartDate)
}
inline ::std::string* user_basic_info::mutable_creditstartdate() {
  set_has_creditstartdate();
  if (creditstartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditstartdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.creditStartDate)
  return creditstartdate_;
}
inline ::std::string* user_basic_info::release_creditstartdate() {
  clear_has_creditstartdate();
  if (creditstartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = creditstartdate_;
    creditstartdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_creditstartdate(::std::string* creditstartdate) {
  if (creditstartdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete creditstartdate_;
  }
  if (creditstartdate) {
    set_has_creditstartdate();
    creditstartdate_ = creditstartdate;
  } else {
    clear_has_creditstartdate();
    creditstartdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.creditStartDate)
}

// optional bytes creditEndDate = 77;
inline bool user_basic_info::has_creditenddate() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void user_basic_info::set_has_creditenddate() {
  _has_bits_[2] |= 0x00001000u;
}
inline void user_basic_info::clear_has_creditenddate() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void user_basic_info::clear_creditenddate() {
  if (creditenddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditenddate_->clear();
  }
  clear_has_creditenddate();
}
inline const ::std::string& user_basic_info::creditenddate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.creditEndDate)
  return *creditenddate_;
}
inline void user_basic_info::set_creditenddate(const ::std::string& value) {
  set_has_creditenddate();
  if (creditenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditenddate_ = new ::std::string;
  }
  creditenddate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.creditEndDate)
}
inline void user_basic_info::set_creditenddate(const char* value) {
  set_has_creditenddate();
  if (creditenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditenddate_ = new ::std::string;
  }
  creditenddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.creditEndDate)
}
inline void user_basic_info::set_creditenddate(const void* value, size_t size) {
  set_has_creditenddate();
  if (creditenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditenddate_ = new ::std::string;
  }
  creditenddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.creditEndDate)
}
inline ::std::string* user_basic_info::mutable_creditenddate() {
  set_has_creditenddate();
  if (creditenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    creditenddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.creditEndDate)
  return creditenddate_;
}
inline ::std::string* user_basic_info::release_creditenddate() {
  clear_has_creditenddate();
  if (creditenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = creditenddate_;
    creditenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_creditenddate(::std::string* creditenddate) {
  if (creditenddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete creditenddate_;
  }
  if (creditenddate) {
    set_has_creditenddate();
    creditenddate_ = creditenddate;
  } else {
    clear_has_creditenddate();
    creditenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.creditEndDate)
}

// optional int32 loanPeriods = 78;
inline bool user_basic_info::has_loanperiods() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void user_basic_info::set_has_loanperiods() {
  _has_bits_[2] |= 0x00002000u;
}
inline void user_basic_info::clear_has_loanperiods() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void user_basic_info::clear_loanperiods() {
  loanperiods_ = 0;
  clear_has_loanperiods();
}
inline ::google::protobuf::int32 user_basic_info::loanperiods() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.loanPeriods)
  return loanperiods_;
}
inline void user_basic_info::set_loanperiods(::google::protobuf::int32 value) {
  set_has_loanperiods();
  loanperiods_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.loanPeriods)
}

// optional double backMoney = 79;
inline bool user_basic_info::has_backmoney() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void user_basic_info::set_has_backmoney() {
  _has_bits_[2] |= 0x00004000u;
}
inline void user_basic_info::clear_has_backmoney() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void user_basic_info::clear_backmoney() {
  backmoney_ = 0;
  clear_has_backmoney();
}
inline double user_basic_info::backmoney() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.backMoney)
  return backmoney_;
}
inline void user_basic_info::set_backmoney(double value) {
  set_has_backmoney();
  backmoney_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.backMoney)
}

// optional bytes isClear = 80;
inline bool user_basic_info::has_isclear() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void user_basic_info::set_has_isclear() {
  _has_bits_[2] |= 0x00008000u;
}
inline void user_basic_info::clear_has_isclear() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void user_basic_info::clear_isclear() {
  if (isclear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    isclear_->clear();
  }
  clear_has_isclear();
}
inline const ::std::string& user_basic_info::isclear() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.isClear)
  return *isclear_;
}
inline void user_basic_info::set_isclear(const ::std::string& value) {
  set_has_isclear();
  if (isclear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    isclear_ = new ::std::string;
  }
  isclear_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.isClear)
}
inline void user_basic_info::set_isclear(const char* value) {
  set_has_isclear();
  if (isclear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    isclear_ = new ::std::string;
  }
  isclear_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.isClear)
}
inline void user_basic_info::set_isclear(const void* value, size_t size) {
  set_has_isclear();
  if (isclear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    isclear_ = new ::std::string;
  }
  isclear_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.isClear)
}
inline ::std::string* user_basic_info::mutable_isclear() {
  set_has_isclear();
  if (isclear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    isclear_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.isClear)
  return isclear_;
}
inline ::std::string* user_basic_info::release_isclear() {
  clear_has_isclear();
  if (isclear_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = isclear_;
    isclear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_isclear(::std::string* isclear) {
  if (isclear_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete isclear_;
  }
  if (isclear) {
    set_has_isclear();
    isclear_ = isclear;
  } else {
    clear_has_isclear();
    isclear_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.isClear)
}

// optional double nbsMoney = 81;
inline bool user_basic_info::has_nbsmoney() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void user_basic_info::set_has_nbsmoney() {
  _has_bits_[2] |= 0x00010000u;
}
inline void user_basic_info::clear_has_nbsmoney() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void user_basic_info::clear_nbsmoney() {
  nbsmoney_ = 0;
  clear_has_nbsmoney();
}
inline double user_basic_info::nbsmoney() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.nbsMoney)
  return nbsmoney_;
}
inline void user_basic_info::set_nbsmoney(double value) {
  set_has_nbsmoney();
  nbsmoney_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.nbsMoney)
}

// optional double nbMoney = 82;
inline bool user_basic_info::has_nbmoney() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void user_basic_info::set_has_nbmoney() {
  _has_bits_[2] |= 0x00020000u;
}
inline void user_basic_info::clear_has_nbmoney() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void user_basic_info::clear_nbmoney() {
  nbmoney_ = 0;
  clear_has_nbmoney();
}
inline double user_basic_info::nbmoney() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.nbMoney)
  return nbmoney_;
}
inline void user_basic_info::set_nbmoney(double value) {
  set_has_nbmoney();
  nbmoney_ = value;
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.nbMoney)
}

// optional bytes cleanDate = 83;
inline bool user_basic_info::has_cleandate() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void user_basic_info::set_has_cleandate() {
  _has_bits_[2] |= 0x00040000u;
}
inline void user_basic_info::clear_has_cleandate() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void user_basic_info::clear_cleandate() {
  if (cleandate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleandate_->clear();
  }
  clear_has_cleandate();
}
inline const ::std::string& user_basic_info::cleandate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.cleanDate)
  return *cleandate_;
}
inline void user_basic_info::set_cleandate(const ::std::string& value) {
  set_has_cleandate();
  if (cleandate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleandate_ = new ::std::string;
  }
  cleandate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.cleanDate)
}
inline void user_basic_info::set_cleandate(const char* value) {
  set_has_cleandate();
  if (cleandate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleandate_ = new ::std::string;
  }
  cleandate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.cleanDate)
}
inline void user_basic_info::set_cleandate(const void* value, size_t size) {
  set_has_cleandate();
  if (cleandate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleandate_ = new ::std::string;
  }
  cleandate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.cleanDate)
}
inline ::std::string* user_basic_info::mutable_cleandate() {
  set_has_cleandate();
  if (cleandate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cleandate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.cleanDate)
  return cleandate_;
}
inline ::std::string* user_basic_info::release_cleandate() {
  clear_has_cleandate();
  if (cleandate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cleandate_;
    cleandate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_cleandate(::std::string* cleandate) {
  if (cleandate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cleandate_;
  }
  if (cleandate) {
    set_has_cleandate();
    cleandate_ = cleandate;
  } else {
    clear_has_cleandate();
    cleandate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.cleanDate)
}

// optional bytes overdueStartDate = 84;
inline bool user_basic_info::has_overduestartdate() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void user_basic_info::set_has_overduestartdate() {
  _has_bits_[2] |= 0x00080000u;
}
inline void user_basic_info::clear_has_overduestartdate() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void user_basic_info::clear_overduestartdate() {
  if (overduestartdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestartdate_->clear();
  }
  clear_has_overduestartdate();
}
inline const ::std::string& user_basic_info::overduestartdate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.overdueStartDate)
  return *overduestartdate_;
}
inline void user_basic_info::set_overduestartdate(const ::std::string& value) {
  set_has_overduestartdate();
  if (overduestartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestartdate_ = new ::std::string;
  }
  overduestartdate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.overdueStartDate)
}
inline void user_basic_info::set_overduestartdate(const char* value) {
  set_has_overduestartdate();
  if (overduestartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestartdate_ = new ::std::string;
  }
  overduestartdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.overdueStartDate)
}
inline void user_basic_info::set_overduestartdate(const void* value, size_t size) {
  set_has_overduestartdate();
  if (overduestartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestartdate_ = new ::std::string;
  }
  overduestartdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.overdueStartDate)
}
inline ::std::string* user_basic_info::mutable_overduestartdate() {
  set_has_overduestartdate();
  if (overduestartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestartdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.overdueStartDate)
  return overduestartdate_;
}
inline ::std::string* user_basic_info::release_overduestartdate() {
  clear_has_overduestartdate();
  if (overduestartdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = overduestartdate_;
    overduestartdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_overduestartdate(::std::string* overduestartdate) {
  if (overduestartdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete overduestartdate_;
  }
  if (overduestartdate) {
    set_has_overduestartdate();
    overduestartdate_ = overduestartdate;
  } else {
    clear_has_overduestartdate();
    overduestartdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.overdueStartDate)
}

// optional bytes overdueEndDate = 85;
inline bool user_basic_info::has_overdueenddate() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void user_basic_info::set_has_overdueenddate() {
  _has_bits_[2] |= 0x00100000u;
}
inline void user_basic_info::clear_has_overdueenddate() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void user_basic_info::clear_overdueenddate() {
  if (overdueenddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overdueenddate_->clear();
  }
  clear_has_overdueenddate();
}
inline const ::std::string& user_basic_info::overdueenddate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.overdueEndDate)
  return *overdueenddate_;
}
inline void user_basic_info::set_overdueenddate(const ::std::string& value) {
  set_has_overdueenddate();
  if (overdueenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overdueenddate_ = new ::std::string;
  }
  overdueenddate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.overdueEndDate)
}
inline void user_basic_info::set_overdueenddate(const char* value) {
  set_has_overdueenddate();
  if (overdueenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overdueenddate_ = new ::std::string;
  }
  overdueenddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.overdueEndDate)
}
inline void user_basic_info::set_overdueenddate(const void* value, size_t size) {
  set_has_overdueenddate();
  if (overdueenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overdueenddate_ = new ::std::string;
  }
  overdueenddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.overdueEndDate)
}
inline ::std::string* user_basic_info::mutable_overdueenddate() {
  set_has_overdueenddate();
  if (overdueenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overdueenddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.overdueEndDate)
  return overdueenddate_;
}
inline ::std::string* user_basic_info::release_overdueenddate() {
  clear_has_overdueenddate();
  if (overdueenddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = overdueenddate_;
    overdueenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_overdueenddate(::std::string* overdueenddate) {
  if (overdueenddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete overdueenddate_;
  }
  if (overdueenddate) {
    set_has_overdueenddate();
    overdueenddate_ = overdueenddate;
  } else {
    clear_has_overdueenddate();
    overdueenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.overdueEndDate)
}

// optional bytes overdueReason = 86;
inline bool user_basic_info::has_overduereason() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void user_basic_info::set_has_overduereason() {
  _has_bits_[2] |= 0x00200000u;
}
inline void user_basic_info::clear_has_overduereason() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void user_basic_info::clear_overduereason() {
  if (overduereason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduereason_->clear();
  }
  clear_has_overduereason();
}
inline const ::std::string& user_basic_info::overduereason() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.overdueReason)
  return *overduereason_;
}
inline void user_basic_info::set_overduereason(const ::std::string& value) {
  set_has_overduereason();
  if (overduereason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduereason_ = new ::std::string;
  }
  overduereason_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.overdueReason)
}
inline void user_basic_info::set_overduereason(const char* value) {
  set_has_overduereason();
  if (overduereason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduereason_ = new ::std::string;
  }
  overduereason_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.overdueReason)
}
inline void user_basic_info::set_overduereason(const void* value, size_t size) {
  set_has_overduereason();
  if (overduereason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduereason_ = new ::std::string;
  }
  overduereason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.overdueReason)
}
inline ::std::string* user_basic_info::mutable_overduereason() {
  set_has_overduereason();
  if (overduereason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduereason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.overdueReason)
  return overduereason_;
}
inline ::std::string* user_basic_info::release_overduereason() {
  clear_has_overduereason();
  if (overduereason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = overduereason_;
    overduereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_overduereason(::std::string* overduereason) {
  if (overduereason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete overduereason_;
  }
  if (overduereason) {
    set_has_overduereason();
    overduereason_ = overduereason;
  } else {
    clear_has_overduereason();
    overduereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.overdueReason)
}

// optional bytes overdueState = 87;
inline bool user_basic_info::has_overduestate() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void user_basic_info::set_has_overduestate() {
  _has_bits_[2] |= 0x00400000u;
}
inline void user_basic_info::clear_has_overduestate() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void user_basic_info::clear_overduestate() {
  if (overduestate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestate_->clear();
  }
  clear_has_overduestate();
}
inline const ::std::string& user_basic_info::overduestate() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.overdueState)
  return *overduestate_;
}
inline void user_basic_info::set_overduestate(const ::std::string& value) {
  set_has_overduestate();
  if (overduestate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestate_ = new ::std::string;
  }
  overduestate_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.overdueState)
}
inline void user_basic_info::set_overduestate(const char* value) {
  set_has_overduestate();
  if (overduestate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestate_ = new ::std::string;
  }
  overduestate_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.overdueState)
}
inline void user_basic_info::set_overduestate(const void* value, size_t size) {
  set_has_overduestate();
  if (overduestate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestate_ = new ::std::string;
  }
  overduestate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.overdueState)
}
inline ::std::string* user_basic_info::mutable_overduestate() {
  set_has_overduestate();
  if (overduestate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    overduestate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.overdueState)
  return overduestate_;
}
inline ::std::string* user_basic_info::release_overduestate() {
  clear_has_overduestate();
  if (overduestate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = overduestate_;
    overduestate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_overduestate(::std::string* overduestate) {
  if (overduestate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete overduestate_;
  }
  if (overduestate) {
    set_has_overduestate();
    overduestate_ = overduestate;
  } else {
    clear_has_overduestate();
    overduestate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.overdueState)
}

// optional bytes relation_name = 88;
inline bool user_basic_info::has_relation_name() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void user_basic_info::set_has_relation_name() {
  _has_bits_[2] |= 0x00800000u;
}
inline void user_basic_info::clear_has_relation_name() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void user_basic_info::clear_relation_name() {
  if (relation_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_name_->clear();
  }
  clear_has_relation_name();
}
inline const ::std::string& user_basic_info::relation_name() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.relation_name)
  return *relation_name_;
}
inline void user_basic_info::set_relation_name(const ::std::string& value) {
  set_has_relation_name();
  if (relation_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_name_ = new ::std::string;
  }
  relation_name_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.relation_name)
}
inline void user_basic_info::set_relation_name(const char* value) {
  set_has_relation_name();
  if (relation_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_name_ = new ::std::string;
  }
  relation_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.relation_name)
}
inline void user_basic_info::set_relation_name(const void* value, size_t size) {
  set_has_relation_name();
  if (relation_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_name_ = new ::std::string;
  }
  relation_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.relation_name)
}
inline ::std::string* user_basic_info::mutable_relation_name() {
  set_has_relation_name();
  if (relation_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.relation_name)
  return relation_name_;
}
inline ::std::string* user_basic_info::release_relation_name() {
  clear_has_relation_name();
  if (relation_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = relation_name_;
    relation_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_relation_name(::std::string* relation_name) {
  if (relation_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete relation_name_;
  }
  if (relation_name) {
    set_has_relation_name();
    relation_name_ = relation_name;
  } else {
    clear_has_relation_name();
    relation_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.relation_name)
}

// optional bytes relation_phone = 89;
inline bool user_basic_info::has_relation_phone() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void user_basic_info::set_has_relation_phone() {
  _has_bits_[2] |= 0x01000000u;
}
inline void user_basic_info::clear_has_relation_phone() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void user_basic_info::clear_relation_phone() {
  if (relation_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_phone_->clear();
  }
  clear_has_relation_phone();
}
inline const ::std::string& user_basic_info::relation_phone() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.relation_phone)
  return *relation_phone_;
}
inline void user_basic_info::set_relation_phone(const ::std::string& value) {
  set_has_relation_phone();
  if (relation_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_phone_ = new ::std::string;
  }
  relation_phone_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.relation_phone)
}
inline void user_basic_info::set_relation_phone(const char* value) {
  set_has_relation_phone();
  if (relation_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_phone_ = new ::std::string;
  }
  relation_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.relation_phone)
}
inline void user_basic_info::set_relation_phone(const void* value, size_t size) {
  set_has_relation_phone();
  if (relation_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_phone_ = new ::std::string;
  }
  relation_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.relation_phone)
}
inline ::std::string* user_basic_info::mutable_relation_phone() {
  set_has_relation_phone();
  if (relation_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    relation_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.relation_phone)
  return relation_phone_;
}
inline ::std::string* user_basic_info::release_relation_phone() {
  clear_has_relation_phone();
  if (relation_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = relation_phone_;
    relation_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_relation_phone(::std::string* relation_phone) {
  if (relation_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete relation_phone_;
  }
  if (relation_phone) {
    set_has_relation_phone();
    relation_phone_ = relation_phone;
  } else {
    clear_has_relation_phone();
    relation_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.relation_phone)
}

// optional bytes trading_address = 90;
inline bool user_basic_info::has_trading_address() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void user_basic_info::set_has_trading_address() {
  _has_bits_[2] |= 0x02000000u;
}
inline void user_basic_info::clear_has_trading_address() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void user_basic_info::clear_trading_address() {
  if (trading_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trading_address_->clear();
  }
  clear_has_trading_address();
}
inline const ::std::string& user_basic_info::trading_address() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.trading_address)
  return *trading_address_;
}
inline void user_basic_info::set_trading_address(const ::std::string& value) {
  set_has_trading_address();
  if (trading_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trading_address_ = new ::std::string;
  }
  trading_address_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.trading_address)
}
inline void user_basic_info::set_trading_address(const char* value) {
  set_has_trading_address();
  if (trading_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trading_address_ = new ::std::string;
  }
  trading_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.trading_address)
}
inline void user_basic_info::set_trading_address(const void* value, size_t size) {
  set_has_trading_address();
  if (trading_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trading_address_ = new ::std::string;
  }
  trading_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.trading_address)
}
inline ::std::string* user_basic_info::mutable_trading_address() {
  set_has_trading_address();
  if (trading_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trading_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.trading_address)
  return trading_address_;
}
inline ::std::string* user_basic_info::release_trading_address() {
  clear_has_trading_address();
  if (trading_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = trading_address_;
    trading_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_trading_address(::std::string* trading_address) {
  if (trading_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trading_address_;
  }
  if (trading_address) {
    set_has_trading_address();
    trading_address_ = trading_address;
  } else {
    clear_has_trading_address();
    trading_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.trading_address)
}

// optional bytes business = 91;
inline bool user_basic_info::has_business() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void user_basic_info::set_has_business() {
  _has_bits_[2] |= 0x04000000u;
}
inline void user_basic_info::clear_has_business() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void user_basic_info::clear_business() {
  if (business_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    business_->clear();
  }
  clear_has_business();
}
inline const ::std::string& user_basic_info::business() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.business)
  return *business_;
}
inline void user_basic_info::set_business(const ::std::string& value) {
  set_has_business();
  if (business_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    business_ = new ::std::string;
  }
  business_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.business)
}
inline void user_basic_info::set_business(const char* value) {
  set_has_business();
  if (business_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    business_ = new ::std::string;
  }
  business_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.business)
}
inline void user_basic_info::set_business(const void* value, size_t size) {
  set_has_business();
  if (business_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    business_ = new ::std::string;
  }
  business_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.business)
}
inline ::std::string* user_basic_info::mutable_business() {
  set_has_business();
  if (business_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    business_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.business)
  return business_;
}
inline ::std::string* user_basic_info::release_business() {
  clear_has_business();
  if (business_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = business_;
    business_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_business(::std::string* business) {
  if (business_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete business_;
  }
  if (business) {
    set_has_business();
    business_ = business;
  } else {
    clear_has_business();
    business_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.business)
}

// optional bytes levelNo = 92;
inline bool user_basic_info::has_levelno() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void user_basic_info::set_has_levelno() {
  _has_bits_[2] |= 0x08000000u;
}
inline void user_basic_info::clear_has_levelno() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void user_basic_info::clear_levelno() {
  if (levelno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    levelno_->clear();
  }
  clear_has_levelno();
}
inline const ::std::string& user_basic_info::levelno() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.levelNo)
  return *levelno_;
}
inline void user_basic_info::set_levelno(const ::std::string& value) {
  set_has_levelno();
  if (levelno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    levelno_ = new ::std::string;
  }
  levelno_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.levelNo)
}
inline void user_basic_info::set_levelno(const char* value) {
  set_has_levelno();
  if (levelno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    levelno_ = new ::std::string;
  }
  levelno_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.levelNo)
}
inline void user_basic_info::set_levelno(const void* value, size_t size) {
  set_has_levelno();
  if (levelno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    levelno_ = new ::std::string;
  }
  levelno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.levelNo)
}
inline ::std::string* user_basic_info::mutable_levelno() {
  set_has_levelno();
  if (levelno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    levelno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.levelNo)
  return levelno_;
}
inline ::std::string* user_basic_info::release_levelno() {
  clear_has_levelno();
  if (levelno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = levelno_;
    levelno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_levelno(::std::string* levelno) {
  if (levelno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete levelno_;
  }
  if (levelno) {
    set_has_levelno();
    levelno_ = levelno;
  } else {
    clear_has_levelno();
    levelno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.levelNo)
}

// optional bytes requestFileList = 93;
inline bool user_basic_info::has_requestfilelist() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void user_basic_info::set_has_requestfilelist() {
  _has_bits_[2] |= 0x10000000u;
}
inline void user_basic_info::clear_has_requestfilelist() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void user_basic_info::clear_requestfilelist() {
  if (requestfilelist_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requestfilelist_->clear();
  }
  clear_has_requestfilelist();
}
inline const ::std::string& user_basic_info::requestfilelist() const {
  // @@protoc_insertion_point(field_get:QDP_basic_info.user_basic_info.requestFileList)
  return *requestfilelist_;
}
inline void user_basic_info::set_requestfilelist(const ::std::string& value) {
  set_has_requestfilelist();
  if (requestfilelist_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requestfilelist_ = new ::std::string;
  }
  requestfilelist_->assign(value);
  // @@protoc_insertion_point(field_set:QDP_basic_info.user_basic_info.requestFileList)
}
inline void user_basic_info::set_requestfilelist(const char* value) {
  set_has_requestfilelist();
  if (requestfilelist_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requestfilelist_ = new ::std::string;
  }
  requestfilelist_->assign(value);
  // @@protoc_insertion_point(field_set_char:QDP_basic_info.user_basic_info.requestFileList)
}
inline void user_basic_info::set_requestfilelist(const void* value, size_t size) {
  set_has_requestfilelist();
  if (requestfilelist_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requestfilelist_ = new ::std::string;
  }
  requestfilelist_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:QDP_basic_info.user_basic_info.requestFileList)
}
inline ::std::string* user_basic_info::mutable_requestfilelist() {
  set_has_requestfilelist();
  if (requestfilelist_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requestfilelist_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:QDP_basic_info.user_basic_info.requestFileList)
  return requestfilelist_;
}
inline ::std::string* user_basic_info::release_requestfilelist() {
  clear_has_requestfilelist();
  if (requestfilelist_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requestfilelist_;
    requestfilelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_basic_info::set_allocated_requestfilelist(::std::string* requestfilelist) {
  if (requestfilelist_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requestfilelist_;
  }
  if (requestfilelist) {
    set_has_requestfilelist();
    requestfilelist_ = requestfilelist;
  } else {
    clear_has_requestfilelist();
    requestfilelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:QDP_basic_info.user_basic_info.requestFileList)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace QDP_basic_info

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::QDP_basic_info::degree> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QDP_basic_info::degree>() {
  return ::QDP_basic_info::degree_descriptor();
}
template <> struct is_proto_enum< ::QDP_basic_info::control_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QDP_basic_info::control_code>() {
  return ::QDP_basic_info::control_code_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_QDP_5fbasic_5finfo_2eproto__INCLUDED
