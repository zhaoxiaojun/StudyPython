// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ODP_main_frame.proto

#ifndef PROTOBUF_ODP_5fmain_5fframe_2eproto__INCLUDED
#define PROTOBUF_ODP_5fmain_5fframe_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace ODP_main_frame {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

class Pay_Withdraw;
class province_under_count;
class city_bid_count;
class unfinished_bid_info;
class user_distribution;
class cur_trading_volume;
class cur_province_trading_volume;
class month_registration_volume;
class cur_trading_count;
class month_trading_volume;
class registration_info;
class charge_info;
class real_fund_detail;
class fund_flow_type;
class user_acount_info;
class top_ten_user_acount_info;
class start_count_info;
class user_analyze_info;
class user_freshness_info;
class user_retain_rate_info;
class user_retain_info;
class app_version_statistics;
class app_version_detail;
class download_src_user_acount_info;
class download_src_detail;
class use_time_info;
class use_count_info;
class use_interval_info;
class third_party_login_info;
class Pay_Withdraw_ask;
class Pay_Withdraw_ans;
class unfinished_bid_ask;
class unfinished_bid_ans;
class city_bid_count_ask;
class city_bid_count_ans;
class user_distribution_ask;
class user_distribution_ans;
class cur_trading_volume_ask;
class cur_trading_volume_ans;
class cur_province_trading_volume_ask;
class cur_province_trading_volume_ans;
class Real_time_registration_ask;
class Real_time_registration_ans;
class month_registration_ask;
class month_registration_ans;
class real_time_charge_ask;
class real_time_charge_ans;
class cur_trading_count_ask;
class cur_trading_count_ans;
class month_trading_ask;
class month_trading_ans;
class cur_fund_detail_ask;
class cur_fund_detail_ans;
class history_fund_detail_ask;
class history_fund_detail_ans;
class history_fund_flow_type_ask;
class history_fund_flow_type_ans;
class client_versions_tendency_ask;
class client_versions_tendency_ans;
class client_versions_distribution_ask;
class client_versions_distribution_ans;
class client_versions_distribution_detail_ask;
class client_versions_distribution_detail_ans;
class client_versions_distribution_detail_list_ask;
class client_versions_distribution_detail_list_ans;
class start_count_analyze_ask;
class start_count_analyze_ans;
class start_count_analyze_list_ask;
class start_count_analyze_list_ans;
class new_add_user_analyze_ask;
class new_add_user_analyze_ans;
class new_add_user_analyze_list_ask;
class new_add_user_analyze_list_ans;
class active_user_analyze_ask;
class active_user_analyze_ans;
class active_user_analyze_list_ask;
class active_user_analyze_list_ans;
class user_freshness_analyze_ask;
class user_freshness_analyze_ans;
class user_freshness_analyze_list_ask;
class user_freshness_analyze_list_ans;
class user_retain_analyze_ask;
class user_retain_analyze_ans;
class use_time_analyze_ask;
class use_time_analyze_ans;
class use_count_analyze_ask;
class use_count_analyze_ans;
class use_interval_analyze_ask;
class use_interval_analyze_ans;
class download_src_analyze_ask;
class download_src_analyze_ans;
class download_src_analyze_detail_ask;
class download_src_analyze_detail_ans;
class third_party_login_analyze_ask;
class third_party_login_analyze_ans;
class third_party_login_analyze_list_ask;
class third_party_login_analyze_list_ans;
class operation_report_ask;
class operation_report_info;
class operation_report_ans;
class doc_row;
class user_certification_list_row;
class user_certification_ask;
class user_certification_ans;

// ===================================================================

class Pay_Withdraw : public ::google::protobuf::Message {
 public:
  Pay_Withdraw();
  virtual ~Pay_Withdraw();

  Pay_Withdraw(const Pay_Withdraw& from);

  inline Pay_Withdraw& operator=(const Pay_Withdraw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pay_Withdraw& default_instance();

  void Swap(Pay_Withdraw* other);

  // implements Message ----------------------------------------------

  Pay_Withdraw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pay_Withdraw& from);
  void MergeFrom(const Pay_Withdraw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cur_date = 1;
  inline bool has_cur_date() const;
  inline void clear_cur_date();
  static const int kCurDateFieldNumber = 1;
  inline const ::std::string& cur_date() const;
  inline void set_cur_date(const ::std::string& value);
  inline void set_cur_date(const char* value);
  inline void set_cur_date(const void* value, size_t size);
  inline ::std::string* mutable_cur_date();
  inline ::std::string* release_cur_date();
  inline void set_allocated_cur_date(::std::string* cur_date);

  // optional double pay_amount = 2;
  inline bool has_pay_amount() const;
  inline void clear_pay_amount();
  static const int kPayAmountFieldNumber = 2;
  inline double pay_amount() const;
  inline void set_pay_amount(double value);

  // optional double withdraw_amount = 3;
  inline bool has_withdraw_amount() const;
  inline void clear_withdraw_amount();
  static const int kWithdrawAmountFieldNumber = 3;
  inline double withdraw_amount() const;
  inline void set_withdraw_amount(double value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.Pay_Withdraw)
 private:
  inline void set_has_cur_date();
  inline void clear_has_cur_date();
  inline void set_has_pay_amount();
  inline void clear_has_pay_amount();
  inline void set_has_withdraw_amount();
  inline void clear_has_withdraw_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cur_date_;
  double pay_amount_;
  double withdraw_amount_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static Pay_Withdraw* default_instance_;
};
// -------------------------------------------------------------------

class province_under_count : public ::google::protobuf::Message {
 public:
  province_under_count();
  virtual ~province_under_count();

  province_under_count(const province_under_count& from);

  inline province_under_count& operator=(const province_under_count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const province_under_count& default_instance();

  void Swap(province_under_count* other);

  // implements Message ----------------------------------------------

  province_under_count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const province_under_count& from);
  void MergeFrom(const province_under_count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes province_name = 1;
  inline bool has_province_name() const;
  inline void clear_province_name();
  static const int kProvinceNameFieldNumber = 1;
  inline const ::std::string& province_name() const;
  inline void set_province_name(const ::std::string& value);
  inline void set_province_name(const char* value);
  inline void set_province_name(const void* value, size_t size);
  inline ::std::string* mutable_province_name();
  inline ::std::string* release_province_name();
  inline void set_allocated_province_name(::std::string* province_name);

  // optional int32 under_count = 2;
  inline bool has_under_count() const;
  inline void clear_under_count();
  static const int kUnderCountFieldNumber = 2;
  inline ::google::protobuf::int32 under_count() const;
  inline void set_under_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.province_under_count)
 private:
  inline void set_has_province_name();
  inline void clear_has_province_name();
  inline void set_has_under_count();
  inline void clear_has_under_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* province_name_;
  ::google::protobuf::int32 under_count_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static province_under_count* default_instance_;
};
// -------------------------------------------------------------------

class city_bid_count : public ::google::protobuf::Message {
 public:
  city_bid_count();
  virtual ~city_bid_count();

  city_bid_count(const city_bid_count& from);

  inline city_bid_count& operator=(const city_bid_count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_bid_count& default_instance();

  void Swap(city_bid_count* other);

  // implements Message ----------------------------------------------

  city_bid_count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_bid_count& from);
  void MergeFrom(const city_bid_count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes city_name = 1;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 1;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const void* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // optional int32 bid_count = 2;
  inline bool has_bid_count() const;
  inline void clear_bid_count();
  static const int kBidCountFieldNumber = 2;
  inline ::google::protobuf::int32 bid_count() const;
  inline void set_bid_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.city_bid_count)
 private:
  inline void set_has_city_name();
  inline void clear_has_city_name();
  inline void set_has_bid_count();
  inline void clear_has_bid_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_name_;
  ::google::protobuf::int32 bid_count_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static city_bid_count* default_instance_;
};
// -------------------------------------------------------------------

class unfinished_bid_info : public ::google::protobuf::Message {
 public:
  unfinished_bid_info();
  virtual ~unfinished_bid_info();

  unfinished_bid_info(const unfinished_bid_info& from);

  inline unfinished_bid_info& operator=(const unfinished_bid_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unfinished_bid_info& default_instance();

  void Swap(unfinished_bid_info* other);

  // implements Message ----------------------------------------------

  unfinished_bid_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unfinished_bid_info& from);
  void MergeFrom(const unfinished_bid_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes city_name = 1;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 1;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const void* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // repeated bytes role_city_name = 2;
  inline int role_city_name_size() const;
  inline void clear_role_city_name();
  static const int kRoleCityNameFieldNumber = 2;
  inline const ::std::string& role_city_name(int index) const;
  inline ::std::string* mutable_role_city_name(int index);
  inline void set_role_city_name(int index, const ::std::string& value);
  inline void set_role_city_name(int index, const char* value);
  inline void set_role_city_name(int index, const void* value, size_t size);
  inline ::std::string* add_role_city_name();
  inline void add_role_city_name(const ::std::string& value);
  inline void add_role_city_name(const char* value);
  inline void add_role_city_name(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& role_city_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_role_city_name();

  // @@protoc_insertion_point(class_scope:ODP_main_frame.unfinished_bid_info)
 private:
  inline void set_has_city_name();
  inline void clear_has_city_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> role_city_name_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static unfinished_bid_info* default_instance_;
};
// -------------------------------------------------------------------

class user_distribution : public ::google::protobuf::Message {
 public:
  user_distribution();
  virtual ~user_distribution();

  user_distribution(const user_distribution& from);

  inline user_distribution& operator=(const user_distribution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_distribution& default_instance();

  void Swap(user_distribution* other);

  // implements Message ----------------------------------------------

  user_distribution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_distribution& from);
  void MergeFrom(const user_distribution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes city_name = 1;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 1;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const void* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // optional int32 user_count = 2;
  inline bool has_user_count() const;
  inline void clear_user_count();
  static const int kUserCountFieldNumber = 2;
  inline ::google::protobuf::int32 user_count() const;
  inline void set_user_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_distribution)
 private:
  inline void set_has_city_name();
  inline void clear_has_city_name();
  inline void set_has_user_count();
  inline void clear_has_user_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_name_;
  ::google::protobuf::int32 user_count_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_distribution* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_volume : public ::google::protobuf::Message {
 public:
  cur_trading_volume();
  virtual ~cur_trading_volume();

  cur_trading_volume(const cur_trading_volume& from);

  inline cur_trading_volume& operator=(const cur_trading_volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_volume& default_instance();

  void Swap(cur_trading_volume* other);

  // implements Message ----------------------------------------------

  cur_trading_volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_volume& from);
  void MergeFrom(const cur_trading_volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hour = 1;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 1;
  inline const ::std::string& hour() const;
  inline void set_hour(const ::std::string& value);
  inline void set_hour(const char* value);
  inline void set_hour(const void* value, size_t size);
  inline ::std::string* mutable_hour();
  inline ::std::string* release_hour();
  inline void set_allocated_hour(::std::string* hour);

  // optional float trading_volume = 2;
  inline bool has_trading_volume() const;
  inline void clear_trading_volume();
  static const int kTradingVolumeFieldNumber = 2;
  inline float trading_volume() const;
  inline void set_trading_volume(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_volume)
 private:
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_trading_volume();
  inline void clear_has_trading_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hour_;
  float trading_volume_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_volume* default_instance_;
};
// -------------------------------------------------------------------

class cur_province_trading_volume : public ::google::protobuf::Message {
 public:
  cur_province_trading_volume();
  virtual ~cur_province_trading_volume();

  cur_province_trading_volume(const cur_province_trading_volume& from);

  inline cur_province_trading_volume& operator=(const cur_province_trading_volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_province_trading_volume& default_instance();

  void Swap(cur_province_trading_volume* other);

  // implements Message ----------------------------------------------

  cur_province_trading_volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_province_trading_volume& from);
  void MergeFrom(const cur_province_trading_volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes province_name = 1;
  inline bool has_province_name() const;
  inline void clear_province_name();
  static const int kProvinceNameFieldNumber = 1;
  inline const ::std::string& province_name() const;
  inline void set_province_name(const ::std::string& value);
  inline void set_province_name(const char* value);
  inline void set_province_name(const void* value, size_t size);
  inline ::std::string* mutable_province_name();
  inline ::std::string* release_province_name();
  inline void set_allocated_province_name(::std::string* province_name);

  // optional int32 trading_volume = 2;
  inline bool has_trading_volume() const;
  inline void clear_trading_volume();
  static const int kTradingVolumeFieldNumber = 2;
  inline ::google::protobuf::int32 trading_volume() const;
  inline void set_trading_volume(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_province_trading_volume)
 private:
  inline void set_has_province_name();
  inline void clear_has_province_name();
  inline void set_has_trading_volume();
  inline void clear_has_trading_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* province_name_;
  ::google::protobuf::int32 trading_volume_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_province_trading_volume* default_instance_;
};
// -------------------------------------------------------------------

class month_registration_volume : public ::google::protobuf::Message {
 public:
  month_registration_volume();
  virtual ~month_registration_volume();

  month_registration_volume(const month_registration_volume& from);

  inline month_registration_volume& operator=(const month_registration_volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_registration_volume& default_instance();

  void Swap(month_registration_volume* other);

  // implements Message ----------------------------------------------

  month_registration_volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_registration_volume& from);
  void MergeFrom(const month_registration_volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes year_month = 1;
  inline bool has_year_month() const;
  inline void clear_year_month();
  static const int kYearMonthFieldNumber = 1;
  inline const ::std::string& year_month() const;
  inline void set_year_month(const ::std::string& value);
  inline void set_year_month(const char* value);
  inline void set_year_month(const void* value, size_t size);
  inline ::std::string* mutable_year_month();
  inline ::std::string* release_year_month();
  inline void set_allocated_year_month(::std::string* year_month);

  // optional int32 regist_volume = 2;
  inline bool has_regist_volume() const;
  inline void clear_regist_volume();
  static const int kRegistVolumeFieldNumber = 2;
  inline ::google::protobuf::int32 regist_volume() const;
  inline void set_regist_volume(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_registration_volume)
 private:
  inline void set_has_year_month();
  inline void clear_has_year_month();
  inline void set_has_regist_volume();
  inline void clear_has_regist_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* year_month_;
  ::google::protobuf::int32 regist_volume_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_registration_volume* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_count : public ::google::protobuf::Message {
 public:
  cur_trading_count();
  virtual ~cur_trading_count();

  cur_trading_count(const cur_trading_count& from);

  inline cur_trading_count& operator=(const cur_trading_count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_count& default_instance();

  void Swap(cur_trading_count* other);

  // implements Message ----------------------------------------------

  cur_trading_count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_count& from);
  void MergeFrom(const cur_trading_count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hour = 1;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 1;
  inline const ::std::string& hour() const;
  inline void set_hour(const ::std::string& value);
  inline void set_hour(const char* value);
  inline void set_hour(const void* value, size_t size);
  inline ::std::string* mutable_hour();
  inline ::std::string* release_hour();
  inline void set_allocated_hour(::std::string* hour);

  // optional int32 trading_count = 2;
  inline bool has_trading_count() const;
  inline void clear_trading_count();
  static const int kTradingCountFieldNumber = 2;
  inline ::google::protobuf::int32 trading_count() const;
  inline void set_trading_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_count)
 private:
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_trading_count();
  inline void clear_has_trading_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hour_;
  ::google::protobuf::int32 trading_count_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_count* default_instance_;
};
// -------------------------------------------------------------------

class month_trading_volume : public ::google::protobuf::Message {
 public:
  month_trading_volume();
  virtual ~month_trading_volume();

  month_trading_volume(const month_trading_volume& from);

  inline month_trading_volume& operator=(const month_trading_volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_trading_volume& default_instance();

  void Swap(month_trading_volume* other);

  // implements Message ----------------------------------------------

  month_trading_volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_trading_volume& from);
  void MergeFrom(const month_trading_volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes year_month = 1;
  inline bool has_year_month() const;
  inline void clear_year_month();
  static const int kYearMonthFieldNumber = 1;
  inline const ::std::string& year_month() const;
  inline void set_year_month(const ::std::string& value);
  inline void set_year_month(const char* value);
  inline void set_year_month(const void* value, size_t size);
  inline ::std::string* mutable_year_month();
  inline ::std::string* release_year_month();
  inline void set_allocated_year_month(::std::string* year_month);

  // optional float trading_volume = 2;
  inline bool has_trading_volume() const;
  inline void clear_trading_volume();
  static const int kTradingVolumeFieldNumber = 2;
  inline float trading_volume() const;
  inline void set_trading_volume(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_trading_volume)
 private:
  inline void set_has_year_month();
  inline void clear_has_year_month();
  inline void set_has_trading_volume();
  inline void clear_has_trading_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* year_month_;
  float trading_volume_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_trading_volume* default_instance_;
};
// -------------------------------------------------------------------

class registration_info : public ::google::protobuf::Message {
 public:
  registration_info();
  virtual ~registration_info();

  registration_info(const registration_info& from);

  inline registration_info& operator=(const registration_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const registration_info& default_instance();

  void Swap(registration_info* other);

  // implements Message ----------------------------------------------

  registration_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const registration_info& from);
  void MergeFrom(const registration_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes city_name = 1;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 1;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const void* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.registration_info)
 private:
  inline void set_has_city_name();
  inline void clear_has_city_name();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_name_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static registration_info* default_instance_;
};
// -------------------------------------------------------------------

class charge_info : public ::google::protobuf::Message {
 public:
  charge_info();
  virtual ~charge_info();

  charge_info(const charge_info& from);

  inline charge_info& operator=(const charge_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const charge_info& default_instance();

  void Swap(charge_info* other);

  // implements Message ----------------------------------------------

  charge_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const charge_info& from);
  void MergeFrom(const charge_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes city_name = 1;
  inline bool has_city_name() const;
  inline void clear_city_name();
  static const int kCityNameFieldNumber = 1;
  inline const ::std::string& city_name() const;
  inline void set_city_name(const ::std::string& value);
  inline void set_city_name(const char* value);
  inline void set_city_name(const void* value, size_t size);
  inline ::std::string* mutable_city_name();
  inline ::std::string* release_city_name();
  inline void set_allocated_city_name(::std::string* city_name);

  // optional float charge_amount = 2;
  inline bool has_charge_amount() const;
  inline void clear_charge_amount();
  static const int kChargeAmountFieldNumber = 2;
  inline float charge_amount() const;
  inline void set_charge_amount(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.charge_info)
 private:
  inline void set_has_city_name();
  inline void clear_has_city_name();
  inline void set_has_charge_amount();
  inline void clear_has_charge_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_name_;
  float charge_amount_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static charge_info* default_instance_;
};
// -------------------------------------------------------------------

class real_fund_detail : public ::google::protobuf::Message {
 public:
  real_fund_detail();
  virtual ~real_fund_detail();

  real_fund_detail(const real_fund_detail& from);

  inline real_fund_detail& operator=(const real_fund_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const real_fund_detail& default_instance();

  void Swap(real_fund_detail* other);

  // implements Message ----------------------------------------------

  real_fund_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const real_fund_detail& from);
  void MergeFrom(const real_fund_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes fund_serial_number = 1;
  inline bool has_fund_serial_number() const;
  inline void clear_fund_serial_number();
  static const int kFundSerialNumberFieldNumber = 1;
  inline const ::std::string& fund_serial_number() const;
  inline void set_fund_serial_number(const ::std::string& value);
  inline void set_fund_serial_number(const char* value);
  inline void set_fund_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_fund_serial_number();
  inline ::std::string* release_fund_serial_number();
  inline void set_allocated_fund_serial_number(::std::string* fund_serial_number);

  // optional bytes fund_serial_name = 2;
  inline bool has_fund_serial_name() const;
  inline void clear_fund_serial_name();
  static const int kFundSerialNameFieldNumber = 2;
  inline const ::std::string& fund_serial_name() const;
  inline void set_fund_serial_name(const ::std::string& value);
  inline void set_fund_serial_name(const char* value);
  inline void set_fund_serial_name(const void* value, size_t size);
  inline ::std::string* mutable_fund_serial_name();
  inline ::std::string* release_fund_serial_name();
  inline void set_allocated_fund_serial_name(::std::string* fund_serial_name);

  // optional bytes user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes telno = 4;
  inline bool has_telno() const;
  inline void clear_telno();
  static const int kTelnoFieldNumber = 4;
  inline const ::std::string& telno() const;
  inline void set_telno(const ::std::string& value);
  inline void set_telno(const char* value);
  inline void set_telno(const void* value, size_t size);
  inline ::std::string* mutable_telno();
  inline ::std::string* release_telno();
  inline void set_allocated_telno(::std::string* telno);

  // optional bytes to_user_name = 5;
  inline bool has_to_user_name() const;
  inline void clear_to_user_name();
  static const int kToUserNameFieldNumber = 5;
  inline const ::std::string& to_user_name() const;
  inline void set_to_user_name(const ::std::string& value);
  inline void set_to_user_name(const char* value);
  inline void set_to_user_name(const void* value, size_t size);
  inline ::std::string* mutable_to_user_name();
  inline ::std::string* release_to_user_name();
  inline void set_allocated_to_user_name(::std::string* to_user_name);

  // optional bytes fund_serial_type = 6;
  inline bool has_fund_serial_type() const;
  inline void clear_fund_serial_type();
  static const int kFundSerialTypeFieldNumber = 6;
  inline const ::std::string& fund_serial_type() const;
  inline void set_fund_serial_type(const ::std::string& value);
  inline void set_fund_serial_type(const char* value);
  inline void set_fund_serial_type(const void* value, size_t size);
  inline ::std::string* mutable_fund_serial_type();
  inline ::std::string* release_fund_serial_type();
  inline void set_allocated_fund_serial_type(::std::string* fund_serial_type);

  // optional bytes fund_amount = 7;
  inline bool has_fund_amount() const;
  inline void clear_fund_amount();
  static const int kFundAmountFieldNumber = 7;
  inline const ::std::string& fund_amount() const;
  inline void set_fund_amount(const ::std::string& value);
  inline void set_fund_amount(const char* value);
  inline void set_fund_amount(const void* value, size_t size);
  inline ::std::string* mutable_fund_amount();
  inline ::std::string* release_fund_amount();
  inline void set_allocated_fund_amount(::std::string* fund_amount);

  // optional bytes fund_status = 8;
  inline bool has_fund_status() const;
  inline void clear_fund_status();
  static const int kFundStatusFieldNumber = 8;
  inline const ::std::string& fund_status() const;
  inline void set_fund_status(const ::std::string& value);
  inline void set_fund_status(const char* value);
  inline void set_fund_status(const void* value, size_t size);
  inline ::std::string* mutable_fund_status();
  inline ::std::string* release_fund_status();
  inline void set_allocated_fund_status(::std::string* fund_status);

  // optional bytes fund_desc = 9;
  inline bool has_fund_desc() const;
  inline void clear_fund_desc();
  static const int kFundDescFieldNumber = 9;
  inline const ::std::string& fund_desc() const;
  inline void set_fund_desc(const ::std::string& value);
  inline void set_fund_desc(const char* value);
  inline void set_fund_desc(const void* value, size_t size);
  inline ::std::string* mutable_fund_desc();
  inline ::std::string* release_fund_desc();
  inline void set_allocated_fund_desc(::std::string* fund_desc);

  // optional bytes update_time = 10;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 10;
  inline const ::std::string& update_time() const;
  inline void set_update_time(const ::std::string& value);
  inline void set_update_time(const char* value);
  inline void set_update_time(const void* value, size_t size);
  inline ::std::string* mutable_update_time();
  inline ::std::string* release_update_time();
  inline void set_allocated_update_time(::std::string* update_time);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.real_fund_detail)
 private:
  inline void set_has_fund_serial_number();
  inline void clear_has_fund_serial_number();
  inline void set_has_fund_serial_name();
  inline void clear_has_fund_serial_name();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_telno();
  inline void clear_has_telno();
  inline void set_has_to_user_name();
  inline void clear_has_to_user_name();
  inline void set_has_fund_serial_type();
  inline void clear_has_fund_serial_type();
  inline void set_has_fund_amount();
  inline void clear_has_fund_amount();
  inline void set_has_fund_status();
  inline void clear_has_fund_status();
  inline void set_has_fund_desc();
  inline void clear_has_fund_desc();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fund_serial_number_;
  ::std::string* fund_serial_name_;
  ::std::string* user_name_;
  ::std::string* telno_;
  ::std::string* to_user_name_;
  ::std::string* fund_serial_type_;
  ::std::string* fund_amount_;
  ::std::string* fund_status_;
  ::std::string* fund_desc_;
  ::std::string* update_time_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static real_fund_detail* default_instance_;
};
// -------------------------------------------------------------------

class fund_flow_type : public ::google::protobuf::Message {
 public:
  fund_flow_type();
  virtual ~fund_flow_type();

  fund_flow_type(const fund_flow_type& from);

  inline fund_flow_type& operator=(const fund_flow_type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fund_flow_type& default_instance();

  void Swap(fund_flow_type* other);

  // implements Message ----------------------------------------------

  fund_flow_type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fund_flow_type& from);
  void MergeFrom(const fund_flow_type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes type_id = 1;
  inline bool has_type_id() const;
  inline void clear_type_id();
  static const int kTypeIdFieldNumber = 1;
  inline const ::std::string& type_id() const;
  inline void set_type_id(const ::std::string& value);
  inline void set_type_id(const char* value);
  inline void set_type_id(const void* value, size_t size);
  inline ::std::string* mutable_type_id();
  inline ::std::string* release_type_id();
  inline void set_allocated_type_id(::std::string* type_id);

  // optional bytes title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const void* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.fund_flow_type)
 private:
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_id_;
  ::std::string* title_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static fund_flow_type* default_instance_;
};
// -------------------------------------------------------------------

class user_acount_info : public ::google::protobuf::Message {
 public:
  user_acount_info();
  virtual ~user_acount_info();

  user_acount_info(const user_acount_info& from);

  inline user_acount_info& operator=(const user_acount_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_acount_info& default_instance();

  void Swap(user_acount_info* other);

  // implements Message ----------------------------------------------

  user_acount_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_acount_info& from);
  void MergeFrom(const user_acount_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_acount = 1;
  inline bool has_user_acount() const;
  inline void clear_user_acount();
  static const int kUserAcountFieldNumber = 1;
  inline ::google::protobuf::int32 user_acount() const;
  inline void set_user_acount(::google::protobuf::int32 value);

  // optional bytes date_tick = 2;
  inline bool has_date_tick() const;
  inline void clear_date_tick();
  static const int kDateTickFieldNumber = 2;
  inline const ::std::string& date_tick() const;
  inline void set_date_tick(const ::std::string& value);
  inline void set_date_tick(const char* value);
  inline void set_date_tick(const void* value, size_t size);
  inline ::std::string* mutable_date_tick();
  inline ::std::string* release_date_tick();
  inline void set_allocated_date_tick(::std::string* date_tick);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_acount_info)
 private:
  inline void set_has_user_acount();
  inline void clear_has_user_acount();
  inline void set_has_date_tick();
  inline void clear_has_date_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* date_tick_;
  ::google::protobuf::int32 user_acount_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_acount_info* default_instance_;
};
// -------------------------------------------------------------------

class top_ten_user_acount_info : public ::google::protobuf::Message {
 public:
  top_ten_user_acount_info();
  virtual ~top_ten_user_acount_info();

  top_ten_user_acount_info(const top_ten_user_acount_info& from);

  inline top_ten_user_acount_info& operator=(const top_ten_user_acount_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const top_ten_user_acount_info& default_instance();

  void Swap(top_ten_user_acount_info* other);

  // implements Message ----------------------------------------------

  top_ten_user_acount_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const top_ten_user_acount_info& from);
  void MergeFrom(const top_ten_user_acount_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes app_version = 1;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 1;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const void* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // repeated .ODP_main_frame.user_acount_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::user_acount_info& info(int index) const;
  inline ::ODP_main_frame::user_acount_info* mutable_info(int index);
  inline ::ODP_main_frame::user_acount_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:ODP_main_frame.top_ten_user_acount_info)
 private:
  inline void set_has_app_version();
  inline void clear_has_app_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* app_version_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info > info_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static top_ten_user_acount_info* default_instance_;
};
// -------------------------------------------------------------------

class start_count_info : public ::google::protobuf::Message {
 public:
  start_count_info();
  virtual ~start_count_info();

  start_count_info(const start_count_info& from);

  inline start_count_info& operator=(const start_count_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_count_info& default_instance();

  void Swap(start_count_info* other);

  // implements Message ----------------------------------------------

  start_count_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_count_info& from);
  void MergeFrom(const start_count_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start_count = 1;
  inline bool has_start_count() const;
  inline void clear_start_count();
  static const int kStartCountFieldNumber = 1;
  inline ::google::protobuf::int32 start_count() const;
  inline void set_start_count(::google::protobuf::int32 value);

  // optional float start_count_rate = 2;
  inline bool has_start_count_rate() const;
  inline void clear_start_count_rate();
  static const int kStartCountRateFieldNumber = 2;
  inline float start_count_rate() const;
  inline void set_start_count_rate(float value);

  // optional bytes date_tick = 3;
  inline bool has_date_tick() const;
  inline void clear_date_tick();
  static const int kDateTickFieldNumber = 3;
  inline const ::std::string& date_tick() const;
  inline void set_date_tick(const ::std::string& value);
  inline void set_date_tick(const char* value);
  inline void set_date_tick(const void* value, size_t size);
  inline ::std::string* mutable_date_tick();
  inline ::std::string* release_date_tick();
  inline void set_allocated_date_tick(::std::string* date_tick);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.start_count_info)
 private:
  inline void set_has_start_count();
  inline void clear_has_start_count();
  inline void set_has_start_count_rate();
  inline void clear_has_start_count_rate();
  inline void set_has_date_tick();
  inline void clear_has_date_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 start_count_;
  float start_count_rate_;
  ::std::string* date_tick_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static start_count_info* default_instance_;
};
// -------------------------------------------------------------------

class user_analyze_info : public ::google::protobuf::Message {
 public:
  user_analyze_info();
  virtual ~user_analyze_info();

  user_analyze_info(const user_analyze_info& from);

  inline user_analyze_info& operator=(const user_analyze_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_analyze_info& default_instance();

  void Swap(user_analyze_info* other);

  // implements Message ----------------------------------------------

  user_analyze_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_analyze_info& from);
  void MergeFrom(const user_analyze_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_count = 1;
  inline bool has_user_count() const;
  inline void clear_user_count();
  static const int kUserCountFieldNumber = 1;
  inline ::google::protobuf::int32 user_count() const;
  inline void set_user_count(::google::protobuf::int32 value);

  // optional float user_count_rate = 2;
  inline bool has_user_count_rate() const;
  inline void clear_user_count_rate();
  static const int kUserCountRateFieldNumber = 2;
  inline float user_count_rate() const;
  inline void set_user_count_rate(float value);

  // optional bytes date_tick = 3;
  inline bool has_date_tick() const;
  inline void clear_date_tick();
  static const int kDateTickFieldNumber = 3;
  inline const ::std::string& date_tick() const;
  inline void set_date_tick(const ::std::string& value);
  inline void set_date_tick(const char* value);
  inline void set_date_tick(const void* value, size_t size);
  inline ::std::string* mutable_date_tick();
  inline ::std::string* release_date_tick();
  inline void set_allocated_date_tick(::std::string* date_tick);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_analyze_info)
 private:
  inline void set_has_user_count();
  inline void clear_has_user_count();
  inline void set_has_user_count_rate();
  inline void clear_has_user_count_rate();
  inline void set_has_date_tick();
  inline void clear_has_date_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 user_count_;
  float user_count_rate_;
  ::std::string* date_tick_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_analyze_info* default_instance_;
};
// -------------------------------------------------------------------

class user_freshness_info : public ::google::protobuf::Message {
 public:
  user_freshness_info();
  virtual ~user_freshness_info();

  user_freshness_info(const user_freshness_info& from);

  inline user_freshness_info& operator=(const user_freshness_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_freshness_info& default_instance();

  void Swap(user_freshness_info* other);

  // implements Message ----------------------------------------------

  user_freshness_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_freshness_info& from);
  void MergeFrom(const user_freshness_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 new_add_user_count = 1;
  inline bool has_new_add_user_count() const;
  inline void clear_new_add_user_count();
  static const int kNewAddUserCountFieldNumber = 1;
  inline ::google::protobuf::int32 new_add_user_count() const;
  inline void set_new_add_user_count(::google::protobuf::int32 value);

  // optional int32 active_user_count = 2;
  inline bool has_active_user_count() const;
  inline void clear_active_user_count();
  static const int kActiveUserCountFieldNumber = 2;
  inline ::google::protobuf::int32 active_user_count() const;
  inline void set_active_user_count(::google::protobuf::int32 value);

  // optional float new_add_count_rate = 3;
  inline bool has_new_add_count_rate() const;
  inline void clear_new_add_count_rate();
  static const int kNewAddCountRateFieldNumber = 3;
  inline float new_add_count_rate() const;
  inline void set_new_add_count_rate(float value);

  // optional bytes date_tick = 4;
  inline bool has_date_tick() const;
  inline void clear_date_tick();
  static const int kDateTickFieldNumber = 4;
  inline const ::std::string& date_tick() const;
  inline void set_date_tick(const ::std::string& value);
  inline void set_date_tick(const char* value);
  inline void set_date_tick(const void* value, size_t size);
  inline ::std::string* mutable_date_tick();
  inline ::std::string* release_date_tick();
  inline void set_allocated_date_tick(::std::string* date_tick);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_freshness_info)
 private:
  inline void set_has_new_add_user_count();
  inline void clear_has_new_add_user_count();
  inline void set_has_active_user_count();
  inline void clear_has_active_user_count();
  inline void set_has_new_add_count_rate();
  inline void clear_has_new_add_count_rate();
  inline void set_has_date_tick();
  inline void clear_has_date_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 new_add_user_count_;
  ::google::protobuf::int32 active_user_count_;
  ::std::string* date_tick_;
  float new_add_count_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_freshness_info* default_instance_;
};
// -------------------------------------------------------------------

class user_retain_rate_info : public ::google::protobuf::Message {
 public:
  user_retain_rate_info();
  virtual ~user_retain_rate_info();

  user_retain_rate_info(const user_retain_rate_info& from);

  inline user_retain_rate_info& operator=(const user_retain_rate_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_retain_rate_info& default_instance();

  void Swap(user_retain_rate_info* other);

  // implements Message ----------------------------------------------

  user_retain_rate_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_retain_rate_info& from);
  void MergeFrom(const user_retain_rate_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float oneday = 1;
  inline bool has_oneday() const;
  inline void clear_oneday();
  static const int kOnedayFieldNumber = 1;
  inline float oneday() const;
  inline void set_oneday(float value);

  // optional float twoday = 2;
  inline bool has_twoday() const;
  inline void clear_twoday();
  static const int kTwodayFieldNumber = 2;
  inline float twoday() const;
  inline void set_twoday(float value);

  // optional float threeday = 3;
  inline bool has_threeday() const;
  inline void clear_threeday();
  static const int kThreedayFieldNumber = 3;
  inline float threeday() const;
  inline void set_threeday(float value);

  // optional float fourday = 4;
  inline bool has_fourday() const;
  inline void clear_fourday();
  static const int kFourdayFieldNumber = 4;
  inline float fourday() const;
  inline void set_fourday(float value);

  // optional float fiveday = 5;
  inline bool has_fiveday() const;
  inline void clear_fiveday();
  static const int kFivedayFieldNumber = 5;
  inline float fiveday() const;
  inline void set_fiveday(float value);

  // optional float sixday = 6;
  inline bool has_sixday() const;
  inline void clear_sixday();
  static const int kSixdayFieldNumber = 6;
  inline float sixday() const;
  inline void set_sixday(float value);

  // optional float sevenday = 7;
  inline bool has_sevenday() const;
  inline void clear_sevenday();
  static const int kSevendayFieldNumber = 7;
  inline float sevenday() const;
  inline void set_sevenday(float value);

  // optional float fourteenday = 14;
  inline bool has_fourteenday() const;
  inline void clear_fourteenday();
  static const int kFourteendayFieldNumber = 14;
  inline float fourteenday() const;
  inline void set_fourteenday(float value);

  // optional float thirtyday = 30;
  inline bool has_thirtyday() const;
  inline void clear_thirtyday();
  static const int kThirtydayFieldNumber = 30;
  inline float thirtyday() const;
  inline void set_thirtyday(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_retain_rate_info)
 private:
  inline void set_has_oneday();
  inline void clear_has_oneday();
  inline void set_has_twoday();
  inline void clear_has_twoday();
  inline void set_has_threeday();
  inline void clear_has_threeday();
  inline void set_has_fourday();
  inline void clear_has_fourday();
  inline void set_has_fiveday();
  inline void clear_has_fiveday();
  inline void set_has_sixday();
  inline void clear_has_sixday();
  inline void set_has_sevenday();
  inline void clear_has_sevenday();
  inline void set_has_fourteenday();
  inline void clear_has_fourteenday();
  inline void set_has_thirtyday();
  inline void clear_has_thirtyday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float oneday_;
  float twoday_;
  float threeday_;
  float fourday_;
  float fiveday_;
  float sixday_;
  float sevenday_;
  float fourteenday_;
  float thirtyday_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_retain_rate_info* default_instance_;
};
// -------------------------------------------------------------------

class user_retain_info : public ::google::protobuf::Message {
 public:
  user_retain_info();
  virtual ~user_retain_info();

  user_retain_info(const user_retain_info& from);

  inline user_retain_info& operator=(const user_retain_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_retain_info& default_instance();

  void Swap(user_retain_info* other);

  // implements Message ----------------------------------------------

  user_retain_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_retain_info& from);
  void MergeFrom(const user_retain_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 new_add_user = 1;
  inline bool has_new_add_user() const;
  inline void clear_new_add_user();
  static const int kNewAddUserFieldNumber = 1;
  inline ::google::protobuf::int32 new_add_user() const;
  inline void set_new_add_user(::google::protobuf::int32 value);

  // optional .ODP_main_frame.user_retain_rate_info user_retain_rate = 2;
  inline bool has_user_retain_rate() const;
  inline void clear_user_retain_rate();
  static const int kUserRetainRateFieldNumber = 2;
  inline const ::ODP_main_frame::user_retain_rate_info& user_retain_rate() const;
  inline ::ODP_main_frame::user_retain_rate_info* mutable_user_retain_rate();
  inline ::ODP_main_frame::user_retain_rate_info* release_user_retain_rate();
  inline void set_allocated_user_retain_rate(::ODP_main_frame::user_retain_rate_info* user_retain_rate);

  // optional bytes first_use_date = 3;
  inline bool has_first_use_date() const;
  inline void clear_first_use_date();
  static const int kFirstUseDateFieldNumber = 3;
  inline const ::std::string& first_use_date() const;
  inline void set_first_use_date(const ::std::string& value);
  inline void set_first_use_date(const char* value);
  inline void set_first_use_date(const void* value, size_t size);
  inline ::std::string* mutable_first_use_date();
  inline ::std::string* release_first_use_date();
  inline void set_allocated_first_use_date(::std::string* first_use_date);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_retain_info)
 private:
  inline void set_has_new_add_user();
  inline void clear_has_new_add_user();
  inline void set_has_user_retain_rate();
  inline void clear_has_user_retain_rate();
  inline void set_has_first_use_date();
  inline void clear_has_first_use_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ODP_main_frame::user_retain_rate_info* user_retain_rate_;
  ::std::string* first_use_date_;
  ::google::protobuf::int32 new_add_user_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_retain_info* default_instance_;
};
// -------------------------------------------------------------------

class app_version_statistics : public ::google::protobuf::Message {
 public:
  app_version_statistics();
  virtual ~app_version_statistics();

  app_version_statistics(const app_version_statistics& from);

  inline app_version_statistics& operator=(const app_version_statistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_version_statistics& default_instance();

  void Swap(app_version_statistics* other);

  // implements Message ----------------------------------------------

  app_version_statistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_version_statistics& from);
  void MergeFrom(const app_version_statistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes app_version = 1;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 1;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const void* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // optional int32 total_user_acount = 2;
  inline bool has_total_user_acount() const;
  inline void clear_total_user_acount();
  static const int kTotalUserAcountFieldNumber = 2;
  inline ::google::protobuf::int32 total_user_acount() const;
  inline void set_total_user_acount(::google::protobuf::int32 value);

  // optional float total_user_rate = 3;
  inline bool has_total_user_rate() const;
  inline void clear_total_user_rate();
  static const int kTotalUserRateFieldNumber = 3;
  inline float total_user_rate() const;
  inline void set_total_user_rate(float value);

  // optional int32 new_add_user_acount = 4;
  inline bool has_new_add_user_acount() const;
  inline void clear_new_add_user_acount();
  static const int kNewAddUserAcountFieldNumber = 4;
  inline ::google::protobuf::int32 new_add_user_acount() const;
  inline void set_new_add_user_acount(::google::protobuf::int32 value);

  // optional float new_add_user_rate = 5;
  inline bool has_new_add_user_rate() const;
  inline void clear_new_add_user_rate();
  static const int kNewAddUserRateFieldNumber = 5;
  inline float new_add_user_rate() const;
  inline void set_new_add_user_rate(float value);

  // optional int32 upgrade_user_acount = 6;
  inline bool has_upgrade_user_acount() const;
  inline void clear_upgrade_user_acount();
  static const int kUpgradeUserAcountFieldNumber = 6;
  inline ::google::protobuf::int32 upgrade_user_acount() const;
  inline void set_upgrade_user_acount(::google::protobuf::int32 value);

  // optional float upgrade_user_rate = 7;
  inline bool has_upgrade_user_rate() const;
  inline void clear_upgrade_user_rate();
  static const int kUpgradeUserRateFieldNumber = 7;
  inline float upgrade_user_rate() const;
  inline void set_upgrade_user_rate(float value);

  // optional int32 new_upgrade_user_acount = 8;
  inline bool has_new_upgrade_user_acount() const;
  inline void clear_new_upgrade_user_acount();
  static const int kNewUpgradeUserAcountFieldNumber = 8;
  inline ::google::protobuf::int32 new_upgrade_user_acount() const;
  inline void set_new_upgrade_user_acount(::google::protobuf::int32 value);

  // optional float new_upgrade_user_rate = 9;
  inline bool has_new_upgrade_user_rate() const;
  inline void clear_new_upgrade_user_rate();
  static const int kNewUpgradeUserRateFieldNumber = 9;
  inline float new_upgrade_user_rate() const;
  inline void set_new_upgrade_user_rate(float value);

  // optional int32 active_user_acount = 10;
  inline bool has_active_user_acount() const;
  inline void clear_active_user_acount();
  static const int kActiveUserAcountFieldNumber = 10;
  inline ::google::protobuf::int32 active_user_acount() const;
  inline void set_active_user_acount(::google::protobuf::int32 value);

  // optional float active_user_rate = 11;
  inline bool has_active_user_rate() const;
  inline void clear_active_user_rate();
  static const int kActiveUserRateFieldNumber = 11;
  inline float active_user_rate() const;
  inline void set_active_user_rate(float value);

  // optional int32 start_acount = 12;
  inline bool has_start_acount() const;
  inline void clear_start_acount();
  static const int kStartAcountFieldNumber = 12;
  inline ::google::protobuf::int32 start_acount() const;
  inline void set_start_acount(::google::protobuf::int32 value);

  // optional float start_acount_rate = 13;
  inline bool has_start_acount_rate() const;
  inline void clear_start_acount_rate();
  static const int kStartAcountRateFieldNumber = 13;
  inline float start_acount_rate() const;
  inline void set_start_acount_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.app_version_statistics)
 private:
  inline void set_has_app_version();
  inline void clear_has_app_version();
  inline void set_has_total_user_acount();
  inline void clear_has_total_user_acount();
  inline void set_has_total_user_rate();
  inline void clear_has_total_user_rate();
  inline void set_has_new_add_user_acount();
  inline void clear_has_new_add_user_acount();
  inline void set_has_new_add_user_rate();
  inline void clear_has_new_add_user_rate();
  inline void set_has_upgrade_user_acount();
  inline void clear_has_upgrade_user_acount();
  inline void set_has_upgrade_user_rate();
  inline void clear_has_upgrade_user_rate();
  inline void set_has_new_upgrade_user_acount();
  inline void clear_has_new_upgrade_user_acount();
  inline void set_has_new_upgrade_user_rate();
  inline void clear_has_new_upgrade_user_rate();
  inline void set_has_active_user_acount();
  inline void clear_has_active_user_acount();
  inline void set_has_active_user_rate();
  inline void clear_has_active_user_rate();
  inline void set_has_start_acount();
  inline void clear_has_start_acount();
  inline void set_has_start_acount_rate();
  inline void clear_has_start_acount_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* app_version_;
  ::google::protobuf::int32 total_user_acount_;
  float total_user_rate_;
  ::google::protobuf::int32 new_add_user_acount_;
  float new_add_user_rate_;
  ::google::protobuf::int32 upgrade_user_acount_;
  float upgrade_user_rate_;
  ::google::protobuf::int32 new_upgrade_user_acount_;
  float new_upgrade_user_rate_;
  ::google::protobuf::int32 active_user_acount_;
  float active_user_rate_;
  ::google::protobuf::int32 start_acount_;
  float start_acount_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static app_version_statistics* default_instance_;
};
// -------------------------------------------------------------------

class app_version_detail : public ::google::protobuf::Message {
 public:
  app_version_detail();
  virtual ~app_version_detail();

  app_version_detail(const app_version_detail& from);

  inline app_version_detail& operator=(const app_version_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const app_version_detail& default_instance();

  void Swap(app_version_detail* other);

  // implements Message ----------------------------------------------

  app_version_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const app_version_detail& from);
  void MergeFrom(const app_version_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes date_tick = 1;
  inline bool has_date_tick() const;
  inline void clear_date_tick();
  static const int kDateTickFieldNumber = 1;
  inline const ::std::string& date_tick() const;
  inline void set_date_tick(const ::std::string& value);
  inline void set_date_tick(const char* value);
  inline void set_date_tick(const void* value, size_t size);
  inline ::std::string* mutable_date_tick();
  inline ::std::string* release_date_tick();
  inline void set_allocated_date_tick(::std::string* date_tick);

  // optional int32 new_add_user_acount = 2;
  inline bool has_new_add_user_acount() const;
  inline void clear_new_add_user_acount();
  static const int kNewAddUserAcountFieldNumber = 2;
  inline ::google::protobuf::int32 new_add_user_acount() const;
  inline void set_new_add_user_acount(::google::protobuf::int32 value);

  // optional int32 upgrade_user_acount = 3;
  inline bool has_upgrade_user_acount() const;
  inline void clear_upgrade_user_acount();
  static const int kUpgradeUserAcountFieldNumber = 3;
  inline ::google::protobuf::int32 upgrade_user_acount() const;
  inline void set_upgrade_user_acount(::google::protobuf::int32 value);

  // optional int32 active_user_acount = 4;
  inline bool has_active_user_acount() const;
  inline void clear_active_user_acount();
  static const int kActiveUserAcountFieldNumber = 4;
  inline ::google::protobuf::int32 active_user_acount() const;
  inline void set_active_user_acount(::google::protobuf::int32 value);

  // optional int32 acumulate_user_acount = 5;
  inline bool has_acumulate_user_acount() const;
  inline void clear_acumulate_user_acount();
  static const int kAcumulateUserAcountFieldNumber = 5;
  inline ::google::protobuf::int32 acumulate_user_acount() const;
  inline void set_acumulate_user_acount(::google::protobuf::int32 value);

  // optional int32 start_acount = 6;
  inline bool has_start_acount() const;
  inline void clear_start_acount();
  static const int kStartAcountFieldNumber = 6;
  inline ::google::protobuf::int32 start_acount() const;
  inline void set_start_acount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.app_version_detail)
 private:
  inline void set_has_date_tick();
  inline void clear_has_date_tick();
  inline void set_has_new_add_user_acount();
  inline void clear_has_new_add_user_acount();
  inline void set_has_upgrade_user_acount();
  inline void clear_has_upgrade_user_acount();
  inline void set_has_active_user_acount();
  inline void clear_has_active_user_acount();
  inline void set_has_acumulate_user_acount();
  inline void clear_has_acumulate_user_acount();
  inline void set_has_start_acount();
  inline void clear_has_start_acount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* date_tick_;
  ::google::protobuf::int32 new_add_user_acount_;
  ::google::protobuf::int32 upgrade_user_acount_;
  ::google::protobuf::int32 active_user_acount_;
  ::google::protobuf::int32 acumulate_user_acount_;
  ::google::protobuf::int32 start_acount_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static app_version_detail* default_instance_;
};
// -------------------------------------------------------------------

class download_src_user_acount_info : public ::google::protobuf::Message {
 public:
  download_src_user_acount_info();
  virtual ~download_src_user_acount_info();

  download_src_user_acount_info(const download_src_user_acount_info& from);

  inline download_src_user_acount_info& operator=(const download_src_user_acount_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_user_acount_info& default_instance();

  void Swap(download_src_user_acount_info* other);

  // implements Message ----------------------------------------------

  download_src_user_acount_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_user_acount_info& from);
  void MergeFrom(const download_src_user_acount_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes src_name = 1;
  inline bool has_src_name() const;
  inline void clear_src_name();
  static const int kSrcNameFieldNumber = 1;
  inline const ::std::string& src_name() const;
  inline void set_src_name(const ::std::string& value);
  inline void set_src_name(const char* value);
  inline void set_src_name(const void* value, size_t size);
  inline ::std::string* mutable_src_name();
  inline ::std::string* release_src_name();
  inline void set_allocated_src_name(::std::string* src_name);

  // repeated .ODP_main_frame.user_acount_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::user_acount_info& info(int index) const;
  inline ::ODP_main_frame::user_acount_info* mutable_info(int index);
  inline ::ODP_main_frame::user_acount_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_user_acount_info)
 private:
  inline void set_has_src_name();
  inline void clear_has_src_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* src_name_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info > info_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_user_acount_info* default_instance_;
};
// -------------------------------------------------------------------

class download_src_detail : public ::google::protobuf::Message {
 public:
  download_src_detail();
  virtual ~download_src_detail();

  download_src_detail(const download_src_detail& from);

  inline download_src_detail& operator=(const download_src_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_detail& default_instance();

  void Swap(download_src_detail* other);

  // implements Message ----------------------------------------------

  download_src_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_detail& from);
  void MergeFrom(const download_src_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes src_name = 1;
  inline bool has_src_name() const;
  inline void clear_src_name();
  static const int kSrcNameFieldNumber = 1;
  inline const ::std::string& src_name() const;
  inline void set_src_name(const ::std::string& value);
  inline void set_src_name(const char* value);
  inline void set_src_name(const void* value, size_t size);
  inline ::std::string* mutable_src_name();
  inline ::std::string* release_src_name();
  inline void set_allocated_src_name(::std::string* src_name);

  // optional int32 new_add_user_acount = 2;
  inline bool has_new_add_user_acount() const;
  inline void clear_new_add_user_acount();
  static const int kNewAddUserAcountFieldNumber = 2;
  inline ::google::protobuf::int32 new_add_user_acount() const;
  inline void set_new_add_user_acount(::google::protobuf::int32 value);

  // optional float new_add_user_acount_rate = 3;
  inline bool has_new_add_user_acount_rate() const;
  inline void clear_new_add_user_acount_rate();
  static const int kNewAddUserAcountRateFieldNumber = 3;
  inline float new_add_user_acount_rate() const;
  inline void set_new_add_user_acount_rate(float value);

  // optional int32 active_user_acount = 4;
  inline bool has_active_user_acount() const;
  inline void clear_active_user_acount();
  static const int kActiveUserAcountFieldNumber = 4;
  inline ::google::protobuf::int32 active_user_acount() const;
  inline void set_active_user_acount(::google::protobuf::int32 value);

  // optional float active_user_acount_rate = 5;
  inline bool has_active_user_acount_rate() const;
  inline void clear_active_user_acount_rate();
  static const int kActiveUserAcountRateFieldNumber = 5;
  inline float active_user_acount_rate() const;
  inline void set_active_user_acount_rate(float value);

  // optional int32 total_user_acount = 6;
  inline bool has_total_user_acount() const;
  inline void clear_total_user_acount();
  static const int kTotalUserAcountFieldNumber = 6;
  inline ::google::protobuf::int32 total_user_acount() const;
  inline void set_total_user_acount(::google::protobuf::int32 value);

  // optional float total_user_acount_rate = 7;
  inline bool has_total_user_acount_rate() const;
  inline void clear_total_user_acount_rate();
  static const int kTotalUserAcountRateFieldNumber = 7;
  inline float total_user_acount_rate() const;
  inline void set_total_user_acount_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_detail)
 private:
  inline void set_has_src_name();
  inline void clear_has_src_name();
  inline void set_has_new_add_user_acount();
  inline void clear_has_new_add_user_acount();
  inline void set_has_new_add_user_acount_rate();
  inline void clear_has_new_add_user_acount_rate();
  inline void set_has_active_user_acount();
  inline void clear_has_active_user_acount();
  inline void set_has_active_user_acount_rate();
  inline void clear_has_active_user_acount_rate();
  inline void set_has_total_user_acount();
  inline void clear_has_total_user_acount();
  inline void set_has_total_user_acount_rate();
  inline void clear_has_total_user_acount_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* src_name_;
  ::google::protobuf::int32 new_add_user_acount_;
  float new_add_user_acount_rate_;
  ::google::protobuf::int32 active_user_acount_;
  float active_user_acount_rate_;
  ::google::protobuf::int32 total_user_acount_;
  float total_user_acount_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_detail* default_instance_;
};
// -------------------------------------------------------------------

class use_time_info : public ::google::protobuf::Message {
 public:
  use_time_info();
  virtual ~use_time_info();

  use_time_info(const use_time_info& from);

  inline use_time_info& operator=(const use_time_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_time_info& default_instance();

  void Swap(use_time_info* other);

  // implements Message ----------------------------------------------

  use_time_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_time_info& from);
  void MergeFrom(const use_time_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes time_tick = 1;
  inline bool has_time_tick() const;
  inline void clear_time_tick();
  static const int kTimeTickFieldNumber = 1;
  inline const ::std::string& time_tick() const;
  inline void set_time_tick(const ::std::string& value);
  inline void set_time_tick(const char* value);
  inline void set_time_tick(const void* value, size_t size);
  inline ::std::string* mutable_time_tick();
  inline ::std::string* release_time_tick();
  inline void set_allocated_time_tick(::std::string* time_tick);

  // optional int32 start_count = 2;
  inline bool has_start_count() const;
  inline void clear_start_count();
  static const int kStartCountFieldNumber = 2;
  inline ::google::protobuf::int32 start_count() const;
  inline void set_start_count(::google::protobuf::int32 value);

  // optional float start_rate = 3;
  inline bool has_start_rate() const;
  inline void clear_start_rate();
  static const int kStartRateFieldNumber = 3;
  inline float start_rate() const;
  inline void set_start_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_time_info)
 private:
  inline void set_has_time_tick();
  inline void clear_has_time_tick();
  inline void set_has_start_count();
  inline void clear_has_start_count();
  inline void set_has_start_rate();
  inline void clear_has_start_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_tick_;
  ::google::protobuf::int32 start_count_;
  float start_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_time_info* default_instance_;
};
// -------------------------------------------------------------------

class use_count_info : public ::google::protobuf::Message {
 public:
  use_count_info();
  virtual ~use_count_info();

  use_count_info(const use_count_info& from);

  inline use_count_info& operator=(const use_count_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_count_info& default_instance();

  void Swap(use_count_info* other);

  // implements Message ----------------------------------------------

  use_count_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_count_info& from);
  void MergeFrom(const use_count_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes count_tick = 1;
  inline bool has_count_tick() const;
  inline void clear_count_tick();
  static const int kCountTickFieldNumber = 1;
  inline const ::std::string& count_tick() const;
  inline void set_count_tick(const ::std::string& value);
  inline void set_count_tick(const char* value);
  inline void set_count_tick(const void* value, size_t size);
  inline ::std::string* mutable_count_tick();
  inline ::std::string* release_count_tick();
  inline void set_allocated_count_tick(::std::string* count_tick);

  // optional int32 user_count = 2;
  inline bool has_user_count() const;
  inline void clear_user_count();
  static const int kUserCountFieldNumber = 2;
  inline ::google::protobuf::int32 user_count() const;
  inline void set_user_count(::google::protobuf::int32 value);

  // optional float user_count_rate = 3;
  inline bool has_user_count_rate() const;
  inline void clear_user_count_rate();
  static const int kUserCountRateFieldNumber = 3;
  inline float user_count_rate() const;
  inline void set_user_count_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_count_info)
 private:
  inline void set_has_count_tick();
  inline void clear_has_count_tick();
  inline void set_has_user_count();
  inline void clear_has_user_count();
  inline void set_has_user_count_rate();
  inline void clear_has_user_count_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* count_tick_;
  ::google::protobuf::int32 user_count_;
  float user_count_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_count_info* default_instance_;
};
// -------------------------------------------------------------------

class use_interval_info : public ::google::protobuf::Message {
 public:
  use_interval_info();
  virtual ~use_interval_info();

  use_interval_info(const use_interval_info& from);

  inline use_interval_info& operator=(const use_interval_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_interval_info& default_instance();

  void Swap(use_interval_info* other);

  // implements Message ----------------------------------------------

  use_interval_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_interval_info& from);
  void MergeFrom(const use_interval_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes interval_tick = 1;
  inline bool has_interval_tick() const;
  inline void clear_interval_tick();
  static const int kIntervalTickFieldNumber = 1;
  inline const ::std::string& interval_tick() const;
  inline void set_interval_tick(const ::std::string& value);
  inline void set_interval_tick(const char* value);
  inline void set_interval_tick(const void* value, size_t size);
  inline ::std::string* mutable_interval_tick();
  inline ::std::string* release_interval_tick();
  inline void set_allocated_interval_tick(::std::string* interval_tick);

  // optional int32 start_count = 2;
  inline bool has_start_count() const;
  inline void clear_start_count();
  static const int kStartCountFieldNumber = 2;
  inline ::google::protobuf::int32 start_count() const;
  inline void set_start_count(::google::protobuf::int32 value);

  // optional float start_count_rate = 3;
  inline bool has_start_count_rate() const;
  inline void clear_start_count_rate();
  static const int kStartCountRateFieldNumber = 3;
  inline float start_count_rate() const;
  inline void set_start_count_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_interval_info)
 private:
  inline void set_has_interval_tick();
  inline void clear_has_interval_tick();
  inline void set_has_start_count();
  inline void clear_has_start_count();
  inline void set_has_start_count_rate();
  inline void clear_has_start_count_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* interval_tick_;
  ::google::protobuf::int32 start_count_;
  float start_count_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_interval_info* default_instance_;
};
// -------------------------------------------------------------------

class third_party_login_info : public ::google::protobuf::Message {
 public:
  third_party_login_info();
  virtual ~third_party_login_info();

  third_party_login_info(const third_party_login_info& from);

  inline third_party_login_info& operator=(const third_party_login_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const third_party_login_info& default_instance();

  void Swap(third_party_login_info* other);

  // implements Message ----------------------------------------------

  third_party_login_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const third_party_login_info& from);
  void MergeFrom(const third_party_login_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes platform_name = 1;
  inline bool has_platform_name() const;
  inline void clear_platform_name();
  static const int kPlatformNameFieldNumber = 1;
  inline const ::std::string& platform_name() const;
  inline void set_platform_name(const ::std::string& value);
  inline void set_platform_name(const char* value);
  inline void set_platform_name(const void* value, size_t size);
  inline ::std::string* mutable_platform_name();
  inline ::std::string* release_platform_name();
  inline void set_allocated_platform_name(::std::string* platform_name);

  // optional int32 new_add_user_count = 2;
  inline bool has_new_add_user_count() const;
  inline void clear_new_add_user_count();
  static const int kNewAddUserCountFieldNumber = 2;
  inline ::google::protobuf::int32 new_add_user_count() const;
  inline void set_new_add_user_count(::google::protobuf::int32 value);

  // optional float new_add_user_count_rate = 3;
  inline bool has_new_add_user_count_rate() const;
  inline void clear_new_add_user_count_rate();
  static const int kNewAddUserCountRateFieldNumber = 3;
  inline float new_add_user_count_rate() const;
  inline void set_new_add_user_count_rate(float value);

  // optional int32 total_user_count = 4;
  inline bool has_total_user_count() const;
  inline void clear_total_user_count();
  static const int kTotalUserCountFieldNumber = 4;
  inline ::google::protobuf::int32 total_user_count() const;
  inline void set_total_user_count(::google::protobuf::int32 value);

  // optional float total_user_count_rate = 5;
  inline bool has_total_user_count_rate() const;
  inline void clear_total_user_count_rate();
  static const int kTotalUserCountRateFieldNumber = 5;
  inline float total_user_count_rate() const;
  inline void set_total_user_count_rate(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.third_party_login_info)
 private:
  inline void set_has_platform_name();
  inline void clear_has_platform_name();
  inline void set_has_new_add_user_count();
  inline void clear_has_new_add_user_count();
  inline void set_has_new_add_user_count_rate();
  inline void clear_has_new_add_user_count_rate();
  inline void set_has_total_user_count();
  inline void clear_has_total_user_count();
  inline void set_has_total_user_count_rate();
  inline void clear_has_total_user_count_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* platform_name_;
  ::google::protobuf::int32 new_add_user_count_;
  float new_add_user_count_rate_;
  ::google::protobuf::int32 total_user_count_;
  float total_user_count_rate_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static third_party_login_info* default_instance_;
};
// -------------------------------------------------------------------

class Pay_Withdraw_ask : public ::google::protobuf::Message {
 public:
  Pay_Withdraw_ask();
  virtual ~Pay_Withdraw_ask();

  Pay_Withdraw_ask(const Pay_Withdraw_ask& from);

  inline Pay_Withdraw_ask& operator=(const Pay_Withdraw_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pay_Withdraw_ask& default_instance();

  void Swap(Pay_Withdraw_ask* other);

  // implements Message ----------------------------------------------

  Pay_Withdraw_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pay_Withdraw_ask& from);
  void MergeFrom(const Pay_Withdraw_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.Pay_Withdraw_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static Pay_Withdraw_ask* default_instance_;
};
// -------------------------------------------------------------------

class Pay_Withdraw_ans : public ::google::protobuf::Message {
 public:
  Pay_Withdraw_ans();
  virtual ~Pay_Withdraw_ans();

  Pay_Withdraw_ans(const Pay_Withdraw_ans& from);

  inline Pay_Withdraw_ans& operator=(const Pay_Withdraw_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pay_Withdraw_ans& default_instance();

  void Swap(Pay_Withdraw_ans* other);

  // implements Message ----------------------------------------------

  Pay_Withdraw_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pay_Withdraw_ans& from);
  void MergeFrom(const Pay_Withdraw_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.Pay_Withdraw cur_pay_withdraw = 1;
  inline int cur_pay_withdraw_size() const;
  inline void clear_cur_pay_withdraw();
  static const int kCurPayWithdrawFieldNumber = 1;
  inline const ::ODP_main_frame::Pay_Withdraw& cur_pay_withdraw(int index) const;
  inline ::ODP_main_frame::Pay_Withdraw* mutable_cur_pay_withdraw(int index);
  inline ::ODP_main_frame::Pay_Withdraw* add_cur_pay_withdraw();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::Pay_Withdraw >&
      cur_pay_withdraw() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::Pay_Withdraw >*
      mutable_cur_pay_withdraw();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.Pay_Withdraw_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::Pay_Withdraw > cur_pay_withdraw_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static Pay_Withdraw_ans* default_instance_;
};
// -------------------------------------------------------------------

class unfinished_bid_ask : public ::google::protobuf::Message {
 public:
  unfinished_bid_ask();
  virtual ~unfinished_bid_ask();

  unfinished_bid_ask(const unfinished_bid_ask& from);

  inline unfinished_bid_ask& operator=(const unfinished_bid_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unfinished_bid_ask& default_instance();

  void Swap(unfinished_bid_ask* other);

  // implements Message ----------------------------------------------

  unfinished_bid_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unfinished_bid_ask& from);
  void MergeFrom(const unfinished_bid_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline ::google::protobuf::int32 event() const;
  inline void set_event(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 2;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 2;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.unfinished_bid_ask)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 event_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static unfinished_bid_ask* default_instance_;
};
// -------------------------------------------------------------------

class unfinished_bid_ans : public ::google::protobuf::Message {
 public:
  unfinished_bid_ans();
  virtual ~unfinished_bid_ans();

  unfinished_bid_ans(const unfinished_bid_ans& from);

  inline unfinished_bid_ans& operator=(const unfinished_bid_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unfinished_bid_ans& default_instance();

  void Swap(unfinished_bid_ans* other);

  // implements Message ----------------------------------------------

  unfinished_bid_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unfinished_bid_ans& from);
  void MergeFrom(const unfinished_bid_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.unfinished_bid_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::unfinished_bid_info& info(int index) const;
  inline ::ODP_main_frame::unfinished_bid_info* mutable_info(int index);
  inline ::ODP_main_frame::unfinished_bid_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::unfinished_bid_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::unfinished_bid_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.unfinished_bid_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::unfinished_bid_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static unfinished_bid_ans* default_instance_;
};
// -------------------------------------------------------------------

class city_bid_count_ask : public ::google::protobuf::Message {
 public:
  city_bid_count_ask();
  virtual ~city_bid_count_ask();

  city_bid_count_ask(const city_bid_count_ask& from);

  inline city_bid_count_ask& operator=(const city_bid_count_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_bid_count_ask& default_instance();

  void Swap(city_bid_count_ask* other);

  // implements Message ----------------------------------------------

  city_bid_count_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_bid_count_ask& from);
  void MergeFrom(const city_bid_count_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bid_status = 1;
  inline bool has_bid_status() const;
  inline void clear_bid_status();
  static const int kBidStatusFieldNumber = 1;
  inline ::google::protobuf::int32 bid_status() const;
  inline void set_bid_status(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 2;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 2;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.city_bid_count_ask)
 private:
  inline void set_has_bid_status();
  inline void clear_has_bid_status();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 bid_status_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static city_bid_count_ask* default_instance_;
};
// -------------------------------------------------------------------

class city_bid_count_ans : public ::google::protobuf::Message {
 public:
  city_bid_count_ans();
  virtual ~city_bid_count_ans();

  city_bid_count_ans(const city_bid_count_ans& from);

  inline city_bid_count_ans& operator=(const city_bid_count_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_bid_count_ans& default_instance();

  void Swap(city_bid_count_ans* other);

  // implements Message ----------------------------------------------

  city_bid_count_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_bid_count_ans& from);
  void MergeFrom(const city_bid_count_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.city_bid_count count_info = 1;
  inline int count_info_size() const;
  inline void clear_count_info();
  static const int kCountInfoFieldNumber = 1;
  inline const ::ODP_main_frame::city_bid_count& count_info(int index) const;
  inline ::ODP_main_frame::city_bid_count* mutable_count_info(int index);
  inline ::ODP_main_frame::city_bid_count* add_count_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::city_bid_count >&
      count_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::city_bid_count >*
      mutable_count_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.city_bid_count_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::city_bid_count > count_info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static city_bid_count_ans* default_instance_;
};
// -------------------------------------------------------------------

class user_distribution_ask : public ::google::protobuf::Message {
 public:
  user_distribution_ask();
  virtual ~user_distribution_ask();

  user_distribution_ask(const user_distribution_ask& from);

  inline user_distribution_ask& operator=(const user_distribution_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_distribution_ask& default_instance();

  void Swap(user_distribution_ask* other);

  // implements Message ----------------------------------------------

  user_distribution_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_distribution_ask& from);
  void MergeFrom(const user_distribution_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_status = 1;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 1;
  inline ::google::protobuf::int32 user_status() const;
  inline void set_user_status(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 2;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 2;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_distribution_ask)
 private:
  inline void set_has_user_status();
  inline void clear_has_user_status();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 user_status_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_distribution_ask* default_instance_;
};
// -------------------------------------------------------------------

class user_distribution_ans : public ::google::protobuf::Message {
 public:
  user_distribution_ans();
  virtual ~user_distribution_ans();

  user_distribution_ans(const user_distribution_ans& from);

  inline user_distribution_ans& operator=(const user_distribution_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_distribution_ans& default_instance();

  void Swap(user_distribution_ans* other);

  // implements Message ----------------------------------------------

  user_distribution_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_distribution_ans& from);
  void MergeFrom(const user_distribution_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_distribution info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_distribution& info(int index) const;
  inline ::ODP_main_frame::user_distribution* mutable_info(int index);
  inline ::ODP_main_frame::user_distribution* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_distribution >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_distribution >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_distribution_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_distribution > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_distribution_ans* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_volume_ask : public ::google::protobuf::Message {
 public:
  cur_trading_volume_ask();
  virtual ~cur_trading_volume_ask();

  cur_trading_volume_ask(const cur_trading_volume_ask& from);

  inline cur_trading_volume_ask& operator=(const cur_trading_volume_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_volume_ask& default_instance();

  void Swap(cur_trading_volume_ask* other);

  // implements Message ----------------------------------------------

  cur_trading_volume_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_volume_ask& from);
  void MergeFrom(const cur_trading_volume_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_datetime = 1;
  inline bool has_start_datetime() const;
  inline void clear_start_datetime();
  static const int kStartDatetimeFieldNumber = 1;
  inline const ::std::string& start_datetime() const;
  inline void set_start_datetime(const ::std::string& value);
  inline void set_start_datetime(const char* value);
  inline void set_start_datetime(const void* value, size_t size);
  inline ::std::string* mutable_start_datetime();
  inline ::std::string* release_start_datetime();
  inline void set_allocated_start_datetime(::std::string* start_datetime);

  // optional bytes end_datetime = 2;
  inline bool has_end_datetime() const;
  inline void clear_end_datetime();
  static const int kEndDatetimeFieldNumber = 2;
  inline const ::std::string& end_datetime() const;
  inline void set_end_datetime(const ::std::string& value);
  inline void set_end_datetime(const char* value);
  inline void set_end_datetime(const void* value, size_t size);
  inline ::std::string* mutable_end_datetime();
  inline ::std::string* release_end_datetime();
  inline void set_allocated_end_datetime(::std::string* end_datetime);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_volume_ask)
 private:
  inline void set_has_start_datetime();
  inline void clear_has_start_datetime();
  inline void set_has_end_datetime();
  inline void clear_has_end_datetime();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_datetime_;
  ::std::string* end_datetime_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_volume_ask* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_volume_ans : public ::google::protobuf::Message {
 public:
  cur_trading_volume_ans();
  virtual ~cur_trading_volume_ans();

  cur_trading_volume_ans(const cur_trading_volume_ans& from);

  inline cur_trading_volume_ans& operator=(const cur_trading_volume_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_volume_ans& default_instance();

  void Swap(cur_trading_volume_ans* other);

  // implements Message ----------------------------------------------

  cur_trading_volume_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_volume_ans& from);
  void MergeFrom(const cur_trading_volume_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.cur_trading_volume info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::cur_trading_volume& info(int index) const;
  inline ::ODP_main_frame::cur_trading_volume* mutable_info(int index);
  inline ::ODP_main_frame::cur_trading_volume* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_volume >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_volume >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_volume_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_volume > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_volume_ans* default_instance_;
};
// -------------------------------------------------------------------

class cur_province_trading_volume_ask : public ::google::protobuf::Message {
 public:
  cur_province_trading_volume_ask();
  virtual ~cur_province_trading_volume_ask();

  cur_province_trading_volume_ask(const cur_province_trading_volume_ask& from);

  inline cur_province_trading_volume_ask& operator=(const cur_province_trading_volume_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_province_trading_volume_ask& default_instance();

  void Swap(cur_province_trading_volume_ask* other);

  // implements Message ----------------------------------------------

  cur_province_trading_volume_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_province_trading_volume_ask& from);
  void MergeFrom(const cur_province_trading_volume_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_province_trading_volume_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_province_trading_volume_ask* default_instance_;
};
// -------------------------------------------------------------------

class cur_province_trading_volume_ans : public ::google::protobuf::Message {
 public:
  cur_province_trading_volume_ans();
  virtual ~cur_province_trading_volume_ans();

  cur_province_trading_volume_ans(const cur_province_trading_volume_ans& from);

  inline cur_province_trading_volume_ans& operator=(const cur_province_trading_volume_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_province_trading_volume_ans& default_instance();

  void Swap(cur_province_trading_volume_ans* other);

  // implements Message ----------------------------------------------

  cur_province_trading_volume_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_province_trading_volume_ans& from);
  void MergeFrom(const cur_province_trading_volume_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.cur_province_trading_volume info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::cur_province_trading_volume& info(int index) const;
  inline ::ODP_main_frame::cur_province_trading_volume* mutable_info(int index);
  inline ::ODP_main_frame::cur_province_trading_volume* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_province_trading_volume >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_province_trading_volume >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_province_trading_volume_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_province_trading_volume > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_province_trading_volume_ans* default_instance_;
};
// -------------------------------------------------------------------

class Real_time_registration_ask : public ::google::protobuf::Message {
 public:
  Real_time_registration_ask();
  virtual ~Real_time_registration_ask();

  Real_time_registration_ask(const Real_time_registration_ask& from);

  inline Real_time_registration_ask& operator=(const Real_time_registration_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Real_time_registration_ask& default_instance();

  void Swap(Real_time_registration_ask* other);

  // implements Message ----------------------------------------------

  Real_time_registration_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Real_time_registration_ask& from);
  void MergeFrom(const Real_time_registration_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.Real_time_registration_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static Real_time_registration_ask* default_instance_;
};
// -------------------------------------------------------------------

class Real_time_registration_ans : public ::google::protobuf::Message {
 public:
  Real_time_registration_ans();
  virtual ~Real_time_registration_ans();

  Real_time_registration_ans(const Real_time_registration_ans& from);

  inline Real_time_registration_ans& operator=(const Real_time_registration_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Real_time_registration_ans& default_instance();

  void Swap(Real_time_registration_ans* other);

  // implements Message ----------------------------------------------

  Real_time_registration_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Real_time_registration_ans& from);
  void MergeFrom(const Real_time_registration_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.registration_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::registration_info& info(int index) const;
  inline ::ODP_main_frame::registration_info* mutable_info(int index);
  inline ::ODP_main_frame::registration_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::registration_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::registration_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.Real_time_registration_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::registration_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static Real_time_registration_ans* default_instance_;
};
// -------------------------------------------------------------------

class month_registration_ask : public ::google::protobuf::Message {
 public:
  month_registration_ask();
  virtual ~month_registration_ask();

  month_registration_ask(const month_registration_ask& from);

  inline month_registration_ask& operator=(const month_registration_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_registration_ask& default_instance();

  void Swap(month_registration_ask* other);

  // implements Message ----------------------------------------------

  month_registration_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_registration_ask& from);
  void MergeFrom(const month_registration_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_registration_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_registration_ask* default_instance_;
};
// -------------------------------------------------------------------

class month_registration_ans : public ::google::protobuf::Message {
 public:
  month_registration_ans();
  virtual ~month_registration_ans();

  month_registration_ans(const month_registration_ans& from);

  inline month_registration_ans& operator=(const month_registration_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_registration_ans& default_instance();

  void Swap(month_registration_ans* other);

  // implements Message ----------------------------------------------

  month_registration_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_registration_ans& from);
  void MergeFrom(const month_registration_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.month_registration_volume info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::month_registration_volume& info(int index) const;
  inline ::ODP_main_frame::month_registration_volume* mutable_info(int index);
  inline ::ODP_main_frame::month_registration_volume* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_registration_volume >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_registration_volume >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_registration_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_registration_volume > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_registration_ans* default_instance_;
};
// -------------------------------------------------------------------

class real_time_charge_ask : public ::google::protobuf::Message {
 public:
  real_time_charge_ask();
  virtual ~real_time_charge_ask();

  real_time_charge_ask(const real_time_charge_ask& from);

  inline real_time_charge_ask& operator=(const real_time_charge_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const real_time_charge_ask& default_instance();

  void Swap(real_time_charge_ask* other);

  // implements Message ----------------------------------------------

  real_time_charge_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const real_time_charge_ask& from);
  void MergeFrom(const real_time_charge_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.real_time_charge_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static real_time_charge_ask* default_instance_;
};
// -------------------------------------------------------------------

class real_time_charge_ans : public ::google::protobuf::Message {
 public:
  real_time_charge_ans();
  virtual ~real_time_charge_ans();

  real_time_charge_ans(const real_time_charge_ans& from);

  inline real_time_charge_ans& operator=(const real_time_charge_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const real_time_charge_ans& default_instance();

  void Swap(real_time_charge_ans* other);

  // implements Message ----------------------------------------------

  real_time_charge_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const real_time_charge_ans& from);
  void MergeFrom(const real_time_charge_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.charge_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::charge_info& info(int index) const;
  inline ::ODP_main_frame::charge_info* mutable_info(int index);
  inline ::ODP_main_frame::charge_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::charge_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::charge_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.real_time_charge_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::charge_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static real_time_charge_ans* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_count_ask : public ::google::protobuf::Message {
 public:
  cur_trading_count_ask();
  virtual ~cur_trading_count_ask();

  cur_trading_count_ask(const cur_trading_count_ask& from);

  inline cur_trading_count_ask& operator=(const cur_trading_count_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_count_ask& default_instance();

  void Swap(cur_trading_count_ask* other);

  // implements Message ----------------------------------------------

  cur_trading_count_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_count_ask& from);
  void MergeFrom(const cur_trading_count_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_datetime = 1;
  inline bool has_start_datetime() const;
  inline void clear_start_datetime();
  static const int kStartDatetimeFieldNumber = 1;
  inline const ::std::string& start_datetime() const;
  inline void set_start_datetime(const ::std::string& value);
  inline void set_start_datetime(const char* value);
  inline void set_start_datetime(const void* value, size_t size);
  inline ::std::string* mutable_start_datetime();
  inline ::std::string* release_start_datetime();
  inline void set_allocated_start_datetime(::std::string* start_datetime);

  // optional bytes end_datetime = 2;
  inline bool has_end_datetime() const;
  inline void clear_end_datetime();
  static const int kEndDatetimeFieldNumber = 2;
  inline const ::std::string& end_datetime() const;
  inline void set_end_datetime(const ::std::string& value);
  inline void set_end_datetime(const char* value);
  inline void set_end_datetime(const void* value, size_t size);
  inline ::std::string* mutable_end_datetime();
  inline ::std::string* release_end_datetime();
  inline void set_allocated_end_datetime(::std::string* end_datetime);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_count_ask)
 private:
  inline void set_has_start_datetime();
  inline void clear_has_start_datetime();
  inline void set_has_end_datetime();
  inline void clear_has_end_datetime();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_datetime_;
  ::std::string* end_datetime_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_count_ask* default_instance_;
};
// -------------------------------------------------------------------

class cur_trading_count_ans : public ::google::protobuf::Message {
 public:
  cur_trading_count_ans();
  virtual ~cur_trading_count_ans();

  cur_trading_count_ans(const cur_trading_count_ans& from);

  inline cur_trading_count_ans& operator=(const cur_trading_count_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_trading_count_ans& default_instance();

  void Swap(cur_trading_count_ans* other);

  // implements Message ----------------------------------------------

  cur_trading_count_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_trading_count_ans& from);
  void MergeFrom(const cur_trading_count_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.cur_trading_count info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::cur_trading_count& info(int index) const;
  inline ::ODP_main_frame::cur_trading_count* mutable_info(int index);
  inline ::ODP_main_frame::cur_trading_count* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_count >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_count >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_trading_count_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_count > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_trading_count_ans* default_instance_;
};
// -------------------------------------------------------------------

class month_trading_ask : public ::google::protobuf::Message {
 public:
  month_trading_ask();
  virtual ~month_trading_ask();

  month_trading_ask(const month_trading_ask& from);

  inline month_trading_ask& operator=(const month_trading_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_trading_ask& default_instance();

  void Swap(month_trading_ask* other);

  // implements Message ----------------------------------------------

  month_trading_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_trading_ask& from);
  void MergeFrom(const month_trading_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_trading_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_trading_ask* default_instance_;
};
// -------------------------------------------------------------------

class month_trading_ans : public ::google::protobuf::Message {
 public:
  month_trading_ans();
  virtual ~month_trading_ans();

  month_trading_ans(const month_trading_ans& from);

  inline month_trading_ans& operator=(const month_trading_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_trading_ans& default_instance();

  void Swap(month_trading_ans* other);

  // implements Message ----------------------------------------------

  month_trading_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_trading_ans& from);
  void MergeFrom(const month_trading_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.month_trading_volume info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::month_trading_volume& info(int index) const;
  inline ::ODP_main_frame::month_trading_volume* mutable_info(int index);
  inline ::ODP_main_frame::month_trading_volume* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_trading_volume >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_trading_volume >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.month_trading_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_trading_volume > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static month_trading_ans* default_instance_;
};
// -------------------------------------------------------------------

class cur_fund_detail_ask : public ::google::protobuf::Message {
 public:
  cur_fund_detail_ask();
  virtual ~cur_fund_detail_ask();

  cur_fund_detail_ask(const cur_fund_detail_ask& from);

  inline cur_fund_detail_ask& operator=(const cur_fund_detail_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_fund_detail_ask& default_instance();

  void Swap(cur_fund_detail_ask* other);

  // implements Message ----------------------------------------------

  cur_fund_detail_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_fund_detail_ask& from);
  void MergeFrom(const cur_fund_detail_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_fund_detail_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_fund_detail_ask* default_instance_;
};
// -------------------------------------------------------------------

class cur_fund_detail_ans : public ::google::protobuf::Message {
 public:
  cur_fund_detail_ans();
  virtual ~cur_fund_detail_ans();

  cur_fund_detail_ans(const cur_fund_detail_ans& from);

  inline cur_fund_detail_ans& operator=(const cur_fund_detail_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_fund_detail_ans& default_instance();

  void Swap(cur_fund_detail_ans* other);

  // implements Message ----------------------------------------------

  cur_fund_detail_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_fund_detail_ans& from);
  void MergeFrom(const cur_fund_detail_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float cur_pay_amount = 1;
  inline bool has_cur_pay_amount() const;
  inline void clear_cur_pay_amount();
  static const int kCurPayAmountFieldNumber = 1;
  inline float cur_pay_amount() const;
  inline void set_cur_pay_amount(float value);

  // optional float cur_withdraw_amount = 2;
  inline bool has_cur_withdraw_amount() const;
  inline void clear_cur_withdraw_amount();
  static const int kCurWithdrawAmountFieldNumber = 2;
  inline float cur_withdraw_amount() const;
  inline void set_cur_withdraw_amount(float value);

  // optional float cur_invest_amount = 3;
  inline bool has_cur_invest_amount() const;
  inline void clear_cur_invest_amount();
  static const int kCurInvestAmountFieldNumber = 3;
  inline float cur_invest_amount() const;
  inline void set_cur_invest_amount(float value);

  // optional float cur_guarantee_amount = 4;
  inline bool has_cur_guarantee_amount() const;
  inline void clear_cur_guarantee_amount();
  static const int kCurGuaranteeAmountFieldNumber = 4;
  inline float cur_guarantee_amount() const;
  inline void set_cur_guarantee_amount(float value);

  // optional float cur_borrow_amount = 5;
  inline bool has_cur_borrow_amount() const;
  inline void clear_cur_borrow_amount();
  static const int kCurBorrowAmountFieldNumber = 5;
  inline float cur_borrow_amount() const;
  inline void set_cur_borrow_amount(float value);

  // optional float cur_repayment_amount = 6;
  inline bool has_cur_repayment_amount() const;
  inline void clear_cur_repayment_amount();
  static const int kCurRepaymentAmountFieldNumber = 6;
  inline float cur_repayment_amount() const;
  inline void set_cur_repayment_amount(float value);

  // optional float cur_overdue_amount = 7;
  inline bool has_cur_overdue_amount() const;
  inline void clear_cur_overdue_amount();
  static const int kCurOverdueAmountFieldNumber = 7;
  inline float cur_overdue_amount() const;
  inline void set_cur_overdue_amount(float value);

  // repeated .ODP_main_frame.real_fund_detail detail = 8;
  inline int detail_size() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 8;
  inline const ::ODP_main_frame::real_fund_detail& detail(int index) const;
  inline ::ODP_main_frame::real_fund_detail* mutable_detail(int index);
  inline ::ODP_main_frame::real_fund_detail* add_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >&
      detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >*
      mutable_detail();

  // optional .common.errorinfo error = 9;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.cur_fund_detail_ans)
 private:
  inline void set_has_cur_pay_amount();
  inline void clear_has_cur_pay_amount();
  inline void set_has_cur_withdraw_amount();
  inline void clear_has_cur_withdraw_amount();
  inline void set_has_cur_invest_amount();
  inline void clear_has_cur_invest_amount();
  inline void set_has_cur_guarantee_amount();
  inline void clear_has_cur_guarantee_amount();
  inline void set_has_cur_borrow_amount();
  inline void clear_has_cur_borrow_amount();
  inline void set_has_cur_repayment_amount();
  inline void clear_has_cur_repayment_amount();
  inline void set_has_cur_overdue_amount();
  inline void clear_has_cur_overdue_amount();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float cur_pay_amount_;
  float cur_withdraw_amount_;
  float cur_invest_amount_;
  float cur_guarantee_amount_;
  float cur_borrow_amount_;
  float cur_repayment_amount_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail > detail_;
  ::common::errorinfo* error_;
  float cur_overdue_amount_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static cur_fund_detail_ans* default_instance_;
};
// -------------------------------------------------------------------

class history_fund_detail_ask : public ::google::protobuf::Message {
 public:
  history_fund_detail_ask();
  virtual ~history_fund_detail_ask();

  history_fund_detail_ask(const history_fund_detail_ask& from);

  inline history_fund_detail_ask& operator=(const history_fund_detail_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const history_fund_detail_ask& default_instance();

  void Swap(history_fund_detail_ask* other);

  // implements Message ----------------------------------------------

  history_fund_detail_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const history_fund_detail_ask& from);
  void MergeFrom(const history_fund_detail_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes key_info = 3;
  inline bool has_key_info() const;
  inline void clear_key_info();
  static const int kKeyInfoFieldNumber = 3;
  inline const ::std::string& key_info() const;
  inline void set_key_info(const ::std::string& value);
  inline void set_key_info(const char* value);
  inline void set_key_info(const void* value, size_t size);
  inline ::std::string* mutable_key_info();
  inline ::std::string* release_key_info();
  inline void set_allocated_key_info(::std::string* key_info);

  // optional bytes flow_type = 4;
  inline bool has_flow_type() const;
  inline void clear_flow_type();
  static const int kFlowTypeFieldNumber = 4;
  inline const ::std::string& flow_type() const;
  inline void set_flow_type(const ::std::string& value);
  inline void set_flow_type(const char* value);
  inline void set_flow_type(const void* value, size_t size);
  inline ::std::string* mutable_flow_type();
  inline ::std::string* release_flow_type();
  inline void set_allocated_flow_type(::std::string* flow_type);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.history_fund_detail_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_key_info();
  inline void clear_has_key_info();
  inline void set_has_flow_type();
  inline void clear_has_flow_type();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* key_info_;
  ::std::string* flow_type_;
  ::google::protobuf::int32 page_num_;
  ::google::protobuf::int32 cur_page_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static history_fund_detail_ask* default_instance_;
};
// -------------------------------------------------------------------

class history_fund_detail_ans : public ::google::protobuf::Message {
 public:
  history_fund_detail_ans();
  virtual ~history_fund_detail_ans();

  history_fund_detail_ans(const history_fund_detail_ans& from);

  inline history_fund_detail_ans& operator=(const history_fund_detail_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const history_fund_detail_ans& default_instance();

  void Swap(history_fund_detail_ans* other);

  // implements Message ----------------------------------------------

  history_fund_detail_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const history_fund_detail_ans& from);
  void MergeFrom(const history_fund_detail_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.real_fund_detail detail = 2;
  inline int detail_size() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 2;
  inline const ::ODP_main_frame::real_fund_detail& detail(int index) const;
  inline ::ODP_main_frame::real_fund_detail* mutable_detail(int index);
  inline ::ODP_main_frame::real_fund_detail* add_detail();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >&
      detail() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >*
      mutable_detail();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.history_fund_detail_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail > detail_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static history_fund_detail_ans* default_instance_;
};
// -------------------------------------------------------------------

class history_fund_flow_type_ask : public ::google::protobuf::Message {
 public:
  history_fund_flow_type_ask();
  virtual ~history_fund_flow_type_ask();

  history_fund_flow_type_ask(const history_fund_flow_type_ask& from);

  inline history_fund_flow_type_ask& operator=(const history_fund_flow_type_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const history_fund_flow_type_ask& default_instance();

  void Swap(history_fund_flow_type_ask* other);

  // implements Message ----------------------------------------------

  history_fund_flow_type_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const history_fund_flow_type_ask& from);
  void MergeFrom(const history_fund_flow_type_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.history_fund_flow_type_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static history_fund_flow_type_ask* default_instance_;
};
// -------------------------------------------------------------------

class history_fund_flow_type_ans : public ::google::protobuf::Message {
 public:
  history_fund_flow_type_ans();
  virtual ~history_fund_flow_type_ans();

  history_fund_flow_type_ans(const history_fund_flow_type_ans& from);

  inline history_fund_flow_type_ans& operator=(const history_fund_flow_type_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const history_fund_flow_type_ans& default_instance();

  void Swap(history_fund_flow_type_ans* other);

  // implements Message ----------------------------------------------

  history_fund_flow_type_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const history_fund_flow_type_ans& from);
  void MergeFrom(const history_fund_flow_type_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.fund_flow_type fundtype = 1;
  inline int fundtype_size() const;
  inline void clear_fundtype();
  static const int kFundtypeFieldNumber = 1;
  inline const ::ODP_main_frame::fund_flow_type& fundtype(int index) const;
  inline ::ODP_main_frame::fund_flow_type* mutable_fundtype(int index);
  inline ::ODP_main_frame::fund_flow_type* add_fundtype();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::fund_flow_type >&
      fundtype() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::fund_flow_type >*
      mutable_fundtype();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.history_fund_flow_type_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::fund_flow_type > fundtype_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static history_fund_flow_type_ans* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_tendency_ask : public ::google::protobuf::Message {
 public:
  client_versions_tendency_ask();
  virtual ~client_versions_tendency_ask();

  client_versions_tendency_ask(const client_versions_tendency_ask& from);

  inline client_versions_tendency_ask& operator=(const client_versions_tendency_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_tendency_ask& default_instance();

  void Swap(client_versions_tendency_ask* other);

  // implements Message ----------------------------------------------

  client_versions_tendency_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_tendency_ask& from);
  void MergeFrom(const client_versions_tendency_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 os_type = 1;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 1;
  inline ::google::protobuf::int32 os_type() const;
  inline void set_os_type(::google::protobuf::int32 value);

  // optional bytes start_date = 2;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 2;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 3;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 3;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_tendency_ask)
 private:
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::google::protobuf::int32 os_type_;
  ::google::protobuf::int32 request_type_;
  ::std::string* end_date_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_tendency_ask* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_tendency_ans : public ::google::protobuf::Message {
 public:
  client_versions_tendency_ans();
  virtual ~client_versions_tendency_ans();

  client_versions_tendency_ans(const client_versions_tendency_ans& from);

  inline client_versions_tendency_ans& operator=(const client_versions_tendency_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_tendency_ans& default_instance();

  void Swap(client_versions_tendency_ans* other);

  // implements Message ----------------------------------------------

  client_versions_tendency_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_tendency_ans& from);
  void MergeFrom(const client_versions_tendency_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.top_ten_user_acount_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::top_ten_user_acount_info& info(int index) const;
  inline ::ODP_main_frame::top_ten_user_acount_info* mutable_info(int index);
  inline ::ODP_main_frame::top_ten_user_acount_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::top_ten_user_acount_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::top_ten_user_acount_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_tendency_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::top_ten_user_acount_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_tendency_ans* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_ask : public ::google::protobuf::Message {
 public:
  client_versions_distribution_ask();
  virtual ~client_versions_distribution_ask();

  client_versions_distribution_ask(const client_versions_distribution_ask& from);

  inline client_versions_distribution_ask& operator=(const client_versions_distribution_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_ask& default_instance();

  void Swap(client_versions_distribution_ask* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_ask& from);
  void MergeFrom(const client_versions_distribution_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 os_type = 1;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 1;
  inline ::google::protobuf::int32 os_type() const;
  inline void set_os_type(::google::protobuf::int32 value);

  // optional bytes start_date = 2;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 2;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 3;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 3;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional int32 page_num = 4;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 4;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 5;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 5;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 6;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 6;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_ask)
 private:
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::google::protobuf::int32 os_type_;
  ::google::protobuf::int32 page_num_;
  ::std::string* end_date_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 cur_page_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_ask* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_ans : public ::google::protobuf::Message {
 public:
  client_versions_distribution_ans();
  virtual ~client_versions_distribution_ans();

  client_versions_distribution_ans(const client_versions_distribution_ans& from);

  inline client_versions_distribution_ans& operator=(const client_versions_distribution_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_ans& default_instance();

  void Swap(client_versions_distribution_ans* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_ans& from);
  void MergeFrom(const client_versions_distribution_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.app_version_statistics info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::app_version_statistics& info(int index) const;
  inline ::ODP_main_frame::app_version_statistics* mutable_info(int index);
  inline ::ODP_main_frame::app_version_statistics* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_statistics >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_statistics >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_statistics > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_ans* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_detail_ask : public ::google::protobuf::Message {
 public:
  client_versions_distribution_detail_ask();
  virtual ~client_versions_distribution_detail_ask();

  client_versions_distribution_detail_ask(const client_versions_distribution_detail_ask& from);

  inline client_versions_distribution_detail_ask& operator=(const client_versions_distribution_detail_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_detail_ask& default_instance();

  void Swap(client_versions_distribution_detail_ask* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_detail_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_detail_ask& from);
  void MergeFrom(const client_versions_distribution_detail_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional bytes app_version = 4;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 4;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const void* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // optional int32 request_type = 5;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 5;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 6;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 6;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_detail_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_app_version();
  inline void clear_has_app_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::std::string* app_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_detail_ask* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_detail_ans : public ::google::protobuf::Message {
 public:
  client_versions_distribution_detail_ans();
  virtual ~client_versions_distribution_detail_ans();

  client_versions_distribution_detail_ans(const client_versions_distribution_detail_ans& from);

  inline client_versions_distribution_detail_ans& operator=(const client_versions_distribution_detail_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_detail_ans& default_instance();

  void Swap(client_versions_distribution_detail_ans* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_detail_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_detail_ans& from);
  void MergeFrom(const client_versions_distribution_detail_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_acount_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_acount_info& info(int index) const;
  inline ::ODP_main_frame::user_acount_info* mutable_info(int index);
  inline ::ODP_main_frame::user_acount_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_detail_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_detail_ans* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_detail_list_ask : public ::google::protobuf::Message {
 public:
  client_versions_distribution_detail_list_ask();
  virtual ~client_versions_distribution_detail_list_ask();

  client_versions_distribution_detail_list_ask(const client_versions_distribution_detail_list_ask& from);

  inline client_versions_distribution_detail_list_ask& operator=(const client_versions_distribution_detail_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_detail_list_ask& default_instance();

  void Swap(client_versions_distribution_detail_list_ask* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_detail_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_detail_list_ask& from);
  void MergeFrom(const client_versions_distribution_detail_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional bytes app_version = 4;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 4;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const void* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_detail_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_app_version();
  inline void clear_has_app_version();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::std::string* app_version_;
  ::google::protobuf::int32 page_num_;
  ::google::protobuf::int32 cur_page_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_detail_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class client_versions_distribution_detail_list_ans : public ::google::protobuf::Message {
 public:
  client_versions_distribution_detail_list_ans();
  virtual ~client_versions_distribution_detail_list_ans();

  client_versions_distribution_detail_list_ans(const client_versions_distribution_detail_list_ans& from);

  inline client_versions_distribution_detail_list_ans& operator=(const client_versions_distribution_detail_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_versions_distribution_detail_list_ans& default_instance();

  void Swap(client_versions_distribution_detail_list_ans* other);

  // implements Message ----------------------------------------------

  client_versions_distribution_detail_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_versions_distribution_detail_list_ans& from);
  void MergeFrom(const client_versions_distribution_detail_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.app_version_detail info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::app_version_detail& info(int index) const;
  inline ::ODP_main_frame::app_version_detail* mutable_info(int index);
  inline ::ODP_main_frame::app_version_detail* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_detail >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_detail >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.client_versions_distribution_detail_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_detail > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static client_versions_distribution_detail_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class start_count_analyze_ask : public ::google::protobuf::Message {
 public:
  start_count_analyze_ask();
  virtual ~start_count_analyze_ask();

  start_count_analyze_ask(const start_count_analyze_ask& from);

  inline start_count_analyze_ask& operator=(const start_count_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_count_analyze_ask& default_instance();

  void Swap(start_count_analyze_ask* other);

  // implements Message ----------------------------------------------

  start_count_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_count_analyze_ask& from);
  void MergeFrom(const start_count_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.start_count_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static start_count_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class start_count_analyze_ans : public ::google::protobuf::Message {
 public:
  start_count_analyze_ans();
  virtual ~start_count_analyze_ans();

  start_count_analyze_ans(const start_count_analyze_ans& from);

  inline start_count_analyze_ans& operator=(const start_count_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_count_analyze_ans& default_instance();

  void Swap(start_count_analyze_ans* other);

  // implements Message ----------------------------------------------

  start_count_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_count_analyze_ans& from);
  void MergeFrom(const start_count_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.start_count_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::start_count_info& info(int index) const;
  inline ::ODP_main_frame::start_count_info* mutable_info(int index);
  inline ::ODP_main_frame::start_count_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.start_count_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static start_count_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class start_count_analyze_list_ask : public ::google::protobuf::Message {
 public:
  start_count_analyze_list_ask();
  virtual ~start_count_analyze_list_ask();

  start_count_analyze_list_ask(const start_count_analyze_list_ask& from);

  inline start_count_analyze_list_ask& operator=(const start_count_analyze_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_count_analyze_list_ask& default_instance();

  void Swap(start_count_analyze_list_ask* other);

  // implements Message ----------------------------------------------

  start_count_analyze_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_count_analyze_list_ask& from);
  void MergeFrom(const start_count_analyze_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.start_count_analyze_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::int32 page_num_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 cur_page_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static start_count_analyze_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class start_count_analyze_list_ans : public ::google::protobuf::Message {
 public:
  start_count_analyze_list_ans();
  virtual ~start_count_analyze_list_ans();

  start_count_analyze_list_ans(const start_count_analyze_list_ans& from);

  inline start_count_analyze_list_ans& operator=(const start_count_analyze_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const start_count_analyze_list_ans& default_instance();

  void Swap(start_count_analyze_list_ans* other);

  // implements Message ----------------------------------------------

  start_count_analyze_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const start_count_analyze_list_ans& from);
  void MergeFrom(const start_count_analyze_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.start_count_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::start_count_info& info(int index) const;
  inline ::ODP_main_frame::start_count_info* mutable_info(int index);
  inline ::ODP_main_frame::start_count_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.start_count_analyze_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static start_count_analyze_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class new_add_user_analyze_ask : public ::google::protobuf::Message {
 public:
  new_add_user_analyze_ask();
  virtual ~new_add_user_analyze_ask();

  new_add_user_analyze_ask(const new_add_user_analyze_ask& from);

  inline new_add_user_analyze_ask& operator=(const new_add_user_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_add_user_analyze_ask& default_instance();

  void Swap(new_add_user_analyze_ask* other);

  // implements Message ----------------------------------------------

  new_add_user_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_add_user_analyze_ask& from);
  void MergeFrom(const new_add_user_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.new_add_user_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static new_add_user_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class new_add_user_analyze_ans : public ::google::protobuf::Message {
 public:
  new_add_user_analyze_ans();
  virtual ~new_add_user_analyze_ans();

  new_add_user_analyze_ans(const new_add_user_analyze_ans& from);

  inline new_add_user_analyze_ans& operator=(const new_add_user_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_add_user_analyze_ans& default_instance();

  void Swap(new_add_user_analyze_ans* other);

  // implements Message ----------------------------------------------

  new_add_user_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_add_user_analyze_ans& from);
  void MergeFrom(const new_add_user_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_analyze_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_analyze_info& info(int index) const;
  inline ::ODP_main_frame::user_analyze_info* mutable_info(int index);
  inline ::ODP_main_frame::user_analyze_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.new_add_user_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static new_add_user_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class new_add_user_analyze_list_ask : public ::google::protobuf::Message {
 public:
  new_add_user_analyze_list_ask();
  virtual ~new_add_user_analyze_list_ask();

  new_add_user_analyze_list_ask(const new_add_user_analyze_list_ask& from);

  inline new_add_user_analyze_list_ask& operator=(const new_add_user_analyze_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_add_user_analyze_list_ask& default_instance();

  void Swap(new_add_user_analyze_list_ask* other);

  // implements Message ----------------------------------------------

  new_add_user_analyze_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_add_user_analyze_list_ask& from);
  void MergeFrom(const new_add_user_analyze_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.new_add_user_analyze_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::int32 page_num_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 cur_page_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static new_add_user_analyze_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class new_add_user_analyze_list_ans : public ::google::protobuf::Message {
 public:
  new_add_user_analyze_list_ans();
  virtual ~new_add_user_analyze_list_ans();

  new_add_user_analyze_list_ans(const new_add_user_analyze_list_ans& from);

  inline new_add_user_analyze_list_ans& operator=(const new_add_user_analyze_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_add_user_analyze_list_ans& default_instance();

  void Swap(new_add_user_analyze_list_ans* other);

  // implements Message ----------------------------------------------

  new_add_user_analyze_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_add_user_analyze_list_ans& from);
  void MergeFrom(const new_add_user_analyze_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.user_analyze_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::user_analyze_info& info(int index) const;
  inline ::ODP_main_frame::user_analyze_info* mutable_info(int index);
  inline ::ODP_main_frame::user_analyze_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.new_add_user_analyze_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static new_add_user_analyze_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class active_user_analyze_ask : public ::google::protobuf::Message {
 public:
  active_user_analyze_ask();
  virtual ~active_user_analyze_ask();

  active_user_analyze_ask(const active_user_analyze_ask& from);

  inline active_user_analyze_ask& operator=(const active_user_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_user_analyze_ask& default_instance();

  void Swap(active_user_analyze_ask* other);

  // implements Message ----------------------------------------------

  active_user_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_user_analyze_ask& from);
  void MergeFrom(const active_user_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.active_user_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static active_user_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class active_user_analyze_ans : public ::google::protobuf::Message {
 public:
  active_user_analyze_ans();
  virtual ~active_user_analyze_ans();

  active_user_analyze_ans(const active_user_analyze_ans& from);

  inline active_user_analyze_ans& operator=(const active_user_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_user_analyze_ans& default_instance();

  void Swap(active_user_analyze_ans* other);

  // implements Message ----------------------------------------------

  active_user_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_user_analyze_ans& from);
  void MergeFrom(const active_user_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_analyze_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_analyze_info& info(int index) const;
  inline ::ODP_main_frame::user_analyze_info* mutable_info(int index);
  inline ::ODP_main_frame::user_analyze_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.active_user_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static active_user_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class active_user_analyze_list_ask : public ::google::protobuf::Message {
 public:
  active_user_analyze_list_ask();
  virtual ~active_user_analyze_list_ask();

  active_user_analyze_list_ask(const active_user_analyze_list_ask& from);

  inline active_user_analyze_list_ask& operator=(const active_user_analyze_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_user_analyze_list_ask& default_instance();

  void Swap(active_user_analyze_list_ask* other);

  // implements Message ----------------------------------------------

  active_user_analyze_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_user_analyze_list_ask& from);
  void MergeFrom(const active_user_analyze_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.active_user_analyze_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::int32 page_num_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 cur_page_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static active_user_analyze_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class active_user_analyze_list_ans : public ::google::protobuf::Message {
 public:
  active_user_analyze_list_ans();
  virtual ~active_user_analyze_list_ans();

  active_user_analyze_list_ans(const active_user_analyze_list_ans& from);

  inline active_user_analyze_list_ans& operator=(const active_user_analyze_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_user_analyze_list_ans& default_instance();

  void Swap(active_user_analyze_list_ans* other);

  // implements Message ----------------------------------------------

  active_user_analyze_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_user_analyze_list_ans& from);
  void MergeFrom(const active_user_analyze_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.user_analyze_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::user_analyze_info& info(int index) const;
  inline ::ODP_main_frame::user_analyze_info* mutable_info(int index);
  inline ::ODP_main_frame::user_analyze_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.active_user_analyze_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static active_user_analyze_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class user_freshness_analyze_ask : public ::google::protobuf::Message {
 public:
  user_freshness_analyze_ask();
  virtual ~user_freshness_analyze_ask();

  user_freshness_analyze_ask(const user_freshness_analyze_ask& from);

  inline user_freshness_analyze_ask& operator=(const user_freshness_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_freshness_analyze_ask& default_instance();

  void Swap(user_freshness_analyze_ask* other);

  // implements Message ----------------------------------------------

  user_freshness_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_freshness_analyze_ask& from);
  void MergeFrom(const user_freshness_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_freshness_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_freshness_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class user_freshness_analyze_ans : public ::google::protobuf::Message {
 public:
  user_freshness_analyze_ans();
  virtual ~user_freshness_analyze_ans();

  user_freshness_analyze_ans(const user_freshness_analyze_ans& from);

  inline user_freshness_analyze_ans& operator=(const user_freshness_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_freshness_analyze_ans& default_instance();

  void Swap(user_freshness_analyze_ans* other);

  // implements Message ----------------------------------------------

  user_freshness_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_freshness_analyze_ans& from);
  void MergeFrom(const user_freshness_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_freshness_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_freshness_info& info(int index) const;
  inline ::ODP_main_frame::user_freshness_info* mutable_info(int index);
  inline ::ODP_main_frame::user_freshness_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_freshness_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_freshness_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class user_freshness_analyze_list_ask : public ::google::protobuf::Message {
 public:
  user_freshness_analyze_list_ask();
  virtual ~user_freshness_analyze_list_ask();

  user_freshness_analyze_list_ask(const user_freshness_analyze_list_ask& from);

  inline user_freshness_analyze_list_ask& operator=(const user_freshness_analyze_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_freshness_analyze_list_ask& default_instance();

  void Swap(user_freshness_analyze_list_ask* other);

  // implements Message ----------------------------------------------

  user_freshness_analyze_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_freshness_analyze_list_ask& from);
  void MergeFrom(const user_freshness_analyze_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional int32 page_num = 5;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 5;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 6;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 6;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 7;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 7;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_freshness_analyze_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::int32 page_num_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 cur_page_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_freshness_analyze_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class user_freshness_analyze_list_ans : public ::google::protobuf::Message {
 public:
  user_freshness_analyze_list_ans();
  virtual ~user_freshness_analyze_list_ans();

  user_freshness_analyze_list_ans(const user_freshness_analyze_list_ans& from);

  inline user_freshness_analyze_list_ans& operator=(const user_freshness_analyze_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_freshness_analyze_list_ans& default_instance();

  void Swap(user_freshness_analyze_list_ans* other);

  // implements Message ----------------------------------------------

  user_freshness_analyze_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_freshness_analyze_list_ans& from);
  void MergeFrom(const user_freshness_analyze_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.user_freshness_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::user_freshness_info& info(int index) const;
  inline ::ODP_main_frame::user_freshness_info* mutable_info(int index);
  inline ::ODP_main_frame::user_freshness_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_freshness_analyze_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_freshness_analyze_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class user_retain_analyze_ask : public ::google::protobuf::Message {
 public:
  user_retain_analyze_ask();
  virtual ~user_retain_analyze_ask();

  user_retain_analyze_ask(const user_retain_analyze_ask& from);

  inline user_retain_analyze_ask& operator=(const user_retain_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_retain_analyze_ask& default_instance();

  void Swap(user_retain_analyze_ask* other);

  // implements Message ----------------------------------------------

  user_retain_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_retain_analyze_ask& from);
  void MergeFrom(const user_retain_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_retain_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_retain_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class user_retain_analyze_ans : public ::google::protobuf::Message {
 public:
  user_retain_analyze_ans();
  virtual ~user_retain_analyze_ans();

  user_retain_analyze_ans(const user_retain_analyze_ans& from);

  inline user_retain_analyze_ans& operator=(const user_retain_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_retain_analyze_ans& default_instance();

  void Swap(user_retain_analyze_ans* other);

  // implements Message ----------------------------------------------

  user_retain_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_retain_analyze_ans& from);
  void MergeFrom(const user_retain_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.user_retain_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::user_retain_info& info(int index) const;
  inline ::ODP_main_frame::user_retain_info* mutable_info(int index);
  inline ::ODP_main_frame::user_retain_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_retain_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_retain_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_retain_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_retain_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_retain_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class use_time_analyze_ask : public ::google::protobuf::Message {
 public:
  use_time_analyze_ask();
  virtual ~use_time_analyze_ask();

  use_time_analyze_ask(const use_time_analyze_ask& from);

  inline use_time_analyze_ask& operator=(const use_time_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_time_analyze_ask& default_instance();

  void Swap(use_time_analyze_ask* other);

  // implements Message ----------------------------------------------

  use_time_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_time_analyze_ask& from);
  void MergeFrom(const use_time_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes os_version = 2;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 3;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 3;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 4;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 4;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_time_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_time_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class use_time_analyze_ans : public ::google::protobuf::Message {
 public:
  use_time_analyze_ans();
  virtual ~use_time_analyze_ans();

  use_time_analyze_ans(const use_time_analyze_ans& from);

  inline use_time_analyze_ans& operator=(const use_time_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_time_analyze_ans& default_instance();

  void Swap(use_time_analyze_ans* other);

  // implements Message ----------------------------------------------

  use_time_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_time_analyze_ans& from);
  void MergeFrom(const use_time_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.use_time_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::use_time_info& info(int index) const;
  inline ::ODP_main_frame::use_time_info* mutable_info(int index);
  inline ::ODP_main_frame::use_time_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_time_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_time_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_time_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_time_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_time_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class use_count_analyze_ask : public ::google::protobuf::Message {
 public:
  use_count_analyze_ask();
  virtual ~use_count_analyze_ask();

  use_count_analyze_ask(const use_count_analyze_ask& from);

  inline use_count_analyze_ask& operator=(const use_count_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_count_analyze_ask& default_instance();

  void Swap(use_count_analyze_ask* other);

  // implements Message ----------------------------------------------

  use_count_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_count_analyze_ask& from);
  void MergeFrom(const use_count_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes os_version = 2;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 3;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 3;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 4;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 4;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_count_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_count_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class use_count_analyze_ans : public ::google::protobuf::Message {
 public:
  use_count_analyze_ans();
  virtual ~use_count_analyze_ans();

  use_count_analyze_ans(const use_count_analyze_ans& from);

  inline use_count_analyze_ans& operator=(const use_count_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_count_analyze_ans& default_instance();

  void Swap(use_count_analyze_ans* other);

  // implements Message ----------------------------------------------

  use_count_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_count_analyze_ans& from);
  void MergeFrom(const use_count_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.use_count_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::use_count_info& info(int index) const;
  inline ::ODP_main_frame::use_count_info* mutable_info(int index);
  inline ::ODP_main_frame::use_count_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_count_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_count_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_count_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_count_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_count_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class use_interval_analyze_ask : public ::google::protobuf::Message {
 public:
  use_interval_analyze_ask();
  virtual ~use_interval_analyze_ask();

  use_interval_analyze_ask(const use_interval_analyze_ask& from);

  inline use_interval_analyze_ask& operator=(const use_interval_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_interval_analyze_ask& default_instance();

  void Swap(use_interval_analyze_ask* other);

  // implements Message ----------------------------------------------

  use_interval_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_interval_analyze_ask& from);
  void MergeFrom(const use_interval_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes end_date = 1;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 1;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 2;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 2;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional .common.common_ask_header ask_header = 3;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 3;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_interval_analyze_ask)
 private:
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_interval_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class use_interval_analyze_ans : public ::google::protobuf::Message {
 public:
  use_interval_analyze_ans();
  virtual ~use_interval_analyze_ans();

  use_interval_analyze_ans(const use_interval_analyze_ans& from);

  inline use_interval_analyze_ans& operator=(const use_interval_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const use_interval_analyze_ans& default_instance();

  void Swap(use_interval_analyze_ans* other);

  // implements Message ----------------------------------------------

  use_interval_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const use_interval_analyze_ans& from);
  void MergeFrom(const use_interval_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.use_interval_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::use_interval_info& info(int index) const;
  inline ::ODP_main_frame::use_interval_info* mutable_info(int index);
  inline ::ODP_main_frame::use_interval_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_interval_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_interval_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.use_interval_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_interval_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static use_interval_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class download_src_analyze_ask : public ::google::protobuf::Message {
 public:
  download_src_analyze_ask();
  virtual ~download_src_analyze_ask();

  download_src_analyze_ask(const download_src_analyze_ask& from);

  inline download_src_analyze_ask& operator=(const download_src_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_analyze_ask& default_instance();

  void Swap(download_src_analyze_ask* other);

  // implements Message ----------------------------------------------

  download_src_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_analyze_ask& from);
  void MergeFrom(const download_src_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 request_type = 4;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 4;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 5;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 5;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  ::google::protobuf::int32 request_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class download_src_analyze_ans : public ::google::protobuf::Message {
 public:
  download_src_analyze_ans();
  virtual ~download_src_analyze_ans();

  download_src_analyze_ans(const download_src_analyze_ans& from);

  inline download_src_analyze_ans& operator=(const download_src_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_analyze_ans& default_instance();

  void Swap(download_src_analyze_ans* other);

  // implements Message ----------------------------------------------

  download_src_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_analyze_ans& from);
  void MergeFrom(const download_src_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.download_src_user_acount_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::download_src_user_acount_info& info(int index) const;
  inline ::ODP_main_frame::download_src_user_acount_info* mutable_info(int index);
  inline ::ODP_main_frame::download_src_user_acount_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_user_acount_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_user_acount_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_user_acount_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class download_src_analyze_detail_ask : public ::google::protobuf::Message {
 public:
  download_src_analyze_detail_ask();
  virtual ~download_src_analyze_detail_ask();

  download_src_analyze_detail_ask(const download_src_analyze_detail_ask& from);

  inline download_src_analyze_detail_ask& operator=(const download_src_analyze_detail_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_analyze_detail_ask& default_instance();

  void Swap(download_src_analyze_detail_ask* other);

  // implements Message ----------------------------------------------

  download_src_analyze_detail_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_analyze_detail_ask& from);
  void MergeFrom(const download_src_analyze_detail_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 page_num = 4;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 4;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 5;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 5;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 6;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 6;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_analyze_detail_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 page_num_;
  ::google::protobuf::int32 cur_page_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_analyze_detail_ask* default_instance_;
};
// -------------------------------------------------------------------

class download_src_analyze_detail_ans : public ::google::protobuf::Message {
 public:
  download_src_analyze_detail_ans();
  virtual ~download_src_analyze_detail_ans();

  download_src_analyze_detail_ans(const download_src_analyze_detail_ans& from);

  inline download_src_analyze_detail_ans& operator=(const download_src_analyze_detail_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const download_src_analyze_detail_ans& default_instance();

  void Swap(download_src_analyze_detail_ans* other);

  // implements Message ----------------------------------------------

  download_src_analyze_detail_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const download_src_analyze_detail_ans& from);
  void MergeFrom(const download_src_analyze_detail_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.download_src_detail info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::download_src_detail& info(int index) const;
  inline ::ODP_main_frame::download_src_detail* mutable_info(int index);
  inline ::ODP_main_frame::download_src_detail* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_detail >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_detail >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.download_src_analyze_detail_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_detail > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static download_src_analyze_detail_ans* default_instance_;
};
// -------------------------------------------------------------------

class third_party_login_analyze_ask : public ::google::protobuf::Message {
 public:
  third_party_login_analyze_ask();
  virtual ~third_party_login_analyze_ask();

  third_party_login_analyze_ask(const third_party_login_analyze_ask& from);

  inline third_party_login_analyze_ask& operator=(const third_party_login_analyze_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const third_party_login_analyze_ask& default_instance();

  void Swap(third_party_login_analyze_ask* other);

  // implements Message ----------------------------------------------

  third_party_login_analyze_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const third_party_login_analyze_ask& from);
  void MergeFrom(const third_party_login_analyze_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional .common.common_ask_header ask_header = 4;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 4;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.third_party_login_analyze_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static third_party_login_analyze_ask* default_instance_;
};
// -------------------------------------------------------------------

class third_party_login_analyze_ans : public ::google::protobuf::Message {
 public:
  third_party_login_analyze_ans();
  virtual ~third_party_login_analyze_ans();

  third_party_login_analyze_ans(const third_party_login_analyze_ans& from);

  inline third_party_login_analyze_ans& operator=(const third_party_login_analyze_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const third_party_login_analyze_ans& default_instance();

  void Swap(third_party_login_analyze_ans* other);

  // implements Message ----------------------------------------------

  third_party_login_analyze_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const third_party_login_analyze_ans& from);
  void MergeFrom(const third_party_login_analyze_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.third_party_login_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ODP_main_frame::third_party_login_info& info(int index) const;
  inline ::ODP_main_frame::third_party_login_info* mutable_info(int index);
  inline ::ODP_main_frame::third_party_login_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >*
      mutable_info();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.third_party_login_analyze_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info > info_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static third_party_login_analyze_ans* default_instance_;
};
// -------------------------------------------------------------------

class third_party_login_analyze_list_ask : public ::google::protobuf::Message {
 public:
  third_party_login_analyze_list_ask();
  virtual ~third_party_login_analyze_list_ask();

  third_party_login_analyze_list_ask(const third_party_login_analyze_list_ask& from);

  inline third_party_login_analyze_list_ask& operator=(const third_party_login_analyze_list_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const third_party_login_analyze_list_ask& default_instance();

  void Swap(third_party_login_analyze_list_ask* other);

  // implements Message ----------------------------------------------

  third_party_login_analyze_list_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const third_party_login_analyze_list_ask& from);
  void MergeFrom(const third_party_login_analyze_list_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const void* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional bytes end_date = 2;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const void* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // optional bytes os_version = 3;
  inline bool has_os_version() const;
  inline void clear_os_version();
  static const int kOsVersionFieldNumber = 3;
  inline const ::std::string& os_version() const;
  inline void set_os_version(const ::std::string& value);
  inline void set_os_version(const char* value);
  inline void set_os_version(const void* value, size_t size);
  inline ::std::string* mutable_os_version();
  inline ::std::string* release_os_version();
  inline void set_allocated_os_version(::std::string* os_version);

  // optional int32 page_num = 4;
  inline bool has_page_num() const;
  inline void clear_page_num();
  static const int kPageNumFieldNumber = 4;
  inline ::google::protobuf::int32 page_num() const;
  inline void set_page_num(::google::protobuf::int32 value);

  // optional int32 cur_page = 5;
  inline bool has_cur_page() const;
  inline void clear_cur_page();
  static const int kCurPageFieldNumber = 5;
  inline ::google::protobuf::int32 cur_page() const;
  inline void set_cur_page(::google::protobuf::int32 value);

  // optional .common.common_ask_header ask_header = 6;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 6;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.third_party_login_analyze_list_ask)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_os_version();
  inline void clear_has_os_version();
  inline void set_has_page_num();
  inline void clear_has_page_num();
  inline void set_has_cur_page();
  inline void clear_has_cur_page();
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* os_version_;
  ::google::protobuf::int32 page_num_;
  ::google::protobuf::int32 cur_page_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static third_party_login_analyze_list_ask* default_instance_;
};
// -------------------------------------------------------------------

class third_party_login_analyze_list_ans : public ::google::protobuf::Message {
 public:
  third_party_login_analyze_list_ans();
  virtual ~third_party_login_analyze_list_ans();

  third_party_login_analyze_list_ans(const third_party_login_analyze_list_ans& from);

  inline third_party_login_analyze_list_ans& operator=(const third_party_login_analyze_list_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const third_party_login_analyze_list_ans& default_instance();

  void Swap(third_party_login_analyze_list_ans* other);

  // implements Message ----------------------------------------------

  third_party_login_analyze_list_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const third_party_login_analyze_list_ans& from);
  void MergeFrom(const third_party_login_analyze_list_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_number = 1;
  inline bool has_total_number() const;
  inline void clear_total_number();
  static const int kTotalNumberFieldNumber = 1;
  inline ::google::protobuf::int32 total_number() const;
  inline void set_total_number(::google::protobuf::int32 value);

  // repeated .ODP_main_frame.third_party_login_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ODP_main_frame::third_party_login_info& info(int index) const;
  inline ::ODP_main_frame::third_party_login_info* mutable_info(int index);
  inline ::ODP_main_frame::third_party_login_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >*
      mutable_info();

  // optional .common.errorinfo error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.third_party_login_analyze_list_ans)
 private:
  inline void set_has_total_number();
  inline void clear_has_total_number();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info > info_;
  ::common::errorinfo* error_;
  ::google::protobuf::int32 total_number_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static third_party_login_analyze_list_ans* default_instance_;
};
// -------------------------------------------------------------------

class operation_report_ask : public ::google::protobuf::Message {
 public:
  operation_report_ask();
  virtual ~operation_report_ask();

  operation_report_ask(const operation_report_ask& from);

  inline operation_report_ask& operator=(const operation_report_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const operation_report_ask& default_instance();

  void Swap(operation_report_ask* other);

  // implements Message ----------------------------------------------

  operation_report_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operation_report_ask& from);
  void MergeFrom(const operation_report_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.operation_report_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static operation_report_ask* default_instance_;
};
// -------------------------------------------------------------------

class operation_report_info : public ::google::protobuf::Message {
 public:
  operation_report_info();
  virtual ~operation_report_info();

  operation_report_info(const operation_report_info& from);

  inline operation_report_info& operator=(const operation_report_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const operation_report_info& default_instance();

  void Swap(operation_report_info* other);

  // implements Message ----------------------------------------------

  operation_report_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operation_report_info& from);
  void MergeFrom(const operation_report_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes report_item = 1;
  inline bool has_report_item() const;
  inline void clear_report_item();
  static const int kReportItemFieldNumber = 1;
  inline const ::std::string& report_item() const;
  inline void set_report_item(const ::std::string& value);
  inline void set_report_item(const char* value);
  inline void set_report_item(const void* value, size_t size);
  inline ::std::string* mutable_report_item();
  inline ::std::string* release_report_item();
  inline void set_allocated_report_item(::std::string* report_item);

  // optional int32 total_num = 2;
  inline bool has_total_num() const;
  inline void clear_total_num();
  static const int kTotalNumFieldNumber = 2;
  inline ::google::protobuf::int32 total_num() const;
  inline void set_total_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.operation_report_info)
 private:
  inline void set_has_report_item();
  inline void clear_has_report_item();
  inline void set_has_total_num();
  inline void clear_has_total_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* report_item_;
  ::google::protobuf::int32 total_num_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static operation_report_info* default_instance_;
};
// -------------------------------------------------------------------

class operation_report_ans : public ::google::protobuf::Message {
 public:
  operation_report_ans();
  virtual ~operation_report_ans();

  operation_report_ans(const operation_report_ans& from);

  inline operation_report_ans& operator=(const operation_report_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const operation_report_ans& default_instance();

  void Swap(operation_report_ans* other);

  // implements Message ----------------------------------------------

  operation_report_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const operation_report_ans& from);
  void MergeFrom(const operation_report_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.operation_report_info list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::ODP_main_frame::operation_report_info& list(int index) const;
  inline ::ODP_main_frame::operation_report_info* mutable_list(int index);
  inline ::ODP_main_frame::operation_report_info* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::operation_report_info >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::operation_report_info >*
      mutable_list();

  // optional .common.errorinfo error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::common::errorinfo& error() const;
  inline ::common::errorinfo* mutable_error();
  inline ::common::errorinfo* release_error();
  inline void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.operation_report_ans)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::operation_report_info > list_;
  ::common::errorinfo* error_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static operation_report_ans* default_instance_;
};
// -------------------------------------------------------------------

class doc_row : public ::google::protobuf::Message {
 public:
  doc_row();
  virtual ~doc_row();

  doc_row(const doc_row& from);

  inline doc_row& operator=(const doc_row& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const doc_row& default_instance();

  void Swap(doc_row* other);

  // implements Message ----------------------------------------------

  doc_row* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const doc_row& from);
  void MergeFrom(const doc_row& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const void* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:ODP_main_frame.doc_row)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static doc_row* default_instance_;
};
// -------------------------------------------------------------------

class user_certification_list_row : public ::google::protobuf::Message {
 public:
  user_certification_list_row();
  virtual ~user_certification_list_row();

  user_certification_list_row(const user_certification_list_row& from);

  inline user_certification_list_row& operator=(const user_certification_list_row& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_certification_list_row& default_instance();

  void Swap(user_certification_list_row* other);

  // implements Message ----------------------------------------------

  user_certification_list_row* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_certification_list_row& from);
  void MergeFrom(const user_certification_list_row& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes page2 = 2;
  inline bool has_page2() const;
  inline void clear_page2();
  static const int kPage2FieldNumber = 2;
  inline const ::std::string& page2() const;
  inline void set_page2(const ::std::string& value);
  inline void set_page2(const char* value);
  inline void set_page2(const void* value, size_t size);
  inline ::std::string* mutable_page2();
  inline ::std::string* release_page2();
  inline void set_allocated_page2(::std::string* page2);

  // optional bytes page3 = 3;
  inline bool has_page3() const;
  inline void clear_page3();
  static const int kPage3FieldNumber = 3;
  inline const ::std::string& page3() const;
  inline void set_page3(const ::std::string& value);
  inline void set_page3(const char* value);
  inline void set_page3(const void* value, size_t size);
  inline ::std::string* mutable_page3();
  inline ::std::string* release_page3();
  inline void set_allocated_page3(::std::string* page3);

  // optional int32 access_count = 4;
  inline bool has_access_count() const;
  inline void clear_access_count();
  static const int kAccessCountFieldNumber = 4;
  inline ::google::protobuf::int32 access_count() const;
  inline void set_access_count(::google::protobuf::int32 value);

  // optional int32 submit_count = 5;
  inline bool has_submit_count() const;
  inline void clear_submit_count();
  static const int kSubmitCountFieldNumber = 5;
  inline ::google::protobuf::int32 submit_count() const;
  inline void set_submit_count(::google::protobuf::int32 value);

  // optional float percent1 = 6;
  inline bool has_percent1() const;
  inline void clear_percent1();
  static const int kPercent1FieldNumber = 6;
  inline float percent1() const;
  inline void set_percent1(float value);

  // optional float percent2 = 7;
  inline bool has_percent2() const;
  inline void clear_percent2();
  static const int kPercent2FieldNumber = 7;
  inline float percent2() const;
  inline void set_percent2(float value);

  // optional float percent3 = 8;
  inline bool has_percent3() const;
  inline void clear_percent3();
  static const int kPercent3FieldNumber = 8;
  inline float percent3() const;
  inline void set_percent3(float value);

  // optional float percent4 = 9;
  inline bool has_percent4() const;
  inline void clear_percent4();
  static const int kPercent4FieldNumber = 9;
  inline float percent4() const;
  inline void set_percent4(float value);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_certification_list_row)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_page2();
  inline void clear_has_page2();
  inline void set_has_page3();
  inline void clear_has_page3();
  inline void set_has_access_count();
  inline void clear_has_access_count();
  inline void set_has_submit_count();
  inline void clear_has_submit_count();
  inline void set_has_percent1();
  inline void clear_has_percent1();
  inline void set_has_percent2();
  inline void clear_has_percent2();
  inline void set_has_percent3();
  inline void clear_has_percent3();
  inline void set_has_percent4();
  inline void clear_has_percent4();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* page2_;
  ::std::string* page3_;
  ::google::protobuf::int32 access_count_;
  ::google::protobuf::int32 submit_count_;
  float percent1_;
  float percent2_;
  float percent3_;
  float percent4_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_certification_list_row* default_instance_;
};
// -------------------------------------------------------------------

class user_certification_ask : public ::google::protobuf::Message {
 public:
  user_certification_ask();
  virtual ~user_certification_ask();

  user_certification_ask(const user_certification_ask& from);

  inline user_certification_ask& operator=(const user_certification_ask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_certification_ask& default_instance();

  void Swap(user_certification_ask* other);

  // implements Message ----------------------------------------------

  user_certification_ask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_certification_ask& from);
  void MergeFrom(const user_certification_ask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.common_ask_header ask_header = 1;
  inline bool has_ask_header() const;
  inline void clear_ask_header();
  static const int kAskHeaderFieldNumber = 1;
  inline const ::common::common_ask_header& ask_header() const;
  inline ::common::common_ask_header* mutable_ask_header();
  inline ::common::common_ask_header* release_ask_header();
  inline void set_allocated_ask_header(::common::common_ask_header* ask_header);

  // optional int32 certification_type = 2;
  inline bool has_certification_type() const;
  inline void clear_certification_type();
  static const int kCertificationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 certification_type() const;
  inline void set_certification_type(::google::protobuf::int32 value);

  // optional bytes begin_time = 3;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 3;
  inline const ::std::string& begin_time() const;
  inline void set_begin_time(const ::std::string& value);
  inline void set_begin_time(const char* value);
  inline void set_begin_time(const void* value, size_t size);
  inline ::std::string* mutable_begin_time();
  inline ::std::string* release_begin_time();
  inline void set_allocated_begin_time(::std::string* begin_time);

  // optional bytes end_time = 4;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const void* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_certification_ask)
 private:
  inline void set_has_ask_header();
  inline void clear_has_ask_header();
  inline void set_has_certification_type();
  inline void clear_has_certification_type();
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::common::common_ask_header* ask_header_;
  ::std::string* begin_time_;
  ::std::string* end_time_;
  ::google::protobuf::int32 certification_type_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_certification_ask* default_instance_;
};
// -------------------------------------------------------------------

class user_certification_ans : public ::google::protobuf::Message {
 public:
  user_certification_ans();
  virtual ~user_certification_ans();

  user_certification_ans(const user_certification_ans& from);

  inline user_certification_ans& operator=(const user_certification_ans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_certification_ans& default_instance();

  void Swap(user_certification_ans* other);

  // implements Message ----------------------------------------------

  user_certification_ans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_certification_ans& from);
  void MergeFrom(const user_certification_ans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ODP_main_frame.doc_row row = 1;
  inline int row_size() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::ODP_main_frame::doc_row& row(int index) const;
  inline ::ODP_main_frame::doc_row* mutable_row(int index);
  inline ::ODP_main_frame::doc_row* add_row();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::doc_row >&
      row() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::doc_row >*
      mutable_row();

  // repeated .ODP_main_frame.user_certification_list_row list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::ODP_main_frame::user_certification_list_row& list(int index) const;
  inline ::ODP_main_frame::user_certification_list_row* mutable_list(int index);
  inline ::ODP_main_frame::user_certification_list_row* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_certification_list_row >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_certification_list_row >*
      mutable_list();

  // optional .common.result_info result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline const ::common::result_info& result() const;
  inline ::common::result_info* mutable_result();
  inline ::common::result_info* release_result();
  inline void set_allocated_result(::common::result_info* result);

  // @@protoc_insertion_point(class_scope:ODP_main_frame.user_certification_ans)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::doc_row > row_;
  ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_certification_list_row > list_;
  ::common::result_info* result_;
  friend void  protobuf_AddDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_AssignDesc_ODP_5fmain_5fframe_2eproto();
  friend void protobuf_ShutdownFile_ODP_5fmain_5fframe_2eproto();

  void InitAsDefaultInstance();
  static user_certification_ans* default_instance_;
};
// ===================================================================


// ===================================================================

// Pay_Withdraw

// optional bytes cur_date = 1;
inline bool Pay_Withdraw::has_cur_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pay_Withdraw::set_has_cur_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pay_Withdraw::clear_has_cur_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pay_Withdraw::clear_cur_date() {
  if (cur_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cur_date_->clear();
  }
  clear_has_cur_date();
}
inline const ::std::string& Pay_Withdraw::cur_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw.cur_date)
  return *cur_date_;
}
inline void Pay_Withdraw::set_cur_date(const ::std::string& value) {
  set_has_cur_date();
  if (cur_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cur_date_ = new ::std::string;
  }
  cur_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.Pay_Withdraw.cur_date)
}
inline void Pay_Withdraw::set_cur_date(const char* value) {
  set_has_cur_date();
  if (cur_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cur_date_ = new ::std::string;
  }
  cur_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.Pay_Withdraw.cur_date)
}
inline void Pay_Withdraw::set_cur_date(const void* value, size_t size) {
  set_has_cur_date();
  if (cur_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cur_date_ = new ::std::string;
  }
  cur_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.Pay_Withdraw.cur_date)
}
inline ::std::string* Pay_Withdraw::mutable_cur_date() {
  set_has_cur_date();
  if (cur_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cur_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw.cur_date)
  return cur_date_;
}
inline ::std::string* Pay_Withdraw::release_cur_date() {
  clear_has_cur_date();
  if (cur_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cur_date_;
    cur_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pay_Withdraw::set_allocated_cur_date(::std::string* cur_date) {
  if (cur_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cur_date_;
  }
  if (cur_date) {
    set_has_cur_date();
    cur_date_ = cur_date;
  } else {
    clear_has_cur_date();
    cur_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Pay_Withdraw.cur_date)
}

// optional double pay_amount = 2;
inline bool Pay_Withdraw::has_pay_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pay_Withdraw::set_has_pay_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pay_Withdraw::clear_has_pay_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pay_Withdraw::clear_pay_amount() {
  pay_amount_ = 0;
  clear_has_pay_amount();
}
inline double Pay_Withdraw::pay_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw.pay_amount)
  return pay_amount_;
}
inline void Pay_Withdraw::set_pay_amount(double value) {
  set_has_pay_amount();
  pay_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.Pay_Withdraw.pay_amount)
}

// optional double withdraw_amount = 3;
inline bool Pay_Withdraw::has_withdraw_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pay_Withdraw::set_has_withdraw_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pay_Withdraw::clear_has_withdraw_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pay_Withdraw::clear_withdraw_amount() {
  withdraw_amount_ = 0;
  clear_has_withdraw_amount();
}
inline double Pay_Withdraw::withdraw_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw.withdraw_amount)
  return withdraw_amount_;
}
inline void Pay_Withdraw::set_withdraw_amount(double value) {
  set_has_withdraw_amount();
  withdraw_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.Pay_Withdraw.withdraw_amount)
}

// -------------------------------------------------------------------

// province_under_count

// optional bytes province_name = 1;
inline bool province_under_count::has_province_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void province_under_count::set_has_province_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void province_under_count::clear_has_province_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void province_under_count::clear_province_name() {
  if (province_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_->clear();
  }
  clear_has_province_name();
}
inline const ::std::string& province_under_count::province_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.province_under_count.province_name)
  return *province_name_;
}
inline void province_under_count::set_province_name(const ::std::string& value) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.province_under_count.province_name)
}
inline void province_under_count::set_province_name(const char* value) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.province_under_count.province_name)
}
inline void province_under_count::set_province_name(const void* value, size_t size) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.province_under_count.province_name)
}
inline ::std::string* province_under_count::mutable_province_name() {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.province_under_count.province_name)
  return province_name_;
}
inline ::std::string* province_under_count::release_province_name() {
  clear_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_name_;
    province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void province_under_count::set_allocated_province_name(::std::string* province_name) {
  if (province_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_name_;
  }
  if (province_name) {
    set_has_province_name();
    province_name_ = province_name;
  } else {
    clear_has_province_name();
    province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.province_under_count.province_name)
}

// optional int32 under_count = 2;
inline bool province_under_count::has_under_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void province_under_count::set_has_under_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void province_under_count::clear_has_under_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void province_under_count::clear_under_count() {
  under_count_ = 0;
  clear_has_under_count();
}
inline ::google::protobuf::int32 province_under_count::under_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.province_under_count.under_count)
  return under_count_;
}
inline void province_under_count::set_under_count(::google::protobuf::int32 value) {
  set_has_under_count();
  under_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.province_under_count.under_count)
}

// -------------------------------------------------------------------

// city_bid_count

// optional bytes city_name = 1;
inline bool city_bid_count::has_city_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_bid_count::set_has_city_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_bid_count::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_bid_count::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& city_bid_count::city_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count.city_name)
  return *city_name_;
}
inline void city_bid_count::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.city_bid_count.city_name)
}
inline void city_bid_count::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.city_bid_count.city_name)
}
inline void city_bid_count::set_city_name(const void* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.city_bid_count.city_name)
}
inline ::std::string* city_bid_count::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.city_bid_count.city_name)
  return city_name_;
}
inline ::std::string* city_bid_count::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void city_bid_count::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.city_bid_count.city_name)
}

// optional int32 bid_count = 2;
inline bool city_bid_count::has_bid_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_bid_count::set_has_bid_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_bid_count::clear_has_bid_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_bid_count::clear_bid_count() {
  bid_count_ = 0;
  clear_has_bid_count();
}
inline ::google::protobuf::int32 city_bid_count::bid_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count.bid_count)
  return bid_count_;
}
inline void city_bid_count::set_bid_count(::google::protobuf::int32 value) {
  set_has_bid_count();
  bid_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.city_bid_count.bid_count)
}

// -------------------------------------------------------------------

// unfinished_bid_info

// optional bytes city_name = 1;
inline bool unfinished_bid_info::has_city_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unfinished_bid_info::set_has_city_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unfinished_bid_info::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unfinished_bid_info::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& unfinished_bid_info::city_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_info.city_name)
  return *city_name_;
}
inline void unfinished_bid_info::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.unfinished_bid_info.city_name)
}
inline void unfinished_bid_info::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.unfinished_bid_info.city_name)
}
inline void unfinished_bid_info::set_city_name(const void* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.unfinished_bid_info.city_name)
}
inline ::std::string* unfinished_bid_info::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.unfinished_bid_info.city_name)
  return city_name_;
}
inline ::std::string* unfinished_bid_info::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void unfinished_bid_info::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.unfinished_bid_info.city_name)
}

// repeated bytes role_city_name = 2;
inline int unfinished_bid_info::role_city_name_size() const {
  return role_city_name_.size();
}
inline void unfinished_bid_info::clear_role_city_name() {
  role_city_name_.Clear();
}
inline const ::std::string& unfinished_bid_info::role_city_name(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_info.role_city_name)
  return role_city_name_.Get(index);
}
inline ::std::string* unfinished_bid_info::mutable_role_city_name(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.unfinished_bid_info.role_city_name)
  return role_city_name_.Mutable(index);
}
inline void unfinished_bid_info::set_role_city_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ODP_main_frame.unfinished_bid_info.role_city_name)
  role_city_name_.Mutable(index)->assign(value);
}
inline void unfinished_bid_info::set_role_city_name(int index, const char* value) {
  role_city_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.unfinished_bid_info.role_city_name)
}
inline void unfinished_bid_info::set_role_city_name(int index, const void* value, size_t size) {
  role_city_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.unfinished_bid_info.role_city_name)
}
inline ::std::string* unfinished_bid_info::add_role_city_name() {
  return role_city_name_.Add();
}
inline void unfinished_bid_info::add_role_city_name(const ::std::string& value) {
  role_city_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ODP_main_frame.unfinished_bid_info.role_city_name)
}
inline void unfinished_bid_info::add_role_city_name(const char* value) {
  role_city_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ODP_main_frame.unfinished_bid_info.role_city_name)
}
inline void unfinished_bid_info::add_role_city_name(const void* value, size_t size) {
  role_city_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ODP_main_frame.unfinished_bid_info.role_city_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unfinished_bid_info::role_city_name() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.unfinished_bid_info.role_city_name)
  return role_city_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unfinished_bid_info::mutable_role_city_name() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.unfinished_bid_info.role_city_name)
  return &role_city_name_;
}

// -------------------------------------------------------------------

// user_distribution

// optional bytes city_name = 1;
inline bool user_distribution::has_city_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_distribution::set_has_city_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_distribution::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_distribution::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& user_distribution::city_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution.city_name)
  return *city_name_;
}
inline void user_distribution::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_distribution.city_name)
}
inline void user_distribution::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_distribution.city_name)
}
inline void user_distribution::set_city_name(const void* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_distribution.city_name)
}
inline ::std::string* user_distribution::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_distribution.city_name)
  return city_name_;
}
inline ::std::string* user_distribution::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_distribution::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_distribution.city_name)
}

// optional int32 user_count = 2;
inline bool user_distribution::has_user_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_distribution::set_has_user_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_distribution::clear_has_user_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_distribution::clear_user_count() {
  user_count_ = 0;
  clear_has_user_count();
}
inline ::google::protobuf::int32 user_distribution::user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution.user_count)
  return user_count_;
}
inline void user_distribution::set_user_count(::google::protobuf::int32 value) {
  set_has_user_count();
  user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_distribution.user_count)
}

// -------------------------------------------------------------------

// cur_trading_volume

// optional bytes hour = 1;
inline bool cur_trading_volume::has_hour() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_trading_volume::set_has_hour() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_trading_volume::clear_has_hour() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_trading_volume::clear_hour() {
  if (hour_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_->clear();
  }
  clear_has_hour();
}
inline const ::std::string& cur_trading_volume::hour() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume.hour)
  return *hour_;
}
inline void cur_trading_volume::set_hour(const ::std::string& value) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_volume.hour)
}
inline void cur_trading_volume::set_hour(const char* value) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_volume.hour)
}
inline void cur_trading_volume::set_hour(const void* value, size_t size) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_volume.hour)
}
inline ::std::string* cur_trading_volume::mutable_hour() {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume.hour)
  return hour_;
}
inline ::std::string* cur_trading_volume::release_hour() {
  clear_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hour_;
    hour_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_volume::set_allocated_hour(::std::string* hour) {
  if (hour_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hour_;
  }
  if (hour) {
    set_has_hour();
    hour_ = hour;
  } else {
    clear_has_hour();
    hour_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_volume.hour)
}

// optional float trading_volume = 2;
inline bool cur_trading_volume::has_trading_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_volume::set_has_trading_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_volume::clear_has_trading_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_volume::clear_trading_volume() {
  trading_volume_ = 0;
  clear_has_trading_volume();
}
inline float cur_trading_volume::trading_volume() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume.trading_volume)
  return trading_volume_;
}
inline void cur_trading_volume::set_trading_volume(float value) {
  set_has_trading_volume();
  trading_volume_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_volume.trading_volume)
}

// -------------------------------------------------------------------

// cur_province_trading_volume

// optional bytes province_name = 1;
inline bool cur_province_trading_volume::has_province_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_province_trading_volume::set_has_province_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_province_trading_volume::clear_has_province_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_province_trading_volume::clear_province_name() {
  if (province_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_->clear();
  }
  clear_has_province_name();
}
inline const ::std::string& cur_province_trading_volume::province_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_province_trading_volume.province_name)
  return *province_name_;
}
inline void cur_province_trading_volume::set_province_name(const ::std::string& value) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_province_trading_volume.province_name)
}
inline void cur_province_trading_volume::set_province_name(const char* value) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_province_trading_volume.province_name)
}
inline void cur_province_trading_volume::set_province_name(const void* value, size_t size) {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  province_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_province_trading_volume.province_name)
}
inline ::std::string* cur_province_trading_volume::mutable_province_name() {
  set_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_province_trading_volume.province_name)
  return province_name_;
}
inline ::std::string* cur_province_trading_volume::release_province_name() {
  clear_has_province_name();
  if (province_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_name_;
    province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_province_trading_volume::set_allocated_province_name(::std::string* province_name) {
  if (province_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_name_;
  }
  if (province_name) {
    set_has_province_name();
    province_name_ = province_name;
  } else {
    clear_has_province_name();
    province_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_province_trading_volume.province_name)
}

// optional int32 trading_volume = 2;
inline bool cur_province_trading_volume::has_trading_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_province_trading_volume::set_has_trading_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_province_trading_volume::clear_has_trading_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_province_trading_volume::clear_trading_volume() {
  trading_volume_ = 0;
  clear_has_trading_volume();
}
inline ::google::protobuf::int32 cur_province_trading_volume::trading_volume() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_province_trading_volume.trading_volume)
  return trading_volume_;
}
inline void cur_province_trading_volume::set_trading_volume(::google::protobuf::int32 value) {
  set_has_trading_volume();
  trading_volume_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_province_trading_volume.trading_volume)
}

// -------------------------------------------------------------------

// month_registration_volume

// optional bytes year_month = 1;
inline bool month_registration_volume::has_year_month() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_registration_volume::set_has_year_month() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_registration_volume::clear_has_year_month() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_registration_volume::clear_year_month() {
  if (year_month_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_->clear();
  }
  clear_has_year_month();
}
inline const ::std::string& month_registration_volume::year_month() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_volume.year_month)
  return *year_month_;
}
inline void month_registration_volume::set_year_month(const ::std::string& value) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_registration_volume.year_month)
}
inline void month_registration_volume::set_year_month(const char* value) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_registration_volume.year_month)
}
inline void month_registration_volume::set_year_month(const void* value, size_t size) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_registration_volume.year_month)
}
inline ::std::string* month_registration_volume::mutable_year_month() {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_volume.year_month)
  return year_month_;
}
inline ::std::string* month_registration_volume::release_year_month() {
  clear_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = year_month_;
    year_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_registration_volume::set_allocated_year_month(::std::string* year_month) {
  if (year_month_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete year_month_;
  }
  if (year_month) {
    set_has_year_month();
    year_month_ = year_month;
  } else {
    clear_has_year_month();
    year_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_registration_volume.year_month)
}

// optional int32 regist_volume = 2;
inline bool month_registration_volume::has_regist_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_registration_volume::set_has_regist_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_registration_volume::clear_has_regist_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_registration_volume::clear_regist_volume() {
  regist_volume_ = 0;
  clear_has_regist_volume();
}
inline ::google::protobuf::int32 month_registration_volume::regist_volume() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_volume.regist_volume)
  return regist_volume_;
}
inline void month_registration_volume::set_regist_volume(::google::protobuf::int32 value) {
  set_has_regist_volume();
  regist_volume_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_registration_volume.regist_volume)
}

// -------------------------------------------------------------------

// cur_trading_count

// optional bytes hour = 1;
inline bool cur_trading_count::has_hour() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_trading_count::set_has_hour() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_trading_count::clear_has_hour() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_trading_count::clear_hour() {
  if (hour_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_->clear();
  }
  clear_has_hour();
}
inline const ::std::string& cur_trading_count::hour() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count.hour)
  return *hour_;
}
inline void cur_trading_count::set_hour(const ::std::string& value) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_count.hour)
}
inline void cur_trading_count::set_hour(const char* value) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_count.hour)
}
inline void cur_trading_count::set_hour(const void* value, size_t size) {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  hour_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_count.hour)
}
inline ::std::string* cur_trading_count::mutable_hour() {
  set_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hour_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count.hour)
  return hour_;
}
inline ::std::string* cur_trading_count::release_hour() {
  clear_has_hour();
  if (hour_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hour_;
    hour_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_count::set_allocated_hour(::std::string* hour) {
  if (hour_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hour_;
  }
  if (hour) {
    set_has_hour();
    hour_ = hour;
  } else {
    clear_has_hour();
    hour_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_count.hour)
}

// optional int32 trading_count = 2;
inline bool cur_trading_count::has_trading_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_count::set_has_trading_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_count::clear_has_trading_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_count::clear_trading_count() {
  trading_count_ = 0;
  clear_has_trading_count();
}
inline ::google::protobuf::int32 cur_trading_count::trading_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count.trading_count)
  return trading_count_;
}
inline void cur_trading_count::set_trading_count(::google::protobuf::int32 value) {
  set_has_trading_count();
  trading_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_count.trading_count)
}

// -------------------------------------------------------------------

// month_trading_volume

// optional bytes year_month = 1;
inline bool month_trading_volume::has_year_month() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_trading_volume::set_has_year_month() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_trading_volume::clear_has_year_month() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_trading_volume::clear_year_month() {
  if (year_month_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_->clear();
  }
  clear_has_year_month();
}
inline const ::std::string& month_trading_volume::year_month() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_volume.year_month)
  return *year_month_;
}
inline void month_trading_volume::set_year_month(const ::std::string& value) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_trading_volume.year_month)
}
inline void month_trading_volume::set_year_month(const char* value) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_trading_volume.year_month)
}
inline void month_trading_volume::set_year_month(const void* value, size_t size) {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  year_month_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_trading_volume.year_month)
}
inline ::std::string* month_trading_volume::mutable_year_month() {
  set_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    year_month_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_volume.year_month)
  return year_month_;
}
inline ::std::string* month_trading_volume::release_year_month() {
  clear_has_year_month();
  if (year_month_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = year_month_;
    year_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_trading_volume::set_allocated_year_month(::std::string* year_month) {
  if (year_month_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete year_month_;
  }
  if (year_month) {
    set_has_year_month();
    year_month_ = year_month;
  } else {
    clear_has_year_month();
    year_month_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_trading_volume.year_month)
}

// optional float trading_volume = 2;
inline bool month_trading_volume::has_trading_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_trading_volume::set_has_trading_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_trading_volume::clear_has_trading_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_trading_volume::clear_trading_volume() {
  trading_volume_ = 0;
  clear_has_trading_volume();
}
inline float month_trading_volume::trading_volume() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_volume.trading_volume)
  return trading_volume_;
}
inline void month_trading_volume::set_trading_volume(float value) {
  set_has_trading_volume();
  trading_volume_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_trading_volume.trading_volume)
}

// -------------------------------------------------------------------

// registration_info

// optional bytes city_name = 1;
inline bool registration_info::has_city_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void registration_info::set_has_city_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void registration_info::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void registration_info::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& registration_info::city_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.registration_info.city_name)
  return *city_name_;
}
inline void registration_info::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.registration_info.city_name)
}
inline void registration_info::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.registration_info.city_name)
}
inline void registration_info::set_city_name(const void* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.registration_info.city_name)
}
inline ::std::string* registration_info::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.registration_info.city_name)
  return city_name_;
}
inline ::std::string* registration_info::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void registration_info::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.registration_info.city_name)
}

// optional int32 count = 2;
inline bool registration_info::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void registration_info::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void registration_info::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void registration_info::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 registration_info::count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.registration_info.count)
  return count_;
}
inline void registration_info::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.registration_info.count)
}

// -------------------------------------------------------------------

// charge_info

// optional bytes city_name = 1;
inline bool charge_info::has_city_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void charge_info::set_has_city_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void charge_info::clear_has_city_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void charge_info::clear_city_name() {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_->clear();
  }
  clear_has_city_name();
}
inline const ::std::string& charge_info::city_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.charge_info.city_name)
  return *city_name_;
}
inline void charge_info::set_city_name(const ::std::string& value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.charge_info.city_name)
}
inline void charge_info::set_city_name(const char* value) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.charge_info.city_name)
}
inline void charge_info::set_city_name(const void* value, size_t size) {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  city_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.charge_info.city_name)
}
inline ::std::string* charge_info::mutable_city_name() {
  set_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.charge_info.city_name)
  return city_name_;
}
inline ::std::string* charge_info::release_city_name() {
  clear_has_city_name();
  if (city_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_name_;
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void charge_info::set_allocated_city_name(::std::string* city_name) {
  if (city_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_name_;
  }
  if (city_name) {
    set_has_city_name();
    city_name_ = city_name;
  } else {
    clear_has_city_name();
    city_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.charge_info.city_name)
}

// optional float charge_amount = 2;
inline bool charge_info::has_charge_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void charge_info::set_has_charge_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void charge_info::clear_has_charge_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void charge_info::clear_charge_amount() {
  charge_amount_ = 0;
  clear_has_charge_amount();
}
inline float charge_info::charge_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.charge_info.charge_amount)
  return charge_amount_;
}
inline void charge_info::set_charge_amount(float value) {
  set_has_charge_amount();
  charge_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.charge_info.charge_amount)
}

// -------------------------------------------------------------------

// real_fund_detail

// optional bytes fund_serial_number = 1;
inline bool real_fund_detail::has_fund_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void real_fund_detail::set_has_fund_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void real_fund_detail::clear_has_fund_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void real_fund_detail::clear_fund_serial_number() {
  if (fund_serial_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_number_->clear();
  }
  clear_has_fund_serial_number();
}
inline const ::std::string& real_fund_detail::fund_serial_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_serial_number)
  return *fund_serial_number_;
}
inline void real_fund_detail::set_fund_serial_number(const ::std::string& value) {
  set_has_fund_serial_number();
  if (fund_serial_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_number_ = new ::std::string;
  }
  fund_serial_number_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_serial_number)
}
inline void real_fund_detail::set_fund_serial_number(const char* value) {
  set_has_fund_serial_number();
  if (fund_serial_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_number_ = new ::std::string;
  }
  fund_serial_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_serial_number)
}
inline void real_fund_detail::set_fund_serial_number(const void* value, size_t size) {
  set_has_fund_serial_number();
  if (fund_serial_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_number_ = new ::std::string;
  }
  fund_serial_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_serial_number)
}
inline ::std::string* real_fund_detail::mutable_fund_serial_number() {
  set_has_fund_serial_number();
  if (fund_serial_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_serial_number)
  return fund_serial_number_;
}
inline ::std::string* real_fund_detail::release_fund_serial_number() {
  clear_has_fund_serial_number();
  if (fund_serial_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_serial_number_;
    fund_serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_serial_number(::std::string* fund_serial_number) {
  if (fund_serial_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_serial_number_;
  }
  if (fund_serial_number) {
    set_has_fund_serial_number();
    fund_serial_number_ = fund_serial_number;
  } else {
    clear_has_fund_serial_number();
    fund_serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_serial_number)
}

// optional bytes fund_serial_name = 2;
inline bool real_fund_detail::has_fund_serial_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void real_fund_detail::set_has_fund_serial_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void real_fund_detail::clear_has_fund_serial_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void real_fund_detail::clear_fund_serial_name() {
  if (fund_serial_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_name_->clear();
  }
  clear_has_fund_serial_name();
}
inline const ::std::string& real_fund_detail::fund_serial_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_serial_name)
  return *fund_serial_name_;
}
inline void real_fund_detail::set_fund_serial_name(const ::std::string& value) {
  set_has_fund_serial_name();
  if (fund_serial_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_name_ = new ::std::string;
  }
  fund_serial_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_serial_name)
}
inline void real_fund_detail::set_fund_serial_name(const char* value) {
  set_has_fund_serial_name();
  if (fund_serial_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_name_ = new ::std::string;
  }
  fund_serial_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_serial_name)
}
inline void real_fund_detail::set_fund_serial_name(const void* value, size_t size) {
  set_has_fund_serial_name();
  if (fund_serial_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_name_ = new ::std::string;
  }
  fund_serial_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_serial_name)
}
inline ::std::string* real_fund_detail::mutable_fund_serial_name() {
  set_has_fund_serial_name();
  if (fund_serial_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_serial_name)
  return fund_serial_name_;
}
inline ::std::string* real_fund_detail::release_fund_serial_name() {
  clear_has_fund_serial_name();
  if (fund_serial_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_serial_name_;
    fund_serial_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_serial_name(::std::string* fund_serial_name) {
  if (fund_serial_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_serial_name_;
  }
  if (fund_serial_name) {
    set_has_fund_serial_name();
    fund_serial_name_ = fund_serial_name;
  } else {
    clear_has_fund_serial_name();
    fund_serial_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_serial_name)
}

// optional bytes user_name = 3;
inline bool real_fund_detail::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void real_fund_detail::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void real_fund_detail::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void real_fund_detail::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& real_fund_detail::user_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.user_name)
  return *user_name_;
}
inline void real_fund_detail::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.user_name)
}
inline void real_fund_detail::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.user_name)
}
inline void real_fund_detail::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.user_name)
}
inline ::std::string* real_fund_detail::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.user_name)
  return user_name_;
}
inline ::std::string* real_fund_detail::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.user_name)
}

// optional bytes telno = 4;
inline bool real_fund_detail::has_telno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void real_fund_detail::set_has_telno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void real_fund_detail::clear_has_telno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void real_fund_detail::clear_telno() {
  if (telno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    telno_->clear();
  }
  clear_has_telno();
}
inline const ::std::string& real_fund_detail::telno() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.telno)
  return *telno_;
}
inline void real_fund_detail::set_telno(const ::std::string& value) {
  set_has_telno();
  if (telno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    telno_ = new ::std::string;
  }
  telno_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.telno)
}
inline void real_fund_detail::set_telno(const char* value) {
  set_has_telno();
  if (telno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    telno_ = new ::std::string;
  }
  telno_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.telno)
}
inline void real_fund_detail::set_telno(const void* value, size_t size) {
  set_has_telno();
  if (telno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    telno_ = new ::std::string;
  }
  telno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.telno)
}
inline ::std::string* real_fund_detail::mutable_telno() {
  set_has_telno();
  if (telno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    telno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.telno)
  return telno_;
}
inline ::std::string* real_fund_detail::release_telno() {
  clear_has_telno();
  if (telno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = telno_;
    telno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_telno(::std::string* telno) {
  if (telno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete telno_;
  }
  if (telno) {
    set_has_telno();
    telno_ = telno;
  } else {
    clear_has_telno();
    telno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.telno)
}

// optional bytes to_user_name = 5;
inline bool real_fund_detail::has_to_user_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void real_fund_detail::set_has_to_user_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void real_fund_detail::clear_has_to_user_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void real_fund_detail::clear_to_user_name() {
  if (to_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_user_name_->clear();
  }
  clear_has_to_user_name();
}
inline const ::std::string& real_fund_detail::to_user_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.to_user_name)
  return *to_user_name_;
}
inline void real_fund_detail::set_to_user_name(const ::std::string& value) {
  set_has_to_user_name();
  if (to_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_user_name_ = new ::std::string;
  }
  to_user_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.to_user_name)
}
inline void real_fund_detail::set_to_user_name(const char* value) {
  set_has_to_user_name();
  if (to_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_user_name_ = new ::std::string;
  }
  to_user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.to_user_name)
}
inline void real_fund_detail::set_to_user_name(const void* value, size_t size) {
  set_has_to_user_name();
  if (to_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_user_name_ = new ::std::string;
  }
  to_user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.to_user_name)
}
inline ::std::string* real_fund_detail::mutable_to_user_name() {
  set_has_to_user_name();
  if (to_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.to_user_name)
  return to_user_name_;
}
inline ::std::string* real_fund_detail::release_to_user_name() {
  clear_has_to_user_name();
  if (to_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = to_user_name_;
    to_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_to_user_name(::std::string* to_user_name) {
  if (to_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete to_user_name_;
  }
  if (to_user_name) {
    set_has_to_user_name();
    to_user_name_ = to_user_name;
  } else {
    clear_has_to_user_name();
    to_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.to_user_name)
}

// optional bytes fund_serial_type = 6;
inline bool real_fund_detail::has_fund_serial_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void real_fund_detail::set_has_fund_serial_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void real_fund_detail::clear_has_fund_serial_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void real_fund_detail::clear_fund_serial_type() {
  if (fund_serial_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_type_->clear();
  }
  clear_has_fund_serial_type();
}
inline const ::std::string& real_fund_detail::fund_serial_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_serial_type)
  return *fund_serial_type_;
}
inline void real_fund_detail::set_fund_serial_type(const ::std::string& value) {
  set_has_fund_serial_type();
  if (fund_serial_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_type_ = new ::std::string;
  }
  fund_serial_type_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_serial_type)
}
inline void real_fund_detail::set_fund_serial_type(const char* value) {
  set_has_fund_serial_type();
  if (fund_serial_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_type_ = new ::std::string;
  }
  fund_serial_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_serial_type)
}
inline void real_fund_detail::set_fund_serial_type(const void* value, size_t size) {
  set_has_fund_serial_type();
  if (fund_serial_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_type_ = new ::std::string;
  }
  fund_serial_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_serial_type)
}
inline ::std::string* real_fund_detail::mutable_fund_serial_type() {
  set_has_fund_serial_type();
  if (fund_serial_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_serial_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_serial_type)
  return fund_serial_type_;
}
inline ::std::string* real_fund_detail::release_fund_serial_type() {
  clear_has_fund_serial_type();
  if (fund_serial_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_serial_type_;
    fund_serial_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_serial_type(::std::string* fund_serial_type) {
  if (fund_serial_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_serial_type_;
  }
  if (fund_serial_type) {
    set_has_fund_serial_type();
    fund_serial_type_ = fund_serial_type;
  } else {
    clear_has_fund_serial_type();
    fund_serial_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_serial_type)
}

// optional bytes fund_amount = 7;
inline bool real_fund_detail::has_fund_amount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void real_fund_detail::set_has_fund_amount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void real_fund_detail::clear_has_fund_amount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void real_fund_detail::clear_fund_amount() {
  if (fund_amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_amount_->clear();
  }
  clear_has_fund_amount();
}
inline const ::std::string& real_fund_detail::fund_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_amount)
  return *fund_amount_;
}
inline void real_fund_detail::set_fund_amount(const ::std::string& value) {
  set_has_fund_amount();
  if (fund_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_amount_ = new ::std::string;
  }
  fund_amount_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_amount)
}
inline void real_fund_detail::set_fund_amount(const char* value) {
  set_has_fund_amount();
  if (fund_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_amount_ = new ::std::string;
  }
  fund_amount_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_amount)
}
inline void real_fund_detail::set_fund_amount(const void* value, size_t size) {
  set_has_fund_amount();
  if (fund_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_amount_ = new ::std::string;
  }
  fund_amount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_amount)
}
inline ::std::string* real_fund_detail::mutable_fund_amount() {
  set_has_fund_amount();
  if (fund_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_amount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_amount)
  return fund_amount_;
}
inline ::std::string* real_fund_detail::release_fund_amount() {
  clear_has_fund_amount();
  if (fund_amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_amount_;
    fund_amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_amount(::std::string* fund_amount) {
  if (fund_amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_amount_;
  }
  if (fund_amount) {
    set_has_fund_amount();
    fund_amount_ = fund_amount;
  } else {
    clear_has_fund_amount();
    fund_amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_amount)
}

// optional bytes fund_status = 8;
inline bool real_fund_detail::has_fund_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void real_fund_detail::set_has_fund_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void real_fund_detail::clear_has_fund_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void real_fund_detail::clear_fund_status() {
  if (fund_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_status_->clear();
  }
  clear_has_fund_status();
}
inline const ::std::string& real_fund_detail::fund_status() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_status)
  return *fund_status_;
}
inline void real_fund_detail::set_fund_status(const ::std::string& value) {
  set_has_fund_status();
  if (fund_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_status_ = new ::std::string;
  }
  fund_status_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_status)
}
inline void real_fund_detail::set_fund_status(const char* value) {
  set_has_fund_status();
  if (fund_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_status_ = new ::std::string;
  }
  fund_status_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_status)
}
inline void real_fund_detail::set_fund_status(const void* value, size_t size) {
  set_has_fund_status();
  if (fund_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_status_ = new ::std::string;
  }
  fund_status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_status)
}
inline ::std::string* real_fund_detail::mutable_fund_status() {
  set_has_fund_status();
  if (fund_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_status)
  return fund_status_;
}
inline ::std::string* real_fund_detail::release_fund_status() {
  clear_has_fund_status();
  if (fund_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_status_;
    fund_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_status(::std::string* fund_status) {
  if (fund_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_status_;
  }
  if (fund_status) {
    set_has_fund_status();
    fund_status_ = fund_status;
  } else {
    clear_has_fund_status();
    fund_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_status)
}

// optional bytes fund_desc = 9;
inline bool real_fund_detail::has_fund_desc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void real_fund_detail::set_has_fund_desc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void real_fund_detail::clear_has_fund_desc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void real_fund_detail::clear_fund_desc() {
  if (fund_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_desc_->clear();
  }
  clear_has_fund_desc();
}
inline const ::std::string& real_fund_detail::fund_desc() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.fund_desc)
  return *fund_desc_;
}
inline void real_fund_detail::set_fund_desc(const ::std::string& value) {
  set_has_fund_desc();
  if (fund_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_desc_ = new ::std::string;
  }
  fund_desc_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.fund_desc)
}
inline void real_fund_detail::set_fund_desc(const char* value) {
  set_has_fund_desc();
  if (fund_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_desc_ = new ::std::string;
  }
  fund_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.fund_desc)
}
inline void real_fund_detail::set_fund_desc(const void* value, size_t size) {
  set_has_fund_desc();
  if (fund_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_desc_ = new ::std::string;
  }
  fund_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.fund_desc)
}
inline ::std::string* real_fund_detail::mutable_fund_desc() {
  set_has_fund_desc();
  if (fund_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fund_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.fund_desc)
  return fund_desc_;
}
inline ::std::string* real_fund_detail::release_fund_desc() {
  clear_has_fund_desc();
  if (fund_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fund_desc_;
    fund_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_fund_desc(::std::string* fund_desc) {
  if (fund_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fund_desc_;
  }
  if (fund_desc) {
    set_has_fund_desc();
    fund_desc_ = fund_desc;
  } else {
    clear_has_fund_desc();
    fund_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.fund_desc)
}

// optional bytes update_time = 10;
inline bool real_fund_detail::has_update_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void real_fund_detail::set_has_update_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void real_fund_detail::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void real_fund_detail::clear_update_time() {
  if (update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_time_->clear();
  }
  clear_has_update_time();
}
inline const ::std::string& real_fund_detail::update_time() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_fund_detail.update_time)
  return *update_time_;
}
inline void real_fund_detail::set_update_time(const ::std::string& value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.real_fund_detail.update_time)
}
inline void real_fund_detail::set_update_time(const char* value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.real_fund_detail.update_time)
}
inline void real_fund_detail::set_update_time(const void* value, size_t size) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.real_fund_detail.update_time)
}
inline ::std::string* real_fund_detail::mutable_update_time() {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_fund_detail.update_time)
  return update_time_;
}
inline ::std::string* real_fund_detail::release_update_time() {
  clear_has_update_time();
  if (update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_time_;
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void real_fund_detail::set_allocated_update_time(::std::string* update_time) {
  if (update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_time_;
  }
  if (update_time) {
    set_has_update_time();
    update_time_ = update_time;
  } else {
    clear_has_update_time();
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_fund_detail.update_time)
}

// -------------------------------------------------------------------

// fund_flow_type

// optional bytes type_id = 1;
inline bool fund_flow_type::has_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fund_flow_type::set_has_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fund_flow_type::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fund_flow_type::clear_type_id() {
  if (type_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_id_->clear();
  }
  clear_has_type_id();
}
inline const ::std::string& fund_flow_type::type_id() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.fund_flow_type.type_id)
  return *type_id_;
}
inline void fund_flow_type::set_type_id(const ::std::string& value) {
  set_has_type_id();
  if (type_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_id_ = new ::std::string;
  }
  type_id_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.fund_flow_type.type_id)
}
inline void fund_flow_type::set_type_id(const char* value) {
  set_has_type_id();
  if (type_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_id_ = new ::std::string;
  }
  type_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.fund_flow_type.type_id)
}
inline void fund_flow_type::set_type_id(const void* value, size_t size) {
  set_has_type_id();
  if (type_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_id_ = new ::std::string;
  }
  type_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.fund_flow_type.type_id)
}
inline ::std::string* fund_flow_type::mutable_type_id() {
  set_has_type_id();
  if (type_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.fund_flow_type.type_id)
  return type_id_;
}
inline ::std::string* fund_flow_type::release_type_id() {
  clear_has_type_id();
  if (type_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_id_;
    type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void fund_flow_type::set_allocated_type_id(::std::string* type_id) {
  if (type_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_id_;
  }
  if (type_id) {
    set_has_type_id();
    type_id_ = type_id;
  } else {
    clear_has_type_id();
    type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.fund_flow_type.type_id)
}

// optional bytes title = 2;
inline bool fund_flow_type::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fund_flow_type::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fund_flow_type::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fund_flow_type::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& fund_flow_type::title() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.fund_flow_type.title)
  return *title_;
}
inline void fund_flow_type::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.fund_flow_type.title)
}
inline void fund_flow_type::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.fund_flow_type.title)
}
inline void fund_flow_type::set_title(const void* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.fund_flow_type.title)
}
inline ::std::string* fund_flow_type::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.fund_flow_type.title)
  return title_;
}
inline ::std::string* fund_flow_type::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void fund_flow_type::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.fund_flow_type.title)
}

// -------------------------------------------------------------------

// user_acount_info

// optional int32 user_acount = 1;
inline bool user_acount_info::has_user_acount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_acount_info::set_has_user_acount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_acount_info::clear_has_user_acount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_acount_info::clear_user_acount() {
  user_acount_ = 0;
  clear_has_user_acount();
}
inline ::google::protobuf::int32 user_acount_info::user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_acount_info.user_acount)
  return user_acount_;
}
inline void user_acount_info::set_user_acount(::google::protobuf::int32 value) {
  set_has_user_acount();
  user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_acount_info.user_acount)
}

// optional bytes date_tick = 2;
inline bool user_acount_info::has_date_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_acount_info::set_has_date_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_acount_info::clear_has_date_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_acount_info::clear_date_tick() {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_->clear();
  }
  clear_has_date_tick();
}
inline const ::std::string& user_acount_info::date_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_acount_info.date_tick)
  return *date_tick_;
}
inline void user_acount_info::set_date_tick(const ::std::string& value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_acount_info.date_tick)
}
inline void user_acount_info::set_date_tick(const char* value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_acount_info.date_tick)
}
inline void user_acount_info::set_date_tick(const void* value, size_t size) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_acount_info.date_tick)
}
inline ::std::string* user_acount_info::mutable_date_tick() {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_acount_info.date_tick)
  return date_tick_;
}
inline ::std::string* user_acount_info::release_date_tick() {
  clear_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_tick_;
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_acount_info::set_allocated_date_tick(::std::string* date_tick) {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_tick_;
  }
  if (date_tick) {
    set_has_date_tick();
    date_tick_ = date_tick;
  } else {
    clear_has_date_tick();
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_acount_info.date_tick)
}

// -------------------------------------------------------------------

// top_ten_user_acount_info

// optional bytes app_version = 1;
inline bool top_ten_user_acount_info::has_app_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void top_ten_user_acount_info::set_has_app_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void top_ten_user_acount_info::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void top_ten_user_acount_info::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& top_ten_user_acount_info::app_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.top_ten_user_acount_info.app_version)
  return *app_version_;
}
inline void top_ten_user_acount_info::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.top_ten_user_acount_info.app_version)
}
inline void top_ten_user_acount_info::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.top_ten_user_acount_info.app_version)
}
inline void top_ten_user_acount_info::set_app_version(const void* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.top_ten_user_acount_info.app_version)
}
inline ::std::string* top_ten_user_acount_info::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.top_ten_user_acount_info.app_version)
  return app_version_;
}
inline ::std::string* top_ten_user_acount_info::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void top_ten_user_acount_info::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.top_ten_user_acount_info.app_version)
}

// repeated .ODP_main_frame.user_acount_info info = 2;
inline int top_ten_user_acount_info::info_size() const {
  return info_.size();
}
inline void top_ten_user_acount_info::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_acount_info& top_ten_user_acount_info::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.top_ten_user_acount_info.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_acount_info* top_ten_user_acount_info::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.top_ten_user_acount_info.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_acount_info* top_ten_user_acount_info::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.top_ten_user_acount_info.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
top_ten_user_acount_info::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.top_ten_user_acount_info.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
top_ten_user_acount_info::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.top_ten_user_acount_info.info)
  return &info_;
}

// -------------------------------------------------------------------

// start_count_info

// optional int32 start_count = 1;
inline bool start_count_info::has_start_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_count_info::set_has_start_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_count_info::clear_has_start_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_count_info::clear_start_count() {
  start_count_ = 0;
  clear_has_start_count();
}
inline ::google::protobuf::int32 start_count_info::start_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_info.start_count)
  return start_count_;
}
inline void start_count_info::set_start_count(::google::protobuf::int32 value) {
  set_has_start_count();
  start_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_info.start_count)
}

// optional float start_count_rate = 2;
inline bool start_count_info::has_start_count_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_count_info::set_has_start_count_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_count_info::clear_has_start_count_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_count_info::clear_start_count_rate() {
  start_count_rate_ = 0;
  clear_has_start_count_rate();
}
inline float start_count_info::start_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_info.start_count_rate)
  return start_count_rate_;
}
inline void start_count_info::set_start_count_rate(float value) {
  set_has_start_count_rate();
  start_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_info.start_count_rate)
}

// optional bytes date_tick = 3;
inline bool start_count_info::has_date_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void start_count_info::set_has_date_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void start_count_info::clear_has_date_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void start_count_info::clear_date_tick() {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_->clear();
  }
  clear_has_date_tick();
}
inline const ::std::string& start_count_info::date_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_info.date_tick)
  return *date_tick_;
}
inline void start_count_info::set_date_tick(const ::std::string& value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_info.date_tick)
}
inline void start_count_info::set_date_tick(const char* value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_info.date_tick)
}
inline void start_count_info::set_date_tick(const void* value, size_t size) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_info.date_tick)
}
inline ::std::string* start_count_info::mutable_date_tick() {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_info.date_tick)
  return date_tick_;
}
inline ::std::string* start_count_info::release_date_tick() {
  clear_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_tick_;
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_info::set_allocated_date_tick(::std::string* date_tick) {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_tick_;
  }
  if (date_tick) {
    set_has_date_tick();
    date_tick_ = date_tick;
  } else {
    clear_has_date_tick();
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_info.date_tick)
}

// -------------------------------------------------------------------

// user_analyze_info

// optional int32 user_count = 1;
inline bool user_analyze_info::has_user_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_analyze_info::set_has_user_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_analyze_info::clear_has_user_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_analyze_info::clear_user_count() {
  user_count_ = 0;
  clear_has_user_count();
}
inline ::google::protobuf::int32 user_analyze_info::user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_analyze_info.user_count)
  return user_count_;
}
inline void user_analyze_info::set_user_count(::google::protobuf::int32 value) {
  set_has_user_count();
  user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_analyze_info.user_count)
}

// optional float user_count_rate = 2;
inline bool user_analyze_info::has_user_count_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_analyze_info::set_has_user_count_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_analyze_info::clear_has_user_count_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_analyze_info::clear_user_count_rate() {
  user_count_rate_ = 0;
  clear_has_user_count_rate();
}
inline float user_analyze_info::user_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_analyze_info.user_count_rate)
  return user_count_rate_;
}
inline void user_analyze_info::set_user_count_rate(float value) {
  set_has_user_count_rate();
  user_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_analyze_info.user_count_rate)
}

// optional bytes date_tick = 3;
inline bool user_analyze_info::has_date_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_analyze_info::set_has_date_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_analyze_info::clear_has_date_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_analyze_info::clear_date_tick() {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_->clear();
  }
  clear_has_date_tick();
}
inline const ::std::string& user_analyze_info::date_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_analyze_info.date_tick)
  return *date_tick_;
}
inline void user_analyze_info::set_date_tick(const ::std::string& value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_analyze_info.date_tick)
}
inline void user_analyze_info::set_date_tick(const char* value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_analyze_info.date_tick)
}
inline void user_analyze_info::set_date_tick(const void* value, size_t size) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_analyze_info.date_tick)
}
inline ::std::string* user_analyze_info::mutable_date_tick() {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_analyze_info.date_tick)
  return date_tick_;
}
inline ::std::string* user_analyze_info::release_date_tick() {
  clear_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_tick_;
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_analyze_info::set_allocated_date_tick(::std::string* date_tick) {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_tick_;
  }
  if (date_tick) {
    set_has_date_tick();
    date_tick_ = date_tick;
  } else {
    clear_has_date_tick();
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_analyze_info.date_tick)
}

// -------------------------------------------------------------------

// user_freshness_info

// optional int32 new_add_user_count = 1;
inline bool user_freshness_info::has_new_add_user_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_freshness_info::set_has_new_add_user_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_freshness_info::clear_has_new_add_user_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_freshness_info::clear_new_add_user_count() {
  new_add_user_count_ = 0;
  clear_has_new_add_user_count();
}
inline ::google::protobuf::int32 user_freshness_info::new_add_user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_info.new_add_user_count)
  return new_add_user_count_;
}
inline void user_freshness_info::set_new_add_user_count(::google::protobuf::int32 value) {
  set_has_new_add_user_count();
  new_add_user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_info.new_add_user_count)
}

// optional int32 active_user_count = 2;
inline bool user_freshness_info::has_active_user_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_freshness_info::set_has_active_user_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_freshness_info::clear_has_active_user_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_freshness_info::clear_active_user_count() {
  active_user_count_ = 0;
  clear_has_active_user_count();
}
inline ::google::protobuf::int32 user_freshness_info::active_user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_info.active_user_count)
  return active_user_count_;
}
inline void user_freshness_info::set_active_user_count(::google::protobuf::int32 value) {
  set_has_active_user_count();
  active_user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_info.active_user_count)
}

// optional float new_add_count_rate = 3;
inline bool user_freshness_info::has_new_add_count_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_freshness_info::set_has_new_add_count_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_freshness_info::clear_has_new_add_count_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_freshness_info::clear_new_add_count_rate() {
  new_add_count_rate_ = 0;
  clear_has_new_add_count_rate();
}
inline float user_freshness_info::new_add_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_info.new_add_count_rate)
  return new_add_count_rate_;
}
inline void user_freshness_info::set_new_add_count_rate(float value) {
  set_has_new_add_count_rate();
  new_add_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_info.new_add_count_rate)
}

// optional bytes date_tick = 4;
inline bool user_freshness_info::has_date_tick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_freshness_info::set_has_date_tick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_freshness_info::clear_has_date_tick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_freshness_info::clear_date_tick() {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_->clear();
  }
  clear_has_date_tick();
}
inline const ::std::string& user_freshness_info::date_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_info.date_tick)
  return *date_tick_;
}
inline void user_freshness_info::set_date_tick(const ::std::string& value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_info.date_tick)
}
inline void user_freshness_info::set_date_tick(const char* value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_info.date_tick)
}
inline void user_freshness_info::set_date_tick(const void* value, size_t size) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_info.date_tick)
}
inline ::std::string* user_freshness_info::mutable_date_tick() {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_info.date_tick)
  return date_tick_;
}
inline ::std::string* user_freshness_info::release_date_tick() {
  clear_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_tick_;
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_info::set_allocated_date_tick(::std::string* date_tick) {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_tick_;
  }
  if (date_tick) {
    set_has_date_tick();
    date_tick_ = date_tick;
  } else {
    clear_has_date_tick();
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_info.date_tick)
}

// -------------------------------------------------------------------

// user_retain_rate_info

// optional float oneday = 1;
inline bool user_retain_rate_info::has_oneday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_retain_rate_info::set_has_oneday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_retain_rate_info::clear_has_oneday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_retain_rate_info::clear_oneday() {
  oneday_ = 0;
  clear_has_oneday();
}
inline float user_retain_rate_info::oneday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.oneday)
  return oneday_;
}
inline void user_retain_rate_info::set_oneday(float value) {
  set_has_oneday();
  oneday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.oneday)
}

// optional float twoday = 2;
inline bool user_retain_rate_info::has_twoday() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_retain_rate_info::set_has_twoday() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_retain_rate_info::clear_has_twoday() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_retain_rate_info::clear_twoday() {
  twoday_ = 0;
  clear_has_twoday();
}
inline float user_retain_rate_info::twoday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.twoday)
  return twoday_;
}
inline void user_retain_rate_info::set_twoday(float value) {
  set_has_twoday();
  twoday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.twoday)
}

// optional float threeday = 3;
inline bool user_retain_rate_info::has_threeday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_retain_rate_info::set_has_threeday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_retain_rate_info::clear_has_threeday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_retain_rate_info::clear_threeday() {
  threeday_ = 0;
  clear_has_threeday();
}
inline float user_retain_rate_info::threeday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.threeday)
  return threeday_;
}
inline void user_retain_rate_info::set_threeday(float value) {
  set_has_threeday();
  threeday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.threeday)
}

// optional float fourday = 4;
inline bool user_retain_rate_info::has_fourday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_retain_rate_info::set_has_fourday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_retain_rate_info::clear_has_fourday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_retain_rate_info::clear_fourday() {
  fourday_ = 0;
  clear_has_fourday();
}
inline float user_retain_rate_info::fourday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.fourday)
  return fourday_;
}
inline void user_retain_rate_info::set_fourday(float value) {
  set_has_fourday();
  fourday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.fourday)
}

// optional float fiveday = 5;
inline bool user_retain_rate_info::has_fiveday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_retain_rate_info::set_has_fiveday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_retain_rate_info::clear_has_fiveday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_retain_rate_info::clear_fiveday() {
  fiveday_ = 0;
  clear_has_fiveday();
}
inline float user_retain_rate_info::fiveday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.fiveday)
  return fiveday_;
}
inline void user_retain_rate_info::set_fiveday(float value) {
  set_has_fiveday();
  fiveday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.fiveday)
}

// optional float sixday = 6;
inline bool user_retain_rate_info::has_sixday() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_retain_rate_info::set_has_sixday() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_retain_rate_info::clear_has_sixday() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_retain_rate_info::clear_sixday() {
  sixday_ = 0;
  clear_has_sixday();
}
inline float user_retain_rate_info::sixday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.sixday)
  return sixday_;
}
inline void user_retain_rate_info::set_sixday(float value) {
  set_has_sixday();
  sixday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.sixday)
}

// optional float sevenday = 7;
inline bool user_retain_rate_info::has_sevenday() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_retain_rate_info::set_has_sevenday() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_retain_rate_info::clear_has_sevenday() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_retain_rate_info::clear_sevenday() {
  sevenday_ = 0;
  clear_has_sevenday();
}
inline float user_retain_rate_info::sevenday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.sevenday)
  return sevenday_;
}
inline void user_retain_rate_info::set_sevenday(float value) {
  set_has_sevenday();
  sevenday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.sevenday)
}

// optional float fourteenday = 14;
inline bool user_retain_rate_info::has_fourteenday() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_retain_rate_info::set_has_fourteenday() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_retain_rate_info::clear_has_fourteenday() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_retain_rate_info::clear_fourteenday() {
  fourteenday_ = 0;
  clear_has_fourteenday();
}
inline float user_retain_rate_info::fourteenday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.fourteenday)
  return fourteenday_;
}
inline void user_retain_rate_info::set_fourteenday(float value) {
  set_has_fourteenday();
  fourteenday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.fourteenday)
}

// optional float thirtyday = 30;
inline bool user_retain_rate_info::has_thirtyday() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_retain_rate_info::set_has_thirtyday() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_retain_rate_info::clear_has_thirtyday() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_retain_rate_info::clear_thirtyday() {
  thirtyday_ = 0;
  clear_has_thirtyday();
}
inline float user_retain_rate_info::thirtyday() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_rate_info.thirtyday)
  return thirtyday_;
}
inline void user_retain_rate_info::set_thirtyday(float value) {
  set_has_thirtyday();
  thirtyday_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_rate_info.thirtyday)
}

// -------------------------------------------------------------------

// user_retain_info

// optional int32 new_add_user = 1;
inline bool user_retain_info::has_new_add_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_retain_info::set_has_new_add_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_retain_info::clear_has_new_add_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_retain_info::clear_new_add_user() {
  new_add_user_ = 0;
  clear_has_new_add_user();
}
inline ::google::protobuf::int32 user_retain_info::new_add_user() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_info.new_add_user)
  return new_add_user_;
}
inline void user_retain_info::set_new_add_user(::google::protobuf::int32 value) {
  set_has_new_add_user();
  new_add_user_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_info.new_add_user)
}

// optional .ODP_main_frame.user_retain_rate_info user_retain_rate = 2;
inline bool user_retain_info::has_user_retain_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_retain_info::set_has_user_retain_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_retain_info::clear_has_user_retain_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_retain_info::clear_user_retain_rate() {
  if (user_retain_rate_ != NULL) user_retain_rate_->::ODP_main_frame::user_retain_rate_info::Clear();
  clear_has_user_retain_rate();
}
inline const ::ODP_main_frame::user_retain_rate_info& user_retain_info::user_retain_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_info.user_retain_rate)
  return user_retain_rate_ != NULL ? *user_retain_rate_ : *default_instance_->user_retain_rate_;
}
inline ::ODP_main_frame::user_retain_rate_info* user_retain_info::mutable_user_retain_rate() {
  set_has_user_retain_rate();
  if (user_retain_rate_ == NULL) user_retain_rate_ = new ::ODP_main_frame::user_retain_rate_info;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_info.user_retain_rate)
  return user_retain_rate_;
}
inline ::ODP_main_frame::user_retain_rate_info* user_retain_info::release_user_retain_rate() {
  clear_has_user_retain_rate();
  ::ODP_main_frame::user_retain_rate_info* temp = user_retain_rate_;
  user_retain_rate_ = NULL;
  return temp;
}
inline void user_retain_info::set_allocated_user_retain_rate(::ODP_main_frame::user_retain_rate_info* user_retain_rate) {
  delete user_retain_rate_;
  user_retain_rate_ = user_retain_rate;
  if (user_retain_rate) {
    set_has_user_retain_rate();
  } else {
    clear_has_user_retain_rate();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_info.user_retain_rate)
}

// optional bytes first_use_date = 3;
inline bool user_retain_info::has_first_use_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_retain_info::set_has_first_use_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_retain_info::clear_has_first_use_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_retain_info::clear_first_use_date() {
  if (first_use_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_use_date_->clear();
  }
  clear_has_first_use_date();
}
inline const ::std::string& user_retain_info::first_use_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_info.first_use_date)
  return *first_use_date_;
}
inline void user_retain_info::set_first_use_date(const ::std::string& value) {
  set_has_first_use_date();
  if (first_use_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_use_date_ = new ::std::string;
  }
  first_use_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_info.first_use_date)
}
inline void user_retain_info::set_first_use_date(const char* value) {
  set_has_first_use_date();
  if (first_use_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_use_date_ = new ::std::string;
  }
  first_use_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_retain_info.first_use_date)
}
inline void user_retain_info::set_first_use_date(const void* value, size_t size) {
  set_has_first_use_date();
  if (first_use_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_use_date_ = new ::std::string;
  }
  first_use_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_retain_info.first_use_date)
}
inline ::std::string* user_retain_info::mutable_first_use_date() {
  set_has_first_use_date();
  if (first_use_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_use_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_info.first_use_date)
  return first_use_date_;
}
inline ::std::string* user_retain_info::release_first_use_date() {
  clear_has_first_use_date();
  if (first_use_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = first_use_date_;
    first_use_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_retain_info::set_allocated_first_use_date(::std::string* first_use_date) {
  if (first_use_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete first_use_date_;
  }
  if (first_use_date) {
    set_has_first_use_date();
    first_use_date_ = first_use_date;
  } else {
    clear_has_first_use_date();
    first_use_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_info.first_use_date)
}

// -------------------------------------------------------------------

// app_version_statistics

// optional bytes app_version = 1;
inline bool app_version_statistics::has_app_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_version_statistics::set_has_app_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_version_statistics::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_version_statistics::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& app_version_statistics::app_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.app_version)
  return *app_version_;
}
inline void app_version_statistics::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.app_version)
}
inline void app_version_statistics::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.app_version_statistics.app_version)
}
inline void app_version_statistics::set_app_version(const void* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.app_version_statistics.app_version)
}
inline ::std::string* app_version_statistics::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.app_version_statistics.app_version)
  return app_version_;
}
inline ::std::string* app_version_statistics::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void app_version_statistics::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.app_version_statistics.app_version)
}

// optional int32 total_user_acount = 2;
inline bool app_version_statistics::has_total_user_acount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_version_statistics::set_has_total_user_acount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_version_statistics::clear_has_total_user_acount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_version_statistics::clear_total_user_acount() {
  total_user_acount_ = 0;
  clear_has_total_user_acount();
}
inline ::google::protobuf::int32 app_version_statistics::total_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.total_user_acount)
  return total_user_acount_;
}
inline void app_version_statistics::set_total_user_acount(::google::protobuf::int32 value) {
  set_has_total_user_acount();
  total_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.total_user_acount)
}

// optional float total_user_rate = 3;
inline bool app_version_statistics::has_total_user_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void app_version_statistics::set_has_total_user_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void app_version_statistics::clear_has_total_user_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void app_version_statistics::clear_total_user_rate() {
  total_user_rate_ = 0;
  clear_has_total_user_rate();
}
inline float app_version_statistics::total_user_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.total_user_rate)
  return total_user_rate_;
}
inline void app_version_statistics::set_total_user_rate(float value) {
  set_has_total_user_rate();
  total_user_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.total_user_rate)
}

// optional int32 new_add_user_acount = 4;
inline bool app_version_statistics::has_new_add_user_acount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void app_version_statistics::set_has_new_add_user_acount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void app_version_statistics::clear_has_new_add_user_acount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void app_version_statistics::clear_new_add_user_acount() {
  new_add_user_acount_ = 0;
  clear_has_new_add_user_acount();
}
inline ::google::protobuf::int32 app_version_statistics::new_add_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.new_add_user_acount)
  return new_add_user_acount_;
}
inline void app_version_statistics::set_new_add_user_acount(::google::protobuf::int32 value) {
  set_has_new_add_user_acount();
  new_add_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.new_add_user_acount)
}

// optional float new_add_user_rate = 5;
inline bool app_version_statistics::has_new_add_user_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void app_version_statistics::set_has_new_add_user_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void app_version_statistics::clear_has_new_add_user_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void app_version_statistics::clear_new_add_user_rate() {
  new_add_user_rate_ = 0;
  clear_has_new_add_user_rate();
}
inline float app_version_statistics::new_add_user_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.new_add_user_rate)
  return new_add_user_rate_;
}
inline void app_version_statistics::set_new_add_user_rate(float value) {
  set_has_new_add_user_rate();
  new_add_user_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.new_add_user_rate)
}

// optional int32 upgrade_user_acount = 6;
inline bool app_version_statistics::has_upgrade_user_acount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void app_version_statistics::set_has_upgrade_user_acount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void app_version_statistics::clear_has_upgrade_user_acount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void app_version_statistics::clear_upgrade_user_acount() {
  upgrade_user_acount_ = 0;
  clear_has_upgrade_user_acount();
}
inline ::google::protobuf::int32 app_version_statistics::upgrade_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.upgrade_user_acount)
  return upgrade_user_acount_;
}
inline void app_version_statistics::set_upgrade_user_acount(::google::protobuf::int32 value) {
  set_has_upgrade_user_acount();
  upgrade_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.upgrade_user_acount)
}

// optional float upgrade_user_rate = 7;
inline bool app_version_statistics::has_upgrade_user_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void app_version_statistics::set_has_upgrade_user_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void app_version_statistics::clear_has_upgrade_user_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void app_version_statistics::clear_upgrade_user_rate() {
  upgrade_user_rate_ = 0;
  clear_has_upgrade_user_rate();
}
inline float app_version_statistics::upgrade_user_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.upgrade_user_rate)
  return upgrade_user_rate_;
}
inline void app_version_statistics::set_upgrade_user_rate(float value) {
  set_has_upgrade_user_rate();
  upgrade_user_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.upgrade_user_rate)
}

// optional int32 new_upgrade_user_acount = 8;
inline bool app_version_statistics::has_new_upgrade_user_acount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void app_version_statistics::set_has_new_upgrade_user_acount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void app_version_statistics::clear_has_new_upgrade_user_acount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void app_version_statistics::clear_new_upgrade_user_acount() {
  new_upgrade_user_acount_ = 0;
  clear_has_new_upgrade_user_acount();
}
inline ::google::protobuf::int32 app_version_statistics::new_upgrade_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.new_upgrade_user_acount)
  return new_upgrade_user_acount_;
}
inline void app_version_statistics::set_new_upgrade_user_acount(::google::protobuf::int32 value) {
  set_has_new_upgrade_user_acount();
  new_upgrade_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.new_upgrade_user_acount)
}

// optional float new_upgrade_user_rate = 9;
inline bool app_version_statistics::has_new_upgrade_user_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void app_version_statistics::set_has_new_upgrade_user_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void app_version_statistics::clear_has_new_upgrade_user_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void app_version_statistics::clear_new_upgrade_user_rate() {
  new_upgrade_user_rate_ = 0;
  clear_has_new_upgrade_user_rate();
}
inline float app_version_statistics::new_upgrade_user_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.new_upgrade_user_rate)
  return new_upgrade_user_rate_;
}
inline void app_version_statistics::set_new_upgrade_user_rate(float value) {
  set_has_new_upgrade_user_rate();
  new_upgrade_user_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.new_upgrade_user_rate)
}

// optional int32 active_user_acount = 10;
inline bool app_version_statistics::has_active_user_acount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void app_version_statistics::set_has_active_user_acount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void app_version_statistics::clear_has_active_user_acount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void app_version_statistics::clear_active_user_acount() {
  active_user_acount_ = 0;
  clear_has_active_user_acount();
}
inline ::google::protobuf::int32 app_version_statistics::active_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.active_user_acount)
  return active_user_acount_;
}
inline void app_version_statistics::set_active_user_acount(::google::protobuf::int32 value) {
  set_has_active_user_acount();
  active_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.active_user_acount)
}

// optional float active_user_rate = 11;
inline bool app_version_statistics::has_active_user_rate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void app_version_statistics::set_has_active_user_rate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void app_version_statistics::clear_has_active_user_rate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void app_version_statistics::clear_active_user_rate() {
  active_user_rate_ = 0;
  clear_has_active_user_rate();
}
inline float app_version_statistics::active_user_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.active_user_rate)
  return active_user_rate_;
}
inline void app_version_statistics::set_active_user_rate(float value) {
  set_has_active_user_rate();
  active_user_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.active_user_rate)
}

// optional int32 start_acount = 12;
inline bool app_version_statistics::has_start_acount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void app_version_statistics::set_has_start_acount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void app_version_statistics::clear_has_start_acount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void app_version_statistics::clear_start_acount() {
  start_acount_ = 0;
  clear_has_start_acount();
}
inline ::google::protobuf::int32 app_version_statistics::start_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.start_acount)
  return start_acount_;
}
inline void app_version_statistics::set_start_acount(::google::protobuf::int32 value) {
  set_has_start_acount();
  start_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.start_acount)
}

// optional float start_acount_rate = 13;
inline bool app_version_statistics::has_start_acount_rate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void app_version_statistics::set_has_start_acount_rate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void app_version_statistics::clear_has_start_acount_rate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void app_version_statistics::clear_start_acount_rate() {
  start_acount_rate_ = 0;
  clear_has_start_acount_rate();
}
inline float app_version_statistics::start_acount_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_statistics.start_acount_rate)
  return start_acount_rate_;
}
inline void app_version_statistics::set_start_acount_rate(float value) {
  set_has_start_acount_rate();
  start_acount_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_statistics.start_acount_rate)
}

// -------------------------------------------------------------------

// app_version_detail

// optional bytes date_tick = 1;
inline bool app_version_detail::has_date_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void app_version_detail::set_has_date_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void app_version_detail::clear_has_date_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void app_version_detail::clear_date_tick() {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_->clear();
  }
  clear_has_date_tick();
}
inline const ::std::string& app_version_detail::date_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.date_tick)
  return *date_tick_;
}
inline void app_version_detail::set_date_tick(const ::std::string& value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.date_tick)
}
inline void app_version_detail::set_date_tick(const char* value) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.app_version_detail.date_tick)
}
inline void app_version_detail::set_date_tick(const void* value, size_t size) {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  date_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.app_version_detail.date_tick)
}
inline ::std::string* app_version_detail::mutable_date_tick() {
  set_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.app_version_detail.date_tick)
  return date_tick_;
}
inline ::std::string* app_version_detail::release_date_tick() {
  clear_has_date_tick();
  if (date_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_tick_;
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void app_version_detail::set_allocated_date_tick(::std::string* date_tick) {
  if (date_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_tick_;
  }
  if (date_tick) {
    set_has_date_tick();
    date_tick_ = date_tick;
  } else {
    clear_has_date_tick();
    date_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.app_version_detail.date_tick)
}

// optional int32 new_add_user_acount = 2;
inline bool app_version_detail::has_new_add_user_acount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void app_version_detail::set_has_new_add_user_acount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void app_version_detail::clear_has_new_add_user_acount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void app_version_detail::clear_new_add_user_acount() {
  new_add_user_acount_ = 0;
  clear_has_new_add_user_acount();
}
inline ::google::protobuf::int32 app_version_detail::new_add_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.new_add_user_acount)
  return new_add_user_acount_;
}
inline void app_version_detail::set_new_add_user_acount(::google::protobuf::int32 value) {
  set_has_new_add_user_acount();
  new_add_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.new_add_user_acount)
}

// optional int32 upgrade_user_acount = 3;
inline bool app_version_detail::has_upgrade_user_acount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void app_version_detail::set_has_upgrade_user_acount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void app_version_detail::clear_has_upgrade_user_acount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void app_version_detail::clear_upgrade_user_acount() {
  upgrade_user_acount_ = 0;
  clear_has_upgrade_user_acount();
}
inline ::google::protobuf::int32 app_version_detail::upgrade_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.upgrade_user_acount)
  return upgrade_user_acount_;
}
inline void app_version_detail::set_upgrade_user_acount(::google::protobuf::int32 value) {
  set_has_upgrade_user_acount();
  upgrade_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.upgrade_user_acount)
}

// optional int32 active_user_acount = 4;
inline bool app_version_detail::has_active_user_acount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void app_version_detail::set_has_active_user_acount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void app_version_detail::clear_has_active_user_acount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void app_version_detail::clear_active_user_acount() {
  active_user_acount_ = 0;
  clear_has_active_user_acount();
}
inline ::google::protobuf::int32 app_version_detail::active_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.active_user_acount)
  return active_user_acount_;
}
inline void app_version_detail::set_active_user_acount(::google::protobuf::int32 value) {
  set_has_active_user_acount();
  active_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.active_user_acount)
}

// optional int32 acumulate_user_acount = 5;
inline bool app_version_detail::has_acumulate_user_acount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void app_version_detail::set_has_acumulate_user_acount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void app_version_detail::clear_has_acumulate_user_acount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void app_version_detail::clear_acumulate_user_acount() {
  acumulate_user_acount_ = 0;
  clear_has_acumulate_user_acount();
}
inline ::google::protobuf::int32 app_version_detail::acumulate_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.acumulate_user_acount)
  return acumulate_user_acount_;
}
inline void app_version_detail::set_acumulate_user_acount(::google::protobuf::int32 value) {
  set_has_acumulate_user_acount();
  acumulate_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.acumulate_user_acount)
}

// optional int32 start_acount = 6;
inline bool app_version_detail::has_start_acount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void app_version_detail::set_has_start_acount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void app_version_detail::clear_has_start_acount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void app_version_detail::clear_start_acount() {
  start_acount_ = 0;
  clear_has_start_acount();
}
inline ::google::protobuf::int32 app_version_detail::start_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.app_version_detail.start_acount)
  return start_acount_;
}
inline void app_version_detail::set_start_acount(::google::protobuf::int32 value) {
  set_has_start_acount();
  start_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.app_version_detail.start_acount)
}

// -------------------------------------------------------------------

// download_src_user_acount_info

// optional bytes src_name = 1;
inline bool download_src_user_acount_info::has_src_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void download_src_user_acount_info::set_has_src_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void download_src_user_acount_info::clear_has_src_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void download_src_user_acount_info::clear_src_name() {
  if (src_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_->clear();
  }
  clear_has_src_name();
}
inline const ::std::string& download_src_user_acount_info::src_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_user_acount_info.src_name)
  return *src_name_;
}
inline void download_src_user_acount_info::set_src_name(const ::std::string& value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_user_acount_info.src_name)
}
inline void download_src_user_acount_info::set_src_name(const char* value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_user_acount_info.src_name)
}
inline void download_src_user_acount_info::set_src_name(const void* value, size_t size) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_user_acount_info.src_name)
}
inline ::std::string* download_src_user_acount_info::mutable_src_name() {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_user_acount_info.src_name)
  return src_name_;
}
inline ::std::string* download_src_user_acount_info::release_src_name() {
  clear_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = src_name_;
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_user_acount_info::set_allocated_src_name(::std::string* src_name) {
  if (src_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete src_name_;
  }
  if (src_name) {
    set_has_src_name();
    src_name_ = src_name;
  } else {
    clear_has_src_name();
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_user_acount_info.src_name)
}

// repeated .ODP_main_frame.user_acount_info info = 2;
inline int download_src_user_acount_info::info_size() const {
  return info_.size();
}
inline void download_src_user_acount_info::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_acount_info& download_src_user_acount_info::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_user_acount_info.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_acount_info* download_src_user_acount_info::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_user_acount_info.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_acount_info* download_src_user_acount_info::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.download_src_user_acount_info.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
download_src_user_acount_info::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.download_src_user_acount_info.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
download_src_user_acount_info::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.download_src_user_acount_info.info)
  return &info_;
}

// -------------------------------------------------------------------

// download_src_detail

// optional bytes src_name = 1;
inline bool download_src_detail::has_src_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void download_src_detail::set_has_src_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void download_src_detail::clear_has_src_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void download_src_detail::clear_src_name() {
  if (src_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_->clear();
  }
  clear_has_src_name();
}
inline const ::std::string& download_src_detail::src_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.src_name)
  return *src_name_;
}
inline void download_src_detail::set_src_name(const ::std::string& value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.src_name)
}
inline void download_src_detail::set_src_name(const char* value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_detail.src_name)
}
inline void download_src_detail::set_src_name(const void* value, size_t size) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_detail.src_name)
}
inline ::std::string* download_src_detail::mutable_src_name() {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_detail.src_name)
  return src_name_;
}
inline ::std::string* download_src_detail::release_src_name() {
  clear_has_src_name();
  if (src_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = src_name_;
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_detail::set_allocated_src_name(::std::string* src_name) {
  if (src_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete src_name_;
  }
  if (src_name) {
    set_has_src_name();
    src_name_ = src_name;
  } else {
    clear_has_src_name();
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_detail.src_name)
}

// optional int32 new_add_user_acount = 2;
inline bool download_src_detail::has_new_add_user_acount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void download_src_detail::set_has_new_add_user_acount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void download_src_detail::clear_has_new_add_user_acount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void download_src_detail::clear_new_add_user_acount() {
  new_add_user_acount_ = 0;
  clear_has_new_add_user_acount();
}
inline ::google::protobuf::int32 download_src_detail::new_add_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.new_add_user_acount)
  return new_add_user_acount_;
}
inline void download_src_detail::set_new_add_user_acount(::google::protobuf::int32 value) {
  set_has_new_add_user_acount();
  new_add_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.new_add_user_acount)
}

// optional float new_add_user_acount_rate = 3;
inline bool download_src_detail::has_new_add_user_acount_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void download_src_detail::set_has_new_add_user_acount_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void download_src_detail::clear_has_new_add_user_acount_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void download_src_detail::clear_new_add_user_acount_rate() {
  new_add_user_acount_rate_ = 0;
  clear_has_new_add_user_acount_rate();
}
inline float download_src_detail::new_add_user_acount_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.new_add_user_acount_rate)
  return new_add_user_acount_rate_;
}
inline void download_src_detail::set_new_add_user_acount_rate(float value) {
  set_has_new_add_user_acount_rate();
  new_add_user_acount_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.new_add_user_acount_rate)
}

// optional int32 active_user_acount = 4;
inline bool download_src_detail::has_active_user_acount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void download_src_detail::set_has_active_user_acount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void download_src_detail::clear_has_active_user_acount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void download_src_detail::clear_active_user_acount() {
  active_user_acount_ = 0;
  clear_has_active_user_acount();
}
inline ::google::protobuf::int32 download_src_detail::active_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.active_user_acount)
  return active_user_acount_;
}
inline void download_src_detail::set_active_user_acount(::google::protobuf::int32 value) {
  set_has_active_user_acount();
  active_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.active_user_acount)
}

// optional float active_user_acount_rate = 5;
inline bool download_src_detail::has_active_user_acount_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void download_src_detail::set_has_active_user_acount_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void download_src_detail::clear_has_active_user_acount_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void download_src_detail::clear_active_user_acount_rate() {
  active_user_acount_rate_ = 0;
  clear_has_active_user_acount_rate();
}
inline float download_src_detail::active_user_acount_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.active_user_acount_rate)
  return active_user_acount_rate_;
}
inline void download_src_detail::set_active_user_acount_rate(float value) {
  set_has_active_user_acount_rate();
  active_user_acount_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.active_user_acount_rate)
}

// optional int32 total_user_acount = 6;
inline bool download_src_detail::has_total_user_acount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void download_src_detail::set_has_total_user_acount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void download_src_detail::clear_has_total_user_acount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void download_src_detail::clear_total_user_acount() {
  total_user_acount_ = 0;
  clear_has_total_user_acount();
}
inline ::google::protobuf::int32 download_src_detail::total_user_acount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.total_user_acount)
  return total_user_acount_;
}
inline void download_src_detail::set_total_user_acount(::google::protobuf::int32 value) {
  set_has_total_user_acount();
  total_user_acount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.total_user_acount)
}

// optional float total_user_acount_rate = 7;
inline bool download_src_detail::has_total_user_acount_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void download_src_detail::set_has_total_user_acount_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void download_src_detail::clear_has_total_user_acount_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void download_src_detail::clear_total_user_acount_rate() {
  total_user_acount_rate_ = 0;
  clear_has_total_user_acount_rate();
}
inline float download_src_detail::total_user_acount_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_detail.total_user_acount_rate)
  return total_user_acount_rate_;
}
inline void download_src_detail::set_total_user_acount_rate(float value) {
  set_has_total_user_acount_rate();
  total_user_acount_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_detail.total_user_acount_rate)
}

// -------------------------------------------------------------------

// use_time_info

// optional bytes time_tick = 1;
inline bool use_time_info::has_time_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_time_info::set_has_time_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_time_info::clear_has_time_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_time_info::clear_time_tick() {
  if (time_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_tick_->clear();
  }
  clear_has_time_tick();
}
inline const ::std::string& use_time_info::time_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_info.time_tick)
  return *time_tick_;
}
inline void use_time_info::set_time_tick(const ::std::string& value) {
  set_has_time_tick();
  if (time_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_tick_ = new ::std::string;
  }
  time_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_info.time_tick)
}
inline void use_time_info::set_time_tick(const char* value) {
  set_has_time_tick();
  if (time_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_tick_ = new ::std::string;
  }
  time_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_time_info.time_tick)
}
inline void use_time_info::set_time_tick(const void* value, size_t size) {
  set_has_time_tick();
  if (time_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_tick_ = new ::std::string;
  }
  time_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_time_info.time_tick)
}
inline ::std::string* use_time_info::mutable_time_tick() {
  set_has_time_tick();
  if (time_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_info.time_tick)
  return time_tick_;
}
inline ::std::string* use_time_info::release_time_tick() {
  clear_has_time_tick();
  if (time_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_tick_;
    time_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_time_info::set_allocated_time_tick(::std::string* time_tick) {
  if (time_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_tick_;
  }
  if (time_tick) {
    set_has_time_tick();
    time_tick_ = time_tick;
  } else {
    clear_has_time_tick();
    time_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_time_info.time_tick)
}

// optional int32 start_count = 2;
inline bool use_time_info::has_start_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_time_info::set_has_start_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_time_info::clear_has_start_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_time_info::clear_start_count() {
  start_count_ = 0;
  clear_has_start_count();
}
inline ::google::protobuf::int32 use_time_info::start_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_info.start_count)
  return start_count_;
}
inline void use_time_info::set_start_count(::google::protobuf::int32 value) {
  set_has_start_count();
  start_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_info.start_count)
}

// optional float start_rate = 3;
inline bool use_time_info::has_start_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_time_info::set_has_start_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_time_info::clear_has_start_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_time_info::clear_start_rate() {
  start_rate_ = 0;
  clear_has_start_rate();
}
inline float use_time_info::start_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_info.start_rate)
  return start_rate_;
}
inline void use_time_info::set_start_rate(float value) {
  set_has_start_rate();
  start_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_info.start_rate)
}

// -------------------------------------------------------------------

// use_count_info

// optional bytes count_tick = 1;
inline bool use_count_info::has_count_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_count_info::set_has_count_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_count_info::clear_has_count_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_count_info::clear_count_tick() {
  if (count_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    count_tick_->clear();
  }
  clear_has_count_tick();
}
inline const ::std::string& use_count_info::count_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_info.count_tick)
  return *count_tick_;
}
inline void use_count_info::set_count_tick(const ::std::string& value) {
  set_has_count_tick();
  if (count_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    count_tick_ = new ::std::string;
  }
  count_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_info.count_tick)
}
inline void use_count_info::set_count_tick(const char* value) {
  set_has_count_tick();
  if (count_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    count_tick_ = new ::std::string;
  }
  count_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_count_info.count_tick)
}
inline void use_count_info::set_count_tick(const void* value, size_t size) {
  set_has_count_tick();
  if (count_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    count_tick_ = new ::std::string;
  }
  count_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_count_info.count_tick)
}
inline ::std::string* use_count_info::mutable_count_tick() {
  set_has_count_tick();
  if (count_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    count_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_info.count_tick)
  return count_tick_;
}
inline ::std::string* use_count_info::release_count_tick() {
  clear_has_count_tick();
  if (count_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = count_tick_;
    count_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_count_info::set_allocated_count_tick(::std::string* count_tick) {
  if (count_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete count_tick_;
  }
  if (count_tick) {
    set_has_count_tick();
    count_tick_ = count_tick;
  } else {
    clear_has_count_tick();
    count_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_count_info.count_tick)
}

// optional int32 user_count = 2;
inline bool use_count_info::has_user_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_count_info::set_has_user_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_count_info::clear_has_user_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_count_info::clear_user_count() {
  user_count_ = 0;
  clear_has_user_count();
}
inline ::google::protobuf::int32 use_count_info::user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_info.user_count)
  return user_count_;
}
inline void use_count_info::set_user_count(::google::protobuf::int32 value) {
  set_has_user_count();
  user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_info.user_count)
}

// optional float user_count_rate = 3;
inline bool use_count_info::has_user_count_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_count_info::set_has_user_count_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_count_info::clear_has_user_count_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_count_info::clear_user_count_rate() {
  user_count_rate_ = 0;
  clear_has_user_count_rate();
}
inline float use_count_info::user_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_info.user_count_rate)
  return user_count_rate_;
}
inline void use_count_info::set_user_count_rate(float value) {
  set_has_user_count_rate();
  user_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_info.user_count_rate)
}

// -------------------------------------------------------------------

// use_interval_info

// optional bytes interval_tick = 1;
inline bool use_interval_info::has_interval_tick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_interval_info::set_has_interval_tick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_interval_info::clear_has_interval_tick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_interval_info::clear_interval_tick() {
  if (interval_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interval_tick_->clear();
  }
  clear_has_interval_tick();
}
inline const ::std::string& use_interval_info::interval_tick() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_info.interval_tick)
  return *interval_tick_;
}
inline void use_interval_info::set_interval_tick(const ::std::string& value) {
  set_has_interval_tick();
  if (interval_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interval_tick_ = new ::std::string;
  }
  interval_tick_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_interval_info.interval_tick)
}
inline void use_interval_info::set_interval_tick(const char* value) {
  set_has_interval_tick();
  if (interval_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interval_tick_ = new ::std::string;
  }
  interval_tick_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_interval_info.interval_tick)
}
inline void use_interval_info::set_interval_tick(const void* value, size_t size) {
  set_has_interval_tick();
  if (interval_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interval_tick_ = new ::std::string;
  }
  interval_tick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_interval_info.interval_tick)
}
inline ::std::string* use_interval_info::mutable_interval_tick() {
  set_has_interval_tick();
  if (interval_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interval_tick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_info.interval_tick)
  return interval_tick_;
}
inline ::std::string* use_interval_info::release_interval_tick() {
  clear_has_interval_tick();
  if (interval_tick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interval_tick_;
    interval_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_interval_info::set_allocated_interval_tick(::std::string* interval_tick) {
  if (interval_tick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interval_tick_;
  }
  if (interval_tick) {
    set_has_interval_tick();
    interval_tick_ = interval_tick;
  } else {
    clear_has_interval_tick();
    interval_tick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_interval_info.interval_tick)
}

// optional int32 start_count = 2;
inline bool use_interval_info::has_start_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_interval_info::set_has_start_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_interval_info::clear_has_start_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_interval_info::clear_start_count() {
  start_count_ = 0;
  clear_has_start_count();
}
inline ::google::protobuf::int32 use_interval_info::start_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_info.start_count)
  return start_count_;
}
inline void use_interval_info::set_start_count(::google::protobuf::int32 value) {
  set_has_start_count();
  start_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_interval_info.start_count)
}

// optional float start_count_rate = 3;
inline bool use_interval_info::has_start_count_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_interval_info::set_has_start_count_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_interval_info::clear_has_start_count_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_interval_info::clear_start_count_rate() {
  start_count_rate_ = 0;
  clear_has_start_count_rate();
}
inline float use_interval_info::start_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_info.start_count_rate)
  return start_count_rate_;
}
inline void use_interval_info::set_start_count_rate(float value) {
  set_has_start_count_rate();
  start_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_interval_info.start_count_rate)
}

// -------------------------------------------------------------------

// third_party_login_info

// optional bytes platform_name = 1;
inline bool third_party_login_info::has_platform_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void third_party_login_info::set_has_platform_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void third_party_login_info::clear_has_platform_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void third_party_login_info::clear_platform_name() {
  if (platform_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_name_->clear();
  }
  clear_has_platform_name();
}
inline const ::std::string& third_party_login_info::platform_name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_info.platform_name)
  return *platform_name_;
}
inline void third_party_login_info::set_platform_name(const ::std::string& value) {
  set_has_platform_name();
  if (platform_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_name_ = new ::std::string;
  }
  platform_name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_info.platform_name)
}
inline void third_party_login_info::set_platform_name(const char* value) {
  set_has_platform_name();
  if (platform_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_name_ = new ::std::string;
  }
  platform_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_info.platform_name)
}
inline void third_party_login_info::set_platform_name(const void* value, size_t size) {
  set_has_platform_name();
  if (platform_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_name_ = new ::std::string;
  }
  platform_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_info.platform_name)
}
inline ::std::string* third_party_login_info::mutable_platform_name() {
  set_has_platform_name();
  if (platform_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_info.platform_name)
  return platform_name_;
}
inline ::std::string* third_party_login_info::release_platform_name() {
  clear_has_platform_name();
  if (platform_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platform_name_;
    platform_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_info::set_allocated_platform_name(::std::string* platform_name) {
  if (platform_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platform_name_;
  }
  if (platform_name) {
    set_has_platform_name();
    platform_name_ = platform_name;
  } else {
    clear_has_platform_name();
    platform_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_info.platform_name)
}

// optional int32 new_add_user_count = 2;
inline bool third_party_login_info::has_new_add_user_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void third_party_login_info::set_has_new_add_user_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void third_party_login_info::clear_has_new_add_user_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void third_party_login_info::clear_new_add_user_count() {
  new_add_user_count_ = 0;
  clear_has_new_add_user_count();
}
inline ::google::protobuf::int32 third_party_login_info::new_add_user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_info.new_add_user_count)
  return new_add_user_count_;
}
inline void third_party_login_info::set_new_add_user_count(::google::protobuf::int32 value) {
  set_has_new_add_user_count();
  new_add_user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_info.new_add_user_count)
}

// optional float new_add_user_count_rate = 3;
inline bool third_party_login_info::has_new_add_user_count_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void third_party_login_info::set_has_new_add_user_count_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void third_party_login_info::clear_has_new_add_user_count_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void third_party_login_info::clear_new_add_user_count_rate() {
  new_add_user_count_rate_ = 0;
  clear_has_new_add_user_count_rate();
}
inline float third_party_login_info::new_add_user_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_info.new_add_user_count_rate)
  return new_add_user_count_rate_;
}
inline void third_party_login_info::set_new_add_user_count_rate(float value) {
  set_has_new_add_user_count_rate();
  new_add_user_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_info.new_add_user_count_rate)
}

// optional int32 total_user_count = 4;
inline bool third_party_login_info::has_total_user_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void third_party_login_info::set_has_total_user_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void third_party_login_info::clear_has_total_user_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void third_party_login_info::clear_total_user_count() {
  total_user_count_ = 0;
  clear_has_total_user_count();
}
inline ::google::protobuf::int32 third_party_login_info::total_user_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_info.total_user_count)
  return total_user_count_;
}
inline void third_party_login_info::set_total_user_count(::google::protobuf::int32 value) {
  set_has_total_user_count();
  total_user_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_info.total_user_count)
}

// optional float total_user_count_rate = 5;
inline bool third_party_login_info::has_total_user_count_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void third_party_login_info::set_has_total_user_count_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void third_party_login_info::clear_has_total_user_count_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void third_party_login_info::clear_total_user_count_rate() {
  total_user_count_rate_ = 0;
  clear_has_total_user_count_rate();
}
inline float third_party_login_info::total_user_count_rate() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_info.total_user_count_rate)
  return total_user_count_rate_;
}
inline void third_party_login_info::set_total_user_count_rate(float value) {
  set_has_total_user_count_rate();
  total_user_count_rate_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_info.total_user_count_rate)
}

// -------------------------------------------------------------------

// Pay_Withdraw_ask

// optional bytes start_date = 1;
inline bool Pay_Withdraw_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pay_Withdraw_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pay_Withdraw_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pay_Withdraw_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& Pay_Withdraw_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw_ask.start_date)
  return *start_date_;
}
inline void Pay_Withdraw_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.Pay_Withdraw_ask.start_date)
}
inline void Pay_Withdraw_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.Pay_Withdraw_ask.start_date)
}
inline void Pay_Withdraw_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.Pay_Withdraw_ask.start_date)
}
inline ::std::string* Pay_Withdraw_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw_ask.start_date)
  return start_date_;
}
inline ::std::string* Pay_Withdraw_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pay_Withdraw_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Pay_Withdraw_ask.start_date)
}

// optional bytes end_date = 2;
inline bool Pay_Withdraw_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pay_Withdraw_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pay_Withdraw_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pay_Withdraw_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& Pay_Withdraw_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw_ask.end_date)
  return *end_date_;
}
inline void Pay_Withdraw_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.Pay_Withdraw_ask.end_date)
}
inline void Pay_Withdraw_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.Pay_Withdraw_ask.end_date)
}
inline void Pay_Withdraw_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.Pay_Withdraw_ask.end_date)
}
inline ::std::string* Pay_Withdraw_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw_ask.end_date)
  return end_date_;
}
inline ::std::string* Pay_Withdraw_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pay_Withdraw_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Pay_Withdraw_ask.end_date)
}

// optional .common.common_ask_header ask_header = 3;
inline bool Pay_Withdraw_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pay_Withdraw_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pay_Withdraw_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pay_Withdraw_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& Pay_Withdraw_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* Pay_Withdraw_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* Pay_Withdraw_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void Pay_Withdraw_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Pay_Withdraw_ask.ask_header)
}

// -------------------------------------------------------------------

// Pay_Withdraw_ans

// repeated .ODP_main_frame.Pay_Withdraw cur_pay_withdraw = 1;
inline int Pay_Withdraw_ans::cur_pay_withdraw_size() const {
  return cur_pay_withdraw_.size();
}
inline void Pay_Withdraw_ans::clear_cur_pay_withdraw() {
  cur_pay_withdraw_.Clear();
}
inline const ::ODP_main_frame::Pay_Withdraw& Pay_Withdraw_ans::cur_pay_withdraw(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw_ans.cur_pay_withdraw)
  return cur_pay_withdraw_.Get(index);
}
inline ::ODP_main_frame::Pay_Withdraw* Pay_Withdraw_ans::mutable_cur_pay_withdraw(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw_ans.cur_pay_withdraw)
  return cur_pay_withdraw_.Mutable(index);
}
inline ::ODP_main_frame::Pay_Withdraw* Pay_Withdraw_ans::add_cur_pay_withdraw() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.Pay_Withdraw_ans.cur_pay_withdraw)
  return cur_pay_withdraw_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::Pay_Withdraw >&
Pay_Withdraw_ans::cur_pay_withdraw() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.Pay_Withdraw_ans.cur_pay_withdraw)
  return cur_pay_withdraw_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::Pay_Withdraw >*
Pay_Withdraw_ans::mutable_cur_pay_withdraw() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.Pay_Withdraw_ans.cur_pay_withdraw)
  return &cur_pay_withdraw_;
}

// optional .common.errorinfo error = 2;
inline bool Pay_Withdraw_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pay_Withdraw_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pay_Withdraw_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pay_Withdraw_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& Pay_Withdraw_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Pay_Withdraw_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* Pay_Withdraw_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Pay_Withdraw_ans.error)
  return error_;
}
inline ::common::errorinfo* Pay_Withdraw_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Pay_Withdraw_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Pay_Withdraw_ans.error)
}

// -------------------------------------------------------------------

// unfinished_bid_ask

// optional int32 event = 1;
inline bool unfinished_bid_ask::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unfinished_bid_ask::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unfinished_bid_ask::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unfinished_bid_ask::clear_event() {
  event_ = 0;
  clear_has_event();
}
inline ::google::protobuf::int32 unfinished_bid_ask::event() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_ask.event)
  return event_;
}
inline void unfinished_bid_ask::set_event(::google::protobuf::int32 value) {
  set_has_event();
  event_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.unfinished_bid_ask.event)
}

// optional .common.common_ask_header ask_header = 2;
inline bool unfinished_bid_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unfinished_bid_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unfinished_bid_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unfinished_bid_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& unfinished_bid_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* unfinished_bid_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.unfinished_bid_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* unfinished_bid_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void unfinished_bid_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.unfinished_bid_ask.ask_header)
}

// -------------------------------------------------------------------

// unfinished_bid_ans

// repeated .ODP_main_frame.unfinished_bid_info info = 1;
inline int unfinished_bid_ans::info_size() const {
  return info_.size();
}
inline void unfinished_bid_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::unfinished_bid_info& unfinished_bid_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::unfinished_bid_info* unfinished_bid_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.unfinished_bid_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::unfinished_bid_info* unfinished_bid_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.unfinished_bid_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::unfinished_bid_info >&
unfinished_bid_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.unfinished_bid_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::unfinished_bid_info >*
unfinished_bid_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.unfinished_bid_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool unfinished_bid_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unfinished_bid_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unfinished_bid_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unfinished_bid_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& unfinished_bid_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.unfinished_bid_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* unfinished_bid_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.unfinished_bid_ans.error)
  return error_;
}
inline ::common::errorinfo* unfinished_bid_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void unfinished_bid_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.unfinished_bid_ans.error)
}

// -------------------------------------------------------------------

// city_bid_count_ask

// optional int32 bid_status = 1;
inline bool city_bid_count_ask::has_bid_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_bid_count_ask::set_has_bid_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_bid_count_ask::clear_has_bid_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_bid_count_ask::clear_bid_status() {
  bid_status_ = 0;
  clear_has_bid_status();
}
inline ::google::protobuf::int32 city_bid_count_ask::bid_status() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count_ask.bid_status)
  return bid_status_;
}
inline void city_bid_count_ask::set_bid_status(::google::protobuf::int32 value) {
  set_has_bid_status();
  bid_status_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.city_bid_count_ask.bid_status)
}

// optional .common.common_ask_header ask_header = 2;
inline bool city_bid_count_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_bid_count_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_bid_count_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_bid_count_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& city_bid_count_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* city_bid_count_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.city_bid_count_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* city_bid_count_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void city_bid_count_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.city_bid_count_ask.ask_header)
}

// -------------------------------------------------------------------

// city_bid_count_ans

// repeated .ODP_main_frame.city_bid_count count_info = 1;
inline int city_bid_count_ans::count_info_size() const {
  return count_info_.size();
}
inline void city_bid_count_ans::clear_count_info() {
  count_info_.Clear();
}
inline const ::ODP_main_frame::city_bid_count& city_bid_count_ans::count_info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count_ans.count_info)
  return count_info_.Get(index);
}
inline ::ODP_main_frame::city_bid_count* city_bid_count_ans::mutable_count_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.city_bid_count_ans.count_info)
  return count_info_.Mutable(index);
}
inline ::ODP_main_frame::city_bid_count* city_bid_count_ans::add_count_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.city_bid_count_ans.count_info)
  return count_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::city_bid_count >&
city_bid_count_ans::count_info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.city_bid_count_ans.count_info)
  return count_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::city_bid_count >*
city_bid_count_ans::mutable_count_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.city_bid_count_ans.count_info)
  return &count_info_;
}

// optional .common.errorinfo error = 2;
inline bool city_bid_count_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_bid_count_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_bid_count_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_bid_count_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& city_bid_count_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.city_bid_count_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* city_bid_count_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.city_bid_count_ans.error)
  return error_;
}
inline ::common::errorinfo* city_bid_count_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void city_bid_count_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.city_bid_count_ans.error)
}

// -------------------------------------------------------------------

// user_distribution_ask

// optional int32 user_status = 1;
inline bool user_distribution_ask::has_user_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_distribution_ask::set_has_user_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_distribution_ask::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_distribution_ask::clear_user_status() {
  user_status_ = 0;
  clear_has_user_status();
}
inline ::google::protobuf::int32 user_distribution_ask::user_status() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution_ask.user_status)
  return user_status_;
}
inline void user_distribution_ask::set_user_status(::google::protobuf::int32 value) {
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_distribution_ask.user_status)
}

// optional .common.common_ask_header ask_header = 2;
inline bool user_distribution_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_distribution_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_distribution_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_distribution_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& user_distribution_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* user_distribution_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_distribution_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* user_distribution_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void user_distribution_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_distribution_ask.ask_header)
}

// -------------------------------------------------------------------

// user_distribution_ans

// repeated .ODP_main_frame.user_distribution info = 1;
inline int user_distribution_ans::info_size() const {
  return info_.size();
}
inline void user_distribution_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_distribution& user_distribution_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_distribution* user_distribution_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_distribution_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_distribution* user_distribution_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_distribution_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_distribution >&
user_distribution_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_distribution_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_distribution >*
user_distribution_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_distribution_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool user_distribution_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_distribution_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_distribution_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_distribution_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& user_distribution_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_distribution_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* user_distribution_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_distribution_ans.error)
  return error_;
}
inline ::common::errorinfo* user_distribution_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void user_distribution_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_distribution_ans.error)
}

// -------------------------------------------------------------------

// cur_trading_volume_ask

// optional bytes start_datetime = 1;
inline bool cur_trading_volume_ask::has_start_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_trading_volume_ask::set_has_start_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_trading_volume_ask::clear_has_start_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_trading_volume_ask::clear_start_datetime() {
  if (start_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_->clear();
  }
  clear_has_start_datetime();
}
inline const ::std::string& cur_trading_volume_ask::start_datetime() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume_ask.start_datetime)
  return *start_datetime_;
}
inline void cur_trading_volume_ask::set_start_datetime(const ::std::string& value) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_volume_ask.start_datetime)
}
inline void cur_trading_volume_ask::set_start_datetime(const char* value) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_volume_ask.start_datetime)
}
inline void cur_trading_volume_ask::set_start_datetime(const void* value, size_t size) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_volume_ask.start_datetime)
}
inline ::std::string* cur_trading_volume_ask::mutable_start_datetime() {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume_ask.start_datetime)
  return start_datetime_;
}
inline ::std::string* cur_trading_volume_ask::release_start_datetime() {
  clear_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_datetime_;
    start_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_volume_ask::set_allocated_start_datetime(::std::string* start_datetime) {
  if (start_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_datetime_;
  }
  if (start_datetime) {
    set_has_start_datetime();
    start_datetime_ = start_datetime;
  } else {
    clear_has_start_datetime();
    start_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_volume_ask.start_datetime)
}

// optional bytes end_datetime = 2;
inline bool cur_trading_volume_ask::has_end_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_volume_ask::set_has_end_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_volume_ask::clear_has_end_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_volume_ask::clear_end_datetime() {
  if (end_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_->clear();
  }
  clear_has_end_datetime();
}
inline const ::std::string& cur_trading_volume_ask::end_datetime() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume_ask.end_datetime)
  return *end_datetime_;
}
inline void cur_trading_volume_ask::set_end_datetime(const ::std::string& value) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_volume_ask.end_datetime)
}
inline void cur_trading_volume_ask::set_end_datetime(const char* value) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_volume_ask.end_datetime)
}
inline void cur_trading_volume_ask::set_end_datetime(const void* value, size_t size) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_volume_ask.end_datetime)
}
inline ::std::string* cur_trading_volume_ask::mutable_end_datetime() {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume_ask.end_datetime)
  return end_datetime_;
}
inline ::std::string* cur_trading_volume_ask::release_end_datetime() {
  clear_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_datetime_;
    end_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_volume_ask::set_allocated_end_datetime(::std::string* end_datetime) {
  if (end_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_datetime_;
  }
  if (end_datetime) {
    set_has_end_datetime();
    end_datetime_ = end_datetime;
  } else {
    clear_has_end_datetime();
    end_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_volume_ask.end_datetime)
}

// optional .common.common_ask_header ask_header = 3;
inline bool cur_trading_volume_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cur_trading_volume_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cur_trading_volume_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cur_trading_volume_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& cur_trading_volume_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* cur_trading_volume_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* cur_trading_volume_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void cur_trading_volume_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_volume_ask.ask_header)
}

// -------------------------------------------------------------------

// cur_trading_volume_ans

// repeated .ODP_main_frame.cur_trading_volume info = 1;
inline int cur_trading_volume_ans::info_size() const {
  return info_.size();
}
inline void cur_trading_volume_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::cur_trading_volume& cur_trading_volume_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::cur_trading_volume* cur_trading_volume_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::cur_trading_volume* cur_trading_volume_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.cur_trading_volume_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_volume >&
cur_trading_volume_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.cur_trading_volume_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_volume >*
cur_trading_volume_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.cur_trading_volume_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool cur_trading_volume_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_volume_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_volume_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_volume_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& cur_trading_volume_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_volume_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* cur_trading_volume_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_volume_ans.error)
  return error_;
}
inline ::common::errorinfo* cur_trading_volume_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void cur_trading_volume_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_volume_ans.error)
}

// -------------------------------------------------------------------

// cur_province_trading_volume_ask

// optional .common.common_ask_header ask_header = 1;
inline bool cur_province_trading_volume_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_province_trading_volume_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_province_trading_volume_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_province_trading_volume_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& cur_province_trading_volume_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_province_trading_volume_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* cur_province_trading_volume_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_province_trading_volume_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* cur_province_trading_volume_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void cur_province_trading_volume_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_province_trading_volume_ask.ask_header)
}

// -------------------------------------------------------------------

// cur_province_trading_volume_ans

// repeated .ODP_main_frame.cur_province_trading_volume info = 1;
inline int cur_province_trading_volume_ans::info_size() const {
  return info_.size();
}
inline void cur_province_trading_volume_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::cur_province_trading_volume& cur_province_trading_volume_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_province_trading_volume_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::cur_province_trading_volume* cur_province_trading_volume_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_province_trading_volume_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::cur_province_trading_volume* cur_province_trading_volume_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.cur_province_trading_volume_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_province_trading_volume >&
cur_province_trading_volume_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.cur_province_trading_volume_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_province_trading_volume >*
cur_province_trading_volume_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.cur_province_trading_volume_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool cur_province_trading_volume_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_province_trading_volume_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_province_trading_volume_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_province_trading_volume_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& cur_province_trading_volume_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_province_trading_volume_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* cur_province_trading_volume_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_province_trading_volume_ans.error)
  return error_;
}
inline ::common::errorinfo* cur_province_trading_volume_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void cur_province_trading_volume_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_province_trading_volume_ans.error)
}

// -------------------------------------------------------------------

// Real_time_registration_ask

// optional .common.common_ask_header ask_header = 1;
inline bool Real_time_registration_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Real_time_registration_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Real_time_registration_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Real_time_registration_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& Real_time_registration_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Real_time_registration_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* Real_time_registration_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Real_time_registration_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* Real_time_registration_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void Real_time_registration_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Real_time_registration_ask.ask_header)
}

// -------------------------------------------------------------------

// Real_time_registration_ans

// repeated .ODP_main_frame.registration_info info = 1;
inline int Real_time_registration_ans::info_size() const {
  return info_.size();
}
inline void Real_time_registration_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::registration_info& Real_time_registration_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Real_time_registration_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::registration_info* Real_time_registration_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Real_time_registration_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::registration_info* Real_time_registration_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.Real_time_registration_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::registration_info >&
Real_time_registration_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.Real_time_registration_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::registration_info >*
Real_time_registration_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.Real_time_registration_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool Real_time_registration_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Real_time_registration_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Real_time_registration_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Real_time_registration_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& Real_time_registration_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.Real_time_registration_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* Real_time_registration_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.Real_time_registration_ans.error)
  return error_;
}
inline ::common::errorinfo* Real_time_registration_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Real_time_registration_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.Real_time_registration_ans.error)
}

// -------------------------------------------------------------------

// month_registration_ask

// optional bytes start_date = 1;
inline bool month_registration_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_registration_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_registration_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_registration_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& month_registration_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_ask.start_date)
  return *start_date_;
}
inline void month_registration_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_registration_ask.start_date)
}
inline void month_registration_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_registration_ask.start_date)
}
inline void month_registration_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_registration_ask.start_date)
}
inline ::std::string* month_registration_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_ask.start_date)
  return start_date_;
}
inline ::std::string* month_registration_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_registration_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_registration_ask.start_date)
}

// optional bytes end_date = 2;
inline bool month_registration_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_registration_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_registration_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_registration_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& month_registration_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_ask.end_date)
  return *end_date_;
}
inline void month_registration_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_registration_ask.end_date)
}
inline void month_registration_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_registration_ask.end_date)
}
inline void month_registration_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_registration_ask.end_date)
}
inline ::std::string* month_registration_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_ask.end_date)
  return end_date_;
}
inline ::std::string* month_registration_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_registration_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_registration_ask.end_date)
}

// optional .common.common_ask_header ask_header = 3;
inline bool month_registration_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void month_registration_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void month_registration_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void month_registration_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& month_registration_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* month_registration_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* month_registration_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void month_registration_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_registration_ask.ask_header)
}

// -------------------------------------------------------------------

// month_registration_ans

// repeated .ODP_main_frame.month_registration_volume info = 1;
inline int month_registration_ans::info_size() const {
  return info_.size();
}
inline void month_registration_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::month_registration_volume& month_registration_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::month_registration_volume* month_registration_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::month_registration_volume* month_registration_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.month_registration_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_registration_volume >&
month_registration_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.month_registration_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_registration_volume >*
month_registration_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.month_registration_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool month_registration_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_registration_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_registration_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_registration_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& month_registration_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_registration_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* month_registration_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_registration_ans.error)
  return error_;
}
inline ::common::errorinfo* month_registration_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void month_registration_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_registration_ans.error)
}

// -------------------------------------------------------------------

// real_time_charge_ask

// optional .common.common_ask_header ask_header = 1;
inline bool real_time_charge_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void real_time_charge_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void real_time_charge_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void real_time_charge_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& real_time_charge_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_time_charge_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* real_time_charge_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_time_charge_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* real_time_charge_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void real_time_charge_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_time_charge_ask.ask_header)
}

// -------------------------------------------------------------------

// real_time_charge_ans

// repeated .ODP_main_frame.charge_info info = 1;
inline int real_time_charge_ans::info_size() const {
  return info_.size();
}
inline void real_time_charge_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::charge_info& real_time_charge_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_time_charge_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::charge_info* real_time_charge_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_time_charge_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::charge_info* real_time_charge_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.real_time_charge_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::charge_info >&
real_time_charge_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.real_time_charge_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::charge_info >*
real_time_charge_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.real_time_charge_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool real_time_charge_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void real_time_charge_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void real_time_charge_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void real_time_charge_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& real_time_charge_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.real_time_charge_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* real_time_charge_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.real_time_charge_ans.error)
  return error_;
}
inline ::common::errorinfo* real_time_charge_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void real_time_charge_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.real_time_charge_ans.error)
}

// -------------------------------------------------------------------

// cur_trading_count_ask

// optional bytes start_datetime = 1;
inline bool cur_trading_count_ask::has_start_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_trading_count_ask::set_has_start_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_trading_count_ask::clear_has_start_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_trading_count_ask::clear_start_datetime() {
  if (start_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_->clear();
  }
  clear_has_start_datetime();
}
inline const ::std::string& cur_trading_count_ask::start_datetime() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count_ask.start_datetime)
  return *start_datetime_;
}
inline void cur_trading_count_ask::set_start_datetime(const ::std::string& value) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_count_ask.start_datetime)
}
inline void cur_trading_count_ask::set_start_datetime(const char* value) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_count_ask.start_datetime)
}
inline void cur_trading_count_ask::set_start_datetime(const void* value, size_t size) {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  start_datetime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_count_ask.start_datetime)
}
inline ::std::string* cur_trading_count_ask::mutable_start_datetime() {
  set_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_datetime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count_ask.start_datetime)
  return start_datetime_;
}
inline ::std::string* cur_trading_count_ask::release_start_datetime() {
  clear_has_start_datetime();
  if (start_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_datetime_;
    start_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_count_ask::set_allocated_start_datetime(::std::string* start_datetime) {
  if (start_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_datetime_;
  }
  if (start_datetime) {
    set_has_start_datetime();
    start_datetime_ = start_datetime;
  } else {
    clear_has_start_datetime();
    start_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_count_ask.start_datetime)
}

// optional bytes end_datetime = 2;
inline bool cur_trading_count_ask::has_end_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_count_ask::set_has_end_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_count_ask::clear_has_end_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_count_ask::clear_end_datetime() {
  if (end_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_->clear();
  }
  clear_has_end_datetime();
}
inline const ::std::string& cur_trading_count_ask::end_datetime() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count_ask.end_datetime)
  return *end_datetime_;
}
inline void cur_trading_count_ask::set_end_datetime(const ::std::string& value) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_trading_count_ask.end_datetime)
}
inline void cur_trading_count_ask::set_end_datetime(const char* value) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.cur_trading_count_ask.end_datetime)
}
inline void cur_trading_count_ask::set_end_datetime(const void* value, size_t size) {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  end_datetime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.cur_trading_count_ask.end_datetime)
}
inline ::std::string* cur_trading_count_ask::mutable_end_datetime() {
  set_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_datetime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count_ask.end_datetime)
  return end_datetime_;
}
inline ::std::string* cur_trading_count_ask::release_end_datetime() {
  clear_has_end_datetime();
  if (end_datetime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_datetime_;
    end_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void cur_trading_count_ask::set_allocated_end_datetime(::std::string* end_datetime) {
  if (end_datetime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_datetime_;
  }
  if (end_datetime) {
    set_has_end_datetime();
    end_datetime_ = end_datetime;
  } else {
    clear_has_end_datetime();
    end_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_count_ask.end_datetime)
}

// optional .common.common_ask_header ask_header = 3;
inline bool cur_trading_count_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cur_trading_count_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cur_trading_count_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cur_trading_count_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& cur_trading_count_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* cur_trading_count_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* cur_trading_count_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void cur_trading_count_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_count_ask.ask_header)
}

// -------------------------------------------------------------------

// cur_trading_count_ans

// repeated .ODP_main_frame.cur_trading_count info = 1;
inline int cur_trading_count_ans::info_size() const {
  return info_.size();
}
inline void cur_trading_count_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::cur_trading_count& cur_trading_count_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::cur_trading_count* cur_trading_count_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::cur_trading_count* cur_trading_count_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.cur_trading_count_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_count >&
cur_trading_count_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.cur_trading_count_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::cur_trading_count >*
cur_trading_count_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.cur_trading_count_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool cur_trading_count_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_trading_count_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_trading_count_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_trading_count_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& cur_trading_count_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_trading_count_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* cur_trading_count_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_trading_count_ans.error)
  return error_;
}
inline ::common::errorinfo* cur_trading_count_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void cur_trading_count_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_trading_count_ans.error)
}

// -------------------------------------------------------------------

// month_trading_ask

// optional bytes start_date = 1;
inline bool month_trading_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_trading_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_trading_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_trading_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& month_trading_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_ask.start_date)
  return *start_date_;
}
inline void month_trading_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_trading_ask.start_date)
}
inline void month_trading_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_trading_ask.start_date)
}
inline void month_trading_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_trading_ask.start_date)
}
inline ::std::string* month_trading_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_ask.start_date)
  return start_date_;
}
inline ::std::string* month_trading_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_trading_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_trading_ask.start_date)
}

// optional bytes end_date = 2;
inline bool month_trading_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_trading_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_trading_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_trading_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& month_trading_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_ask.end_date)
  return *end_date_;
}
inline void month_trading_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.month_trading_ask.end_date)
}
inline void month_trading_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.month_trading_ask.end_date)
}
inline void month_trading_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.month_trading_ask.end_date)
}
inline ::std::string* month_trading_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_ask.end_date)
  return end_date_;
}
inline ::std::string* month_trading_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void month_trading_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_trading_ask.end_date)
}

// optional .common.common_ask_header ask_header = 3;
inline bool month_trading_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void month_trading_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void month_trading_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void month_trading_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& month_trading_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* month_trading_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* month_trading_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void month_trading_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_trading_ask.ask_header)
}

// -------------------------------------------------------------------

// month_trading_ans

// repeated .ODP_main_frame.month_trading_volume info = 1;
inline int month_trading_ans::info_size() const {
  return info_.size();
}
inline void month_trading_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::month_trading_volume& month_trading_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::month_trading_volume* month_trading_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::month_trading_volume* month_trading_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.month_trading_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_trading_volume >&
month_trading_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.month_trading_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::month_trading_volume >*
month_trading_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.month_trading_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool month_trading_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_trading_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_trading_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_trading_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& month_trading_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.month_trading_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* month_trading_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.month_trading_ans.error)
  return error_;
}
inline ::common::errorinfo* month_trading_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void month_trading_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.month_trading_ans.error)
}

// -------------------------------------------------------------------

// cur_fund_detail_ask

// optional .common.common_ask_header ask_header = 1;
inline bool cur_fund_detail_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_fund_detail_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_fund_detail_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_fund_detail_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& cur_fund_detail_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* cur_fund_detail_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_fund_detail_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* cur_fund_detail_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void cur_fund_detail_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_fund_detail_ask.ask_header)
}

// -------------------------------------------------------------------

// cur_fund_detail_ans

// optional float cur_pay_amount = 1;
inline bool cur_fund_detail_ans::has_cur_pay_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_pay_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cur_fund_detail_ans::clear_has_cur_pay_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cur_fund_detail_ans::clear_cur_pay_amount() {
  cur_pay_amount_ = 0;
  clear_has_cur_pay_amount();
}
inline float cur_fund_detail_ans::cur_pay_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_pay_amount)
  return cur_pay_amount_;
}
inline void cur_fund_detail_ans::set_cur_pay_amount(float value) {
  set_has_cur_pay_amount();
  cur_pay_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_pay_amount)
}

// optional float cur_withdraw_amount = 2;
inline bool cur_fund_detail_ans::has_cur_withdraw_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_withdraw_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cur_fund_detail_ans::clear_has_cur_withdraw_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cur_fund_detail_ans::clear_cur_withdraw_amount() {
  cur_withdraw_amount_ = 0;
  clear_has_cur_withdraw_amount();
}
inline float cur_fund_detail_ans::cur_withdraw_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_withdraw_amount)
  return cur_withdraw_amount_;
}
inline void cur_fund_detail_ans::set_cur_withdraw_amount(float value) {
  set_has_cur_withdraw_amount();
  cur_withdraw_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_withdraw_amount)
}

// optional float cur_invest_amount = 3;
inline bool cur_fund_detail_ans::has_cur_invest_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_invest_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cur_fund_detail_ans::clear_has_cur_invest_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cur_fund_detail_ans::clear_cur_invest_amount() {
  cur_invest_amount_ = 0;
  clear_has_cur_invest_amount();
}
inline float cur_fund_detail_ans::cur_invest_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_invest_amount)
  return cur_invest_amount_;
}
inline void cur_fund_detail_ans::set_cur_invest_amount(float value) {
  set_has_cur_invest_amount();
  cur_invest_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_invest_amount)
}

// optional float cur_guarantee_amount = 4;
inline bool cur_fund_detail_ans::has_cur_guarantee_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_guarantee_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cur_fund_detail_ans::clear_has_cur_guarantee_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cur_fund_detail_ans::clear_cur_guarantee_amount() {
  cur_guarantee_amount_ = 0;
  clear_has_cur_guarantee_amount();
}
inline float cur_fund_detail_ans::cur_guarantee_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_guarantee_amount)
  return cur_guarantee_amount_;
}
inline void cur_fund_detail_ans::set_cur_guarantee_amount(float value) {
  set_has_cur_guarantee_amount();
  cur_guarantee_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_guarantee_amount)
}

// optional float cur_borrow_amount = 5;
inline bool cur_fund_detail_ans::has_cur_borrow_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_borrow_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cur_fund_detail_ans::clear_has_cur_borrow_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cur_fund_detail_ans::clear_cur_borrow_amount() {
  cur_borrow_amount_ = 0;
  clear_has_cur_borrow_amount();
}
inline float cur_fund_detail_ans::cur_borrow_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_borrow_amount)
  return cur_borrow_amount_;
}
inline void cur_fund_detail_ans::set_cur_borrow_amount(float value) {
  set_has_cur_borrow_amount();
  cur_borrow_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_borrow_amount)
}

// optional float cur_repayment_amount = 6;
inline bool cur_fund_detail_ans::has_cur_repayment_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_repayment_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cur_fund_detail_ans::clear_has_cur_repayment_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cur_fund_detail_ans::clear_cur_repayment_amount() {
  cur_repayment_amount_ = 0;
  clear_has_cur_repayment_amount();
}
inline float cur_fund_detail_ans::cur_repayment_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_repayment_amount)
  return cur_repayment_amount_;
}
inline void cur_fund_detail_ans::set_cur_repayment_amount(float value) {
  set_has_cur_repayment_amount();
  cur_repayment_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_repayment_amount)
}

// optional float cur_overdue_amount = 7;
inline bool cur_fund_detail_ans::has_cur_overdue_amount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cur_fund_detail_ans::set_has_cur_overdue_amount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cur_fund_detail_ans::clear_has_cur_overdue_amount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cur_fund_detail_ans::clear_cur_overdue_amount() {
  cur_overdue_amount_ = 0;
  clear_has_cur_overdue_amount();
}
inline float cur_fund_detail_ans::cur_overdue_amount() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.cur_overdue_amount)
  return cur_overdue_amount_;
}
inline void cur_fund_detail_ans::set_cur_overdue_amount(float value) {
  set_has_cur_overdue_amount();
  cur_overdue_amount_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.cur_fund_detail_ans.cur_overdue_amount)
}

// repeated .ODP_main_frame.real_fund_detail detail = 8;
inline int cur_fund_detail_ans::detail_size() const {
  return detail_.size();
}
inline void cur_fund_detail_ans::clear_detail() {
  detail_.Clear();
}
inline const ::ODP_main_frame::real_fund_detail& cur_fund_detail_ans::detail(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.detail)
  return detail_.Get(index);
}
inline ::ODP_main_frame::real_fund_detail* cur_fund_detail_ans::mutable_detail(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_fund_detail_ans.detail)
  return detail_.Mutable(index);
}
inline ::ODP_main_frame::real_fund_detail* cur_fund_detail_ans::add_detail() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.cur_fund_detail_ans.detail)
  return detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >&
cur_fund_detail_ans::detail() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.cur_fund_detail_ans.detail)
  return detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >*
cur_fund_detail_ans::mutable_detail() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.cur_fund_detail_ans.detail)
  return &detail_;
}

// optional .common.errorinfo error = 9;
inline bool cur_fund_detail_ans::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void cur_fund_detail_ans::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void cur_fund_detail_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void cur_fund_detail_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& cur_fund_detail_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.cur_fund_detail_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* cur_fund_detail_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.cur_fund_detail_ans.error)
  return error_;
}
inline ::common::errorinfo* cur_fund_detail_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void cur_fund_detail_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.cur_fund_detail_ans.error)
}

// -------------------------------------------------------------------

// history_fund_detail_ask

// optional bytes start_date = 1;
inline bool history_fund_detail_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void history_fund_detail_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void history_fund_detail_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void history_fund_detail_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& history_fund_detail_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.start_date)
  return *start_date_;
}
inline void history_fund_detail_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.start_date)
}
inline void history_fund_detail_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.history_fund_detail_ask.start_date)
}
inline void history_fund_detail_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.history_fund_detail_ask.start_date)
}
inline ::std::string* history_fund_detail_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ask.start_date)
  return start_date_;
}
inline ::std::string* history_fund_detail_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void history_fund_detail_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ask.start_date)
}

// optional bytes end_date = 2;
inline bool history_fund_detail_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void history_fund_detail_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void history_fund_detail_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void history_fund_detail_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& history_fund_detail_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.end_date)
  return *end_date_;
}
inline void history_fund_detail_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.end_date)
}
inline void history_fund_detail_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.history_fund_detail_ask.end_date)
}
inline void history_fund_detail_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.history_fund_detail_ask.end_date)
}
inline ::std::string* history_fund_detail_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ask.end_date)
  return end_date_;
}
inline ::std::string* history_fund_detail_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void history_fund_detail_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ask.end_date)
}

// optional bytes key_info = 3;
inline bool history_fund_detail_ask::has_key_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void history_fund_detail_ask::set_has_key_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void history_fund_detail_ask::clear_has_key_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void history_fund_detail_ask::clear_key_info() {
  if (key_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_info_->clear();
  }
  clear_has_key_info();
}
inline const ::std::string& history_fund_detail_ask::key_info() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.key_info)
  return *key_info_;
}
inline void history_fund_detail_ask::set_key_info(const ::std::string& value) {
  set_has_key_info();
  if (key_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_info_ = new ::std::string;
  }
  key_info_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.key_info)
}
inline void history_fund_detail_ask::set_key_info(const char* value) {
  set_has_key_info();
  if (key_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_info_ = new ::std::string;
  }
  key_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.history_fund_detail_ask.key_info)
}
inline void history_fund_detail_ask::set_key_info(const void* value, size_t size) {
  set_has_key_info();
  if (key_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_info_ = new ::std::string;
  }
  key_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.history_fund_detail_ask.key_info)
}
inline ::std::string* history_fund_detail_ask::mutable_key_info() {
  set_has_key_info();
  if (key_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ask.key_info)
  return key_info_;
}
inline ::std::string* history_fund_detail_ask::release_key_info() {
  clear_has_key_info();
  if (key_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_info_;
    key_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void history_fund_detail_ask::set_allocated_key_info(::std::string* key_info) {
  if (key_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_info_;
  }
  if (key_info) {
    set_has_key_info();
    key_info_ = key_info;
  } else {
    clear_has_key_info();
    key_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ask.key_info)
}

// optional bytes flow_type = 4;
inline bool history_fund_detail_ask::has_flow_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void history_fund_detail_ask::set_has_flow_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void history_fund_detail_ask::clear_has_flow_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void history_fund_detail_ask::clear_flow_type() {
  if (flow_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flow_type_->clear();
  }
  clear_has_flow_type();
}
inline const ::std::string& history_fund_detail_ask::flow_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.flow_type)
  return *flow_type_;
}
inline void history_fund_detail_ask::set_flow_type(const ::std::string& value) {
  set_has_flow_type();
  if (flow_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flow_type_ = new ::std::string;
  }
  flow_type_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.flow_type)
}
inline void history_fund_detail_ask::set_flow_type(const char* value) {
  set_has_flow_type();
  if (flow_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flow_type_ = new ::std::string;
  }
  flow_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.history_fund_detail_ask.flow_type)
}
inline void history_fund_detail_ask::set_flow_type(const void* value, size_t size) {
  set_has_flow_type();
  if (flow_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flow_type_ = new ::std::string;
  }
  flow_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.history_fund_detail_ask.flow_type)
}
inline ::std::string* history_fund_detail_ask::mutable_flow_type() {
  set_has_flow_type();
  if (flow_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flow_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ask.flow_type)
  return flow_type_;
}
inline ::std::string* history_fund_detail_ask::release_flow_type() {
  clear_has_flow_type();
  if (flow_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = flow_type_;
    flow_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void history_fund_detail_ask::set_allocated_flow_type(::std::string* flow_type) {
  if (flow_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete flow_type_;
  }
  if (flow_type) {
    set_has_flow_type();
    flow_type_ = flow_type;
  } else {
    clear_has_flow_type();
    flow_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ask.flow_type)
}

// optional int32 page_num = 5;
inline bool history_fund_detail_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void history_fund_detail_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void history_fund_detail_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void history_fund_detail_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 history_fund_detail_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.page_num)
  return page_num_;
}
inline void history_fund_detail_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool history_fund_detail_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void history_fund_detail_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void history_fund_detail_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void history_fund_detail_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 history_fund_detail_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.cur_page)
  return cur_page_;
}
inline void history_fund_detail_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool history_fund_detail_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void history_fund_detail_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void history_fund_detail_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void history_fund_detail_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& history_fund_detail_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* history_fund_detail_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* history_fund_detail_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void history_fund_detail_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ask.ask_header)
}

// -------------------------------------------------------------------

// history_fund_detail_ans

// optional int32 total_number = 1;
inline bool history_fund_detail_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void history_fund_detail_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void history_fund_detail_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void history_fund_detail_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 history_fund_detail_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ans.total_number)
  return total_number_;
}
inline void history_fund_detail_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.history_fund_detail_ans.total_number)
}

// repeated .ODP_main_frame.real_fund_detail detail = 2;
inline int history_fund_detail_ans::detail_size() const {
  return detail_.size();
}
inline void history_fund_detail_ans::clear_detail() {
  detail_.Clear();
}
inline const ::ODP_main_frame::real_fund_detail& history_fund_detail_ans::detail(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ans.detail)
  return detail_.Get(index);
}
inline ::ODP_main_frame::real_fund_detail* history_fund_detail_ans::mutable_detail(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ans.detail)
  return detail_.Mutable(index);
}
inline ::ODP_main_frame::real_fund_detail* history_fund_detail_ans::add_detail() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.history_fund_detail_ans.detail)
  return detail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >&
history_fund_detail_ans::detail() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.history_fund_detail_ans.detail)
  return detail_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::real_fund_detail >*
history_fund_detail_ans::mutable_detail() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.history_fund_detail_ans.detail)
  return &detail_;
}

// optional .common.errorinfo error = 3;
inline bool history_fund_detail_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void history_fund_detail_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void history_fund_detail_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void history_fund_detail_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& history_fund_detail_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_detail_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* history_fund_detail_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_detail_ans.error)
  return error_;
}
inline ::common::errorinfo* history_fund_detail_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void history_fund_detail_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_detail_ans.error)
}

// -------------------------------------------------------------------

// history_fund_flow_type_ask

// optional .common.common_ask_header ask_header = 1;
inline bool history_fund_flow_type_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void history_fund_flow_type_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void history_fund_flow_type_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void history_fund_flow_type_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& history_fund_flow_type_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_flow_type_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* history_fund_flow_type_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_flow_type_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* history_fund_flow_type_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void history_fund_flow_type_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_flow_type_ask.ask_header)
}

// -------------------------------------------------------------------

// history_fund_flow_type_ans

// repeated .ODP_main_frame.fund_flow_type fundtype = 1;
inline int history_fund_flow_type_ans::fundtype_size() const {
  return fundtype_.size();
}
inline void history_fund_flow_type_ans::clear_fundtype() {
  fundtype_.Clear();
}
inline const ::ODP_main_frame::fund_flow_type& history_fund_flow_type_ans::fundtype(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_flow_type_ans.fundtype)
  return fundtype_.Get(index);
}
inline ::ODP_main_frame::fund_flow_type* history_fund_flow_type_ans::mutable_fundtype(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_flow_type_ans.fundtype)
  return fundtype_.Mutable(index);
}
inline ::ODP_main_frame::fund_flow_type* history_fund_flow_type_ans::add_fundtype() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.history_fund_flow_type_ans.fundtype)
  return fundtype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::fund_flow_type >&
history_fund_flow_type_ans::fundtype() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.history_fund_flow_type_ans.fundtype)
  return fundtype_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::fund_flow_type >*
history_fund_flow_type_ans::mutable_fundtype() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.history_fund_flow_type_ans.fundtype)
  return &fundtype_;
}

// optional .common.errorinfo error = 2;
inline bool history_fund_flow_type_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void history_fund_flow_type_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void history_fund_flow_type_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void history_fund_flow_type_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& history_fund_flow_type_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.history_fund_flow_type_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* history_fund_flow_type_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.history_fund_flow_type_ans.error)
  return error_;
}
inline ::common::errorinfo* history_fund_flow_type_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void history_fund_flow_type_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.history_fund_flow_type_ans.error)
}

// -------------------------------------------------------------------

// client_versions_tendency_ask

// optional int32 os_type = 1;
inline bool client_versions_tendency_ask::has_os_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_tendency_ask::set_has_os_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_tendency_ask::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_tendency_ask::clear_os_type() {
  os_type_ = 0;
  clear_has_os_type();
}
inline ::google::protobuf::int32 client_versions_tendency_ask::os_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ask.os_type)
  return os_type_;
}
inline void client_versions_tendency_ask::set_os_type(::google::protobuf::int32 value) {
  set_has_os_type();
  os_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_tendency_ask.os_type)
}

// optional bytes start_date = 2;
inline bool client_versions_tendency_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_tendency_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_tendency_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_tendency_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& client_versions_tendency_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ask.start_date)
  return *start_date_;
}
inline void client_versions_tendency_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_tendency_ask.start_date)
}
inline void client_versions_tendency_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_tendency_ask.start_date)
}
inline void client_versions_tendency_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_tendency_ask.start_date)
}
inline ::std::string* client_versions_tendency_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_tendency_ask.start_date)
  return start_date_;
}
inline ::std::string* client_versions_tendency_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_tendency_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_tendency_ask.start_date)
}

// optional bytes end_date = 3;
inline bool client_versions_tendency_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_tendency_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_tendency_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_tendency_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& client_versions_tendency_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ask.end_date)
  return *end_date_;
}
inline void client_versions_tendency_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_tendency_ask.end_date)
}
inline void client_versions_tendency_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_tendency_ask.end_date)
}
inline void client_versions_tendency_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_tendency_ask.end_date)
}
inline ::std::string* client_versions_tendency_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_tendency_ask.end_date)
  return end_date_;
}
inline ::std::string* client_versions_tendency_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_tendency_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_tendency_ask.end_date)
}

// optional int32 request_type = 4;
inline bool client_versions_tendency_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_versions_tendency_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_versions_tendency_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_versions_tendency_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 client_versions_tendency_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ask.request_type)
  return request_type_;
}
inline void client_versions_tendency_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_tendency_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool client_versions_tendency_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_versions_tendency_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_versions_tendency_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_versions_tendency_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& client_versions_tendency_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* client_versions_tendency_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_tendency_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* client_versions_tendency_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void client_versions_tendency_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_tendency_ask.ask_header)
}

// -------------------------------------------------------------------

// client_versions_tendency_ans

// repeated .ODP_main_frame.top_ten_user_acount_info info = 1;
inline int client_versions_tendency_ans::info_size() const {
  return info_.size();
}
inline void client_versions_tendency_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::top_ten_user_acount_info& client_versions_tendency_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::top_ten_user_acount_info* client_versions_tendency_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_tendency_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::top_ten_user_acount_info* client_versions_tendency_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.client_versions_tendency_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::top_ten_user_acount_info >&
client_versions_tendency_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.client_versions_tendency_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::top_ten_user_acount_info >*
client_versions_tendency_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.client_versions_tendency_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool client_versions_tendency_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_tendency_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_tendency_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_tendency_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& client_versions_tendency_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_tendency_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* client_versions_tendency_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_tendency_ans.error)
  return error_;
}
inline ::common::errorinfo* client_versions_tendency_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void client_versions_tendency_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_tendency_ans.error)
}

// -------------------------------------------------------------------

// client_versions_distribution_ask

// optional int32 os_type = 1;
inline bool client_versions_distribution_ask::has_os_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_distribution_ask::set_has_os_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_distribution_ask::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_distribution_ask::clear_os_type() {
  os_type_ = 0;
  clear_has_os_type();
}
inline ::google::protobuf::int32 client_versions_distribution_ask::os_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.os_type)
  return os_type_;
}
inline void client_versions_distribution_ask::set_os_type(::google::protobuf::int32 value) {
  set_has_os_type();
  os_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ask.os_type)
}

// optional bytes start_date = 2;
inline bool client_versions_distribution_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_distribution_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_distribution_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_distribution_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& client_versions_distribution_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.start_date)
  return *start_date_;
}
inline void client_versions_distribution_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ask.start_date)
}
inline void client_versions_distribution_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_ask.start_date)
}
inline void client_versions_distribution_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_ask.start_date)
}
inline ::std::string* client_versions_distribution_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_ask.start_date)
  return start_date_;
}
inline ::std::string* client_versions_distribution_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_ask.start_date)
}

// optional bytes end_date = 3;
inline bool client_versions_distribution_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_distribution_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_distribution_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_distribution_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& client_versions_distribution_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.end_date)
  return *end_date_;
}
inline void client_versions_distribution_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ask.end_date)
}
inline void client_versions_distribution_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_ask.end_date)
}
inline void client_versions_distribution_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_ask.end_date)
}
inline ::std::string* client_versions_distribution_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_ask.end_date)
  return end_date_;
}
inline ::std::string* client_versions_distribution_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_ask.end_date)
}

// optional int32 page_num = 4;
inline bool client_versions_distribution_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_versions_distribution_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_versions_distribution_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_versions_distribution_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 client_versions_distribution_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.page_num)
  return page_num_;
}
inline void client_versions_distribution_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ask.page_num)
}

// optional int32 cur_page = 5;
inline bool client_versions_distribution_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_versions_distribution_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_versions_distribution_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_versions_distribution_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 client_versions_distribution_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.cur_page)
  return cur_page_;
}
inline void client_versions_distribution_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 6;
inline bool client_versions_distribution_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void client_versions_distribution_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void client_versions_distribution_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void client_versions_distribution_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& client_versions_distribution_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void client_versions_distribution_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_ask.ask_header)
}

// -------------------------------------------------------------------

// client_versions_distribution_ans

// optional int32 total_number = 1;
inline bool client_versions_distribution_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_distribution_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_distribution_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_distribution_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 client_versions_distribution_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ans.total_number)
  return total_number_;
}
inline void client_versions_distribution_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_ans.total_number)
}

// repeated .ODP_main_frame.app_version_statistics info = 2;
inline int client_versions_distribution_ans::info_size() const {
  return info_.size();
}
inline void client_versions_distribution_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::app_version_statistics& client_versions_distribution_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::app_version_statistics* client_versions_distribution_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::app_version_statistics* client_versions_distribution_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.client_versions_distribution_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_statistics >&
client_versions_distribution_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.client_versions_distribution_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_statistics >*
client_versions_distribution_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.client_versions_distribution_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool client_versions_distribution_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_distribution_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_distribution_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_distribution_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& client_versions_distribution_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* client_versions_distribution_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_ans.error)
  return error_;
}
inline ::common::errorinfo* client_versions_distribution_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void client_versions_distribution_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_ans.error)
}

// -------------------------------------------------------------------

// client_versions_distribution_detail_ask

// optional bytes start_date = 1;
inline bool client_versions_distribution_detail_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_distribution_detail_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_distribution_detail_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& client_versions_distribution_detail_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
  return *start_date_;
}
inline void client_versions_distribution_detail_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
}
inline void client_versions_distribution_detail_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
}
inline void client_versions_distribution_detail_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
}
inline ::std::string* client_versions_distribution_detail_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
  return start_date_;
}
inline ::std::string* client_versions_distribution_detail_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ask.start_date)
}

// optional bytes end_date = 2;
inline bool client_versions_distribution_detail_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_distribution_detail_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_distribution_detail_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& client_versions_distribution_detail_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
  return *end_date_;
}
inline void client_versions_distribution_detail_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
}
inline void client_versions_distribution_detail_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
}
inline void client_versions_distribution_detail_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
}
inline ::std::string* client_versions_distribution_detail_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
  return end_date_;
}
inline ::std::string* client_versions_distribution_detail_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ask.end_date)
}

// optional bytes os_version = 3;
inline bool client_versions_distribution_detail_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_distribution_detail_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_distribution_detail_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& client_versions_distribution_detail_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
  return *os_version_;
}
inline void client_versions_distribution_detail_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
}
inline void client_versions_distribution_detail_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
}
inline void client_versions_distribution_detail_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
}
inline ::std::string* client_versions_distribution_detail_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
  return os_version_;
}
inline ::std::string* client_versions_distribution_detail_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ask.os_version)
}

// optional bytes app_version = 4;
inline bool client_versions_distribution_detail_ask::has_app_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_app_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_versions_distribution_detail_ask::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_versions_distribution_detail_ask::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& client_versions_distribution_detail_ask::app_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
  return *app_version_;
}
inline void client_versions_distribution_detail_ask::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
}
inline void client_versions_distribution_detail_ask::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
}
inline void client_versions_distribution_detail_ask::set_app_version(const void* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
}
inline ::std::string* client_versions_distribution_detail_ask::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
  return app_version_;
}
inline ::std::string* client_versions_distribution_detail_ask::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_ask::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ask.app_version)
}

// optional int32 request_type = 5;
inline bool client_versions_distribution_detail_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_versions_distribution_detail_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_versions_distribution_detail_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 client_versions_distribution_detail_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.request_type)
  return request_type_;
}
inline void client_versions_distribution_detail_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_ask.request_type)
}

// optional .common.common_ask_header ask_header = 6;
inline bool client_versions_distribution_detail_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void client_versions_distribution_detail_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void client_versions_distribution_detail_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void client_versions_distribution_detail_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& client_versions_distribution_detail_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_detail_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_detail_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void client_versions_distribution_detail_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ask.ask_header)
}

// -------------------------------------------------------------------

// client_versions_distribution_detail_ans

// repeated .ODP_main_frame.user_acount_info info = 1;
inline int client_versions_distribution_detail_ans::info_size() const {
  return info_.size();
}
inline void client_versions_distribution_detail_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_acount_info& client_versions_distribution_detail_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_acount_info* client_versions_distribution_detail_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_acount_info* client_versions_distribution_detail_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.client_versions_distribution_detail_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >&
client_versions_distribution_detail_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.client_versions_distribution_detail_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_acount_info >*
client_versions_distribution_detail_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.client_versions_distribution_detail_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool client_versions_distribution_detail_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_distribution_detail_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_distribution_detail_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_distribution_detail_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& client_versions_distribution_detail_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* client_versions_distribution_detail_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_ans.error)
  return error_;
}
inline ::common::errorinfo* client_versions_distribution_detail_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void client_versions_distribution_detail_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_ans.error)
}

// -------------------------------------------------------------------

// client_versions_distribution_detail_list_ask

// optional bytes start_date = 1;
inline bool client_versions_distribution_detail_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_distribution_detail_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& client_versions_distribution_detail_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
  return *start_date_;
}
inline void client_versions_distribution_detail_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
}
inline void client_versions_distribution_detail_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
}
inline void client_versions_distribution_detail_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
}
inline ::std::string* client_versions_distribution_detail_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
  return start_date_;
}
inline ::std::string* client_versions_distribution_detail_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool client_versions_distribution_detail_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_versions_distribution_detail_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& client_versions_distribution_detail_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
  return *end_date_;
}
inline void client_versions_distribution_detail_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
}
inline void client_versions_distribution_detail_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
}
inline void client_versions_distribution_detail_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
}
inline ::std::string* client_versions_distribution_detail_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
  return end_date_;
}
inline ::std::string* client_versions_distribution_detail_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool client_versions_distribution_detail_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_distribution_detail_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& client_versions_distribution_detail_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
  return *os_version_;
}
inline void client_versions_distribution_detail_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
}
inline void client_versions_distribution_detail_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
}
inline void client_versions_distribution_detail_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
}
inline ::std::string* client_versions_distribution_detail_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
  return os_version_;
}
inline ::std::string* client_versions_distribution_detail_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ask.os_version)
}

// optional bytes app_version = 4;
inline bool client_versions_distribution_detail_list_ask::has_app_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_app_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_versions_distribution_detail_list_ask::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& client_versions_distribution_detail_list_ask::app_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
  return *app_version_;
}
inline void client_versions_distribution_detail_list_ask::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
}
inline void client_versions_distribution_detail_list_ask::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
}
inline void client_versions_distribution_detail_list_ask::set_app_version(const void* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
}
inline ::std::string* client_versions_distribution_detail_list_ask::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
  return app_version_;
}
inline ::std::string* client_versions_distribution_detail_list_ask::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_versions_distribution_detail_list_ask::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ask.app_version)
}

// optional int32 page_num = 5;
inline bool client_versions_distribution_detail_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_versions_distribution_detail_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 client_versions_distribution_detail_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.page_num)
  return page_num_;
}
inline void client_versions_distribution_detail_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool client_versions_distribution_detail_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void client_versions_distribution_detail_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 client_versions_distribution_detail_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.cur_page)
  return cur_page_;
}
inline void client_versions_distribution_detail_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool client_versions_distribution_detail_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void client_versions_distribution_detail_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void client_versions_distribution_detail_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void client_versions_distribution_detail_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& client_versions_distribution_detail_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_detail_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* client_versions_distribution_detail_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void client_versions_distribution_detail_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ask.ask_header)
}

// -------------------------------------------------------------------

// client_versions_distribution_detail_list_ans

// optional int32 total_number = 1;
inline bool client_versions_distribution_detail_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_versions_distribution_detail_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_versions_distribution_detail_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_versions_distribution_detail_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 client_versions_distribution_detail_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ans.total_number)
  return total_number_;
}
inline void client_versions_distribution_detail_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.client_versions_distribution_detail_list_ans.total_number)
}

// repeated .ODP_main_frame.app_version_detail info = 2;
inline int client_versions_distribution_detail_list_ans::info_size() const {
  return info_.size();
}
inline void client_versions_distribution_detail_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::app_version_detail& client_versions_distribution_detail_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::app_version_detail* client_versions_distribution_detail_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::app_version_detail* client_versions_distribution_detail_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.client_versions_distribution_detail_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_detail >&
client_versions_distribution_detail_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.client_versions_distribution_detail_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::app_version_detail >*
client_versions_distribution_detail_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.client_versions_distribution_detail_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool client_versions_distribution_detail_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_versions_distribution_detail_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_versions_distribution_detail_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_versions_distribution_detail_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& client_versions_distribution_detail_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.client_versions_distribution_detail_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* client_versions_distribution_detail_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.client_versions_distribution_detail_list_ans.error)
  return error_;
}
inline ::common::errorinfo* client_versions_distribution_detail_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void client_versions_distribution_detail_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.client_versions_distribution_detail_list_ans.error)
}

// -------------------------------------------------------------------

// start_count_analyze_ask

// optional bytes start_date = 1;
inline bool start_count_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_count_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_count_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_count_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& start_count_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ask.start_date)
  return *start_date_;
}
inline void start_count_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_ask.start_date)
}
inline void start_count_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_ask.start_date)
}
inline void start_count_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_ask.start_date)
}
inline ::std::string* start_count_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* start_count_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool start_count_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_count_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_count_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_count_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& start_count_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ask.end_date)
  return *end_date_;
}
inline void start_count_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_ask.end_date)
}
inline void start_count_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_ask.end_date)
}
inline void start_count_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_ask.end_date)
}
inline ::std::string* start_count_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* start_count_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool start_count_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void start_count_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void start_count_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void start_count_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& start_count_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ask.os_version)
  return *os_version_;
}
inline void start_count_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_ask.os_version)
}
inline void start_count_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_ask.os_version)
}
inline void start_count_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_ask.os_version)
}
inline ::std::string* start_count_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* start_count_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool start_count_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void start_count_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void start_count_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void start_count_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 start_count_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ask.request_type)
  return request_type_;
}
inline void start_count_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool start_count_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void start_count_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void start_count_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void start_count_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& start_count_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* start_count_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* start_count_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void start_count_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// start_count_analyze_ans

// repeated .ODP_main_frame.start_count_info info = 1;
inline int start_count_analyze_ans::info_size() const {
  return info_.size();
}
inline void start_count_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::start_count_info& start_count_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::start_count_info* start_count_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::start_count_info* start_count_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.start_count_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >&
start_count_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.start_count_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >*
start_count_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.start_count_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool start_count_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_count_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_count_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_count_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& start_count_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* start_count_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* start_count_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void start_count_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_ans.error)
}

// -------------------------------------------------------------------

// start_count_analyze_list_ask

// optional bytes start_date = 1;
inline bool start_count_analyze_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_count_analyze_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_count_analyze_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_count_analyze_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& start_count_analyze_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.start_date)
  return *start_date_;
}
inline void start_count_analyze_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.start_date)
}
inline void start_count_analyze_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_list_ask.start_date)
}
inline void start_count_analyze_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_list_ask.start_date)
}
inline ::std::string* start_count_analyze_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ask.start_date)
  return start_date_;
}
inline ::std::string* start_count_analyze_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool start_count_analyze_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void start_count_analyze_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void start_count_analyze_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void start_count_analyze_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& start_count_analyze_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.end_date)
  return *end_date_;
}
inline void start_count_analyze_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.end_date)
}
inline void start_count_analyze_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_list_ask.end_date)
}
inline void start_count_analyze_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_list_ask.end_date)
}
inline ::std::string* start_count_analyze_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ask.end_date)
  return end_date_;
}
inline ::std::string* start_count_analyze_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool start_count_analyze_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void start_count_analyze_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void start_count_analyze_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void start_count_analyze_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& start_count_analyze_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.os_version)
  return *os_version_;
}
inline void start_count_analyze_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.os_version)
}
inline void start_count_analyze_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.start_count_analyze_list_ask.os_version)
}
inline void start_count_analyze_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.start_count_analyze_list_ask.os_version)
}
inline ::std::string* start_count_analyze_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ask.os_version)
  return os_version_;
}
inline ::std::string* start_count_analyze_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void start_count_analyze_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_list_ask.os_version)
}

// optional int32 request_type = 4;
inline bool start_count_analyze_list_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void start_count_analyze_list_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void start_count_analyze_list_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void start_count_analyze_list_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 start_count_analyze_list_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.request_type)
  return request_type_;
}
inline void start_count_analyze_list_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.request_type)
}

// optional int32 page_num = 5;
inline bool start_count_analyze_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void start_count_analyze_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void start_count_analyze_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void start_count_analyze_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 start_count_analyze_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.page_num)
  return page_num_;
}
inline void start_count_analyze_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool start_count_analyze_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void start_count_analyze_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void start_count_analyze_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void start_count_analyze_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 start_count_analyze_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.cur_page)
  return cur_page_;
}
inline void start_count_analyze_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool start_count_analyze_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void start_count_analyze_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void start_count_analyze_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void start_count_analyze_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& start_count_analyze_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* start_count_analyze_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* start_count_analyze_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void start_count_analyze_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_list_ask.ask_header)
}

// -------------------------------------------------------------------

// start_count_analyze_list_ans

// optional int32 total_number = 1;
inline bool start_count_analyze_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void start_count_analyze_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void start_count_analyze_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void start_count_analyze_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 start_count_analyze_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ans.total_number)
  return total_number_;
}
inline void start_count_analyze_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.start_count_analyze_list_ans.total_number)
}

// repeated .ODP_main_frame.start_count_info info = 2;
inline int start_count_analyze_list_ans::info_size() const {
  return info_.size();
}
inline void start_count_analyze_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::start_count_info& start_count_analyze_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::start_count_info* start_count_analyze_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::start_count_info* start_count_analyze_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.start_count_analyze_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >&
start_count_analyze_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.start_count_analyze_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::start_count_info >*
start_count_analyze_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.start_count_analyze_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool start_count_analyze_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void start_count_analyze_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void start_count_analyze_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void start_count_analyze_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& start_count_analyze_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.start_count_analyze_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* start_count_analyze_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.start_count_analyze_list_ans.error)
  return error_;
}
inline ::common::errorinfo* start_count_analyze_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void start_count_analyze_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.start_count_analyze_list_ans.error)
}

// -------------------------------------------------------------------

// new_add_user_analyze_ask

// optional bytes start_date = 1;
inline bool new_add_user_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void new_add_user_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void new_add_user_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void new_add_user_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& new_add_user_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ask.start_date)
  return *start_date_;
}
inline void new_add_user_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_ask.start_date)
}
inline void new_add_user_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_ask.start_date)
}
inline void new_add_user_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_ask.start_date)
}
inline ::std::string* new_add_user_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* new_add_user_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool new_add_user_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void new_add_user_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void new_add_user_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void new_add_user_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& new_add_user_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ask.end_date)
  return *end_date_;
}
inline void new_add_user_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_ask.end_date)
}
inline void new_add_user_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_ask.end_date)
}
inline void new_add_user_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_ask.end_date)
}
inline ::std::string* new_add_user_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* new_add_user_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool new_add_user_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void new_add_user_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void new_add_user_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void new_add_user_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& new_add_user_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ask.os_version)
  return *os_version_;
}
inline void new_add_user_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_ask.os_version)
}
inline void new_add_user_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_ask.os_version)
}
inline void new_add_user_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_ask.os_version)
}
inline ::std::string* new_add_user_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* new_add_user_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool new_add_user_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void new_add_user_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void new_add_user_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void new_add_user_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 new_add_user_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ask.request_type)
  return request_type_;
}
inline void new_add_user_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool new_add_user_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void new_add_user_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void new_add_user_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void new_add_user_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& new_add_user_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* new_add_user_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* new_add_user_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void new_add_user_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// new_add_user_analyze_ans

// repeated .ODP_main_frame.user_analyze_info info = 1;
inline int new_add_user_analyze_ans::info_size() const {
  return info_.size();
}
inline void new_add_user_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_analyze_info& new_add_user_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_analyze_info* new_add_user_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_analyze_info* new_add_user_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.new_add_user_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
new_add_user_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.new_add_user_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
new_add_user_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.new_add_user_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool new_add_user_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void new_add_user_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void new_add_user_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void new_add_user_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& new_add_user_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* new_add_user_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* new_add_user_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void new_add_user_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_ans.error)
}

// -------------------------------------------------------------------

// new_add_user_analyze_list_ask

// optional bytes start_date = 1;
inline bool new_add_user_analyze_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void new_add_user_analyze_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void new_add_user_analyze_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& new_add_user_analyze_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
  return *start_date_;
}
inline void new_add_user_analyze_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
}
inline void new_add_user_analyze_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
}
inline void new_add_user_analyze_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
}
inline ::std::string* new_add_user_analyze_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
  return start_date_;
}
inline ::std::string* new_add_user_analyze_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool new_add_user_analyze_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void new_add_user_analyze_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void new_add_user_analyze_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& new_add_user_analyze_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
  return *end_date_;
}
inline void new_add_user_analyze_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
}
inline void new_add_user_analyze_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
}
inline void new_add_user_analyze_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
}
inline ::std::string* new_add_user_analyze_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
  return end_date_;
}
inline ::std::string* new_add_user_analyze_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool new_add_user_analyze_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void new_add_user_analyze_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void new_add_user_analyze_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& new_add_user_analyze_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
  return *os_version_;
}
inline void new_add_user_analyze_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
}
inline void new_add_user_analyze_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
}
inline void new_add_user_analyze_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
}
inline ::std::string* new_add_user_analyze_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
  return os_version_;
}
inline ::std::string* new_add_user_analyze_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void new_add_user_analyze_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_list_ask.os_version)
}

// optional int32 request_type = 4;
inline bool new_add_user_analyze_list_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void new_add_user_analyze_list_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void new_add_user_analyze_list_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 new_add_user_analyze_list_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.request_type)
  return request_type_;
}
inline void new_add_user_analyze_list_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.request_type)
}

// optional int32 page_num = 5;
inline bool new_add_user_analyze_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void new_add_user_analyze_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void new_add_user_analyze_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 new_add_user_analyze_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.page_num)
  return page_num_;
}
inline void new_add_user_analyze_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool new_add_user_analyze_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void new_add_user_analyze_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void new_add_user_analyze_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 new_add_user_analyze_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.cur_page)
  return cur_page_;
}
inline void new_add_user_analyze_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool new_add_user_analyze_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void new_add_user_analyze_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void new_add_user_analyze_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void new_add_user_analyze_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& new_add_user_analyze_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* new_add_user_analyze_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* new_add_user_analyze_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void new_add_user_analyze_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_list_ask.ask_header)
}

// -------------------------------------------------------------------

// new_add_user_analyze_list_ans

// optional int32 total_number = 1;
inline bool new_add_user_analyze_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void new_add_user_analyze_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void new_add_user_analyze_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void new_add_user_analyze_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 new_add_user_analyze_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ans.total_number)
  return total_number_;
}
inline void new_add_user_analyze_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.new_add_user_analyze_list_ans.total_number)
}

// repeated .ODP_main_frame.user_analyze_info info = 2;
inline int new_add_user_analyze_list_ans::info_size() const {
  return info_.size();
}
inline void new_add_user_analyze_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_analyze_info& new_add_user_analyze_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_analyze_info* new_add_user_analyze_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_analyze_info* new_add_user_analyze_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.new_add_user_analyze_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
new_add_user_analyze_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.new_add_user_analyze_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
new_add_user_analyze_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.new_add_user_analyze_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool new_add_user_analyze_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void new_add_user_analyze_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void new_add_user_analyze_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void new_add_user_analyze_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& new_add_user_analyze_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.new_add_user_analyze_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* new_add_user_analyze_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.new_add_user_analyze_list_ans.error)
  return error_;
}
inline ::common::errorinfo* new_add_user_analyze_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void new_add_user_analyze_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.new_add_user_analyze_list_ans.error)
}

// -------------------------------------------------------------------

// active_user_analyze_ask

// optional bytes start_date = 1;
inline bool active_user_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void active_user_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void active_user_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void active_user_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& active_user_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ask.start_date)
  return *start_date_;
}
inline void active_user_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_ask.start_date)
}
inline void active_user_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_ask.start_date)
}
inline void active_user_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_ask.start_date)
}
inline ::std::string* active_user_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* active_user_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool active_user_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void active_user_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void active_user_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void active_user_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& active_user_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ask.end_date)
  return *end_date_;
}
inline void active_user_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_ask.end_date)
}
inline void active_user_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_ask.end_date)
}
inline void active_user_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_ask.end_date)
}
inline ::std::string* active_user_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* active_user_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool active_user_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void active_user_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void active_user_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void active_user_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& active_user_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ask.os_version)
  return *os_version_;
}
inline void active_user_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_ask.os_version)
}
inline void active_user_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_ask.os_version)
}
inline void active_user_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_ask.os_version)
}
inline ::std::string* active_user_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* active_user_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool active_user_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void active_user_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void active_user_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void active_user_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 active_user_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ask.request_type)
  return request_type_;
}
inline void active_user_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool active_user_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void active_user_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void active_user_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void active_user_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& active_user_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* active_user_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* active_user_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void active_user_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// active_user_analyze_ans

// repeated .ODP_main_frame.user_analyze_info info = 1;
inline int active_user_analyze_ans::info_size() const {
  return info_.size();
}
inline void active_user_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_analyze_info& active_user_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_analyze_info* active_user_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_analyze_info* active_user_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.active_user_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
active_user_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.active_user_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
active_user_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.active_user_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool active_user_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void active_user_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void active_user_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void active_user_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& active_user_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* active_user_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* active_user_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void active_user_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_ans.error)
}

// -------------------------------------------------------------------

// active_user_analyze_list_ask

// optional bytes start_date = 1;
inline bool active_user_analyze_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void active_user_analyze_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void active_user_analyze_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void active_user_analyze_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& active_user_analyze_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.start_date)
  return *start_date_;
}
inline void active_user_analyze_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.start_date)
}
inline void active_user_analyze_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_list_ask.start_date)
}
inline void active_user_analyze_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_list_ask.start_date)
}
inline ::std::string* active_user_analyze_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ask.start_date)
  return start_date_;
}
inline ::std::string* active_user_analyze_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool active_user_analyze_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void active_user_analyze_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void active_user_analyze_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void active_user_analyze_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& active_user_analyze_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.end_date)
  return *end_date_;
}
inline void active_user_analyze_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.end_date)
}
inline void active_user_analyze_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_list_ask.end_date)
}
inline void active_user_analyze_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_list_ask.end_date)
}
inline ::std::string* active_user_analyze_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ask.end_date)
  return end_date_;
}
inline ::std::string* active_user_analyze_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool active_user_analyze_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void active_user_analyze_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void active_user_analyze_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void active_user_analyze_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& active_user_analyze_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.os_version)
  return *os_version_;
}
inline void active_user_analyze_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.os_version)
}
inline void active_user_analyze_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.active_user_analyze_list_ask.os_version)
}
inline void active_user_analyze_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.active_user_analyze_list_ask.os_version)
}
inline ::std::string* active_user_analyze_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ask.os_version)
  return os_version_;
}
inline ::std::string* active_user_analyze_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void active_user_analyze_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_list_ask.os_version)
}

// optional int32 request_type = 4;
inline bool active_user_analyze_list_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void active_user_analyze_list_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void active_user_analyze_list_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void active_user_analyze_list_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 active_user_analyze_list_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.request_type)
  return request_type_;
}
inline void active_user_analyze_list_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.request_type)
}

// optional int32 page_num = 5;
inline bool active_user_analyze_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void active_user_analyze_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void active_user_analyze_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void active_user_analyze_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 active_user_analyze_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.page_num)
  return page_num_;
}
inline void active_user_analyze_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool active_user_analyze_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void active_user_analyze_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void active_user_analyze_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void active_user_analyze_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 active_user_analyze_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.cur_page)
  return cur_page_;
}
inline void active_user_analyze_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool active_user_analyze_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void active_user_analyze_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void active_user_analyze_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void active_user_analyze_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& active_user_analyze_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* active_user_analyze_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* active_user_analyze_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void active_user_analyze_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_list_ask.ask_header)
}

// -------------------------------------------------------------------

// active_user_analyze_list_ans

// optional int32 total_number = 1;
inline bool active_user_analyze_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void active_user_analyze_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void active_user_analyze_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void active_user_analyze_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 active_user_analyze_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ans.total_number)
  return total_number_;
}
inline void active_user_analyze_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.active_user_analyze_list_ans.total_number)
}

// repeated .ODP_main_frame.user_analyze_info info = 2;
inline int active_user_analyze_list_ans::info_size() const {
  return info_.size();
}
inline void active_user_analyze_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_analyze_info& active_user_analyze_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_analyze_info* active_user_analyze_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_analyze_info* active_user_analyze_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.active_user_analyze_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >&
active_user_analyze_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.active_user_analyze_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_analyze_info >*
active_user_analyze_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.active_user_analyze_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool active_user_analyze_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void active_user_analyze_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void active_user_analyze_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void active_user_analyze_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& active_user_analyze_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.active_user_analyze_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* active_user_analyze_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.active_user_analyze_list_ans.error)
  return error_;
}
inline ::common::errorinfo* active_user_analyze_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void active_user_analyze_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.active_user_analyze_list_ans.error)
}

// -------------------------------------------------------------------

// user_freshness_analyze_ask

// optional bytes start_date = 1;
inline bool user_freshness_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_freshness_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_freshness_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_freshness_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& user_freshness_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ask.start_date)
  return *start_date_;
}
inline void user_freshness_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_ask.start_date)
}
inline void user_freshness_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_ask.start_date)
}
inline void user_freshness_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_ask.start_date)
}
inline ::std::string* user_freshness_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* user_freshness_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool user_freshness_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_freshness_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_freshness_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_freshness_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& user_freshness_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ask.end_date)
  return *end_date_;
}
inline void user_freshness_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_ask.end_date)
}
inline void user_freshness_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_ask.end_date)
}
inline void user_freshness_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_ask.end_date)
}
inline ::std::string* user_freshness_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* user_freshness_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool user_freshness_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_freshness_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_freshness_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_freshness_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& user_freshness_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ask.os_version)
  return *os_version_;
}
inline void user_freshness_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_ask.os_version)
}
inline void user_freshness_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_ask.os_version)
}
inline void user_freshness_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_ask.os_version)
}
inline ::std::string* user_freshness_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* user_freshness_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool user_freshness_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_freshness_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_freshness_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_freshness_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 user_freshness_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ask.request_type)
  return request_type_;
}
inline void user_freshness_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool user_freshness_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_freshness_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_freshness_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_freshness_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& user_freshness_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* user_freshness_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* user_freshness_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void user_freshness_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// user_freshness_analyze_ans

// repeated .ODP_main_frame.user_freshness_info info = 1;
inline int user_freshness_analyze_ans::info_size() const {
  return info_.size();
}
inline void user_freshness_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_freshness_info& user_freshness_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_freshness_info* user_freshness_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_freshness_info* user_freshness_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_freshness_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >&
user_freshness_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_freshness_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >*
user_freshness_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_freshness_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool user_freshness_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_freshness_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_freshness_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_freshness_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& user_freshness_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* user_freshness_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* user_freshness_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void user_freshness_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_ans.error)
}

// -------------------------------------------------------------------

// user_freshness_analyze_list_ask

// optional bytes start_date = 1;
inline bool user_freshness_analyze_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_freshness_analyze_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_freshness_analyze_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& user_freshness_analyze_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
  return *start_date_;
}
inline void user_freshness_analyze_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
}
inline void user_freshness_analyze_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
}
inline void user_freshness_analyze_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
}
inline ::std::string* user_freshness_analyze_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
  return start_date_;
}
inline ::std::string* user_freshness_analyze_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool user_freshness_analyze_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_freshness_analyze_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_freshness_analyze_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& user_freshness_analyze_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
  return *end_date_;
}
inline void user_freshness_analyze_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
}
inline void user_freshness_analyze_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
}
inline void user_freshness_analyze_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
}
inline ::std::string* user_freshness_analyze_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
  return end_date_;
}
inline ::std::string* user_freshness_analyze_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool user_freshness_analyze_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_freshness_analyze_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_freshness_analyze_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& user_freshness_analyze_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
  return *os_version_;
}
inline void user_freshness_analyze_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
}
inline void user_freshness_analyze_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
}
inline void user_freshness_analyze_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
}
inline ::std::string* user_freshness_analyze_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
  return os_version_;
}
inline ::std::string* user_freshness_analyze_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_freshness_analyze_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_list_ask.os_version)
}

// optional int32 request_type = 4;
inline bool user_freshness_analyze_list_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_freshness_analyze_list_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_freshness_analyze_list_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 user_freshness_analyze_list_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.request_type)
  return request_type_;
}
inline void user_freshness_analyze_list_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.request_type)
}

// optional int32 page_num = 5;
inline bool user_freshness_analyze_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_freshness_analyze_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_freshness_analyze_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 user_freshness_analyze_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.page_num)
  return page_num_;
}
inline void user_freshness_analyze_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.page_num)
}

// optional int32 cur_page = 6;
inline bool user_freshness_analyze_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_freshness_analyze_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_freshness_analyze_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 user_freshness_analyze_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.cur_page)
  return cur_page_;
}
inline void user_freshness_analyze_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 7;
inline bool user_freshness_analyze_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_freshness_analyze_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_freshness_analyze_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_freshness_analyze_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& user_freshness_analyze_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* user_freshness_analyze_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* user_freshness_analyze_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void user_freshness_analyze_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_list_ask.ask_header)
}

// -------------------------------------------------------------------

// user_freshness_analyze_list_ans

// optional int32 total_number = 1;
inline bool user_freshness_analyze_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_freshness_analyze_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_freshness_analyze_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_freshness_analyze_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 user_freshness_analyze_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ans.total_number)
  return total_number_;
}
inline void user_freshness_analyze_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_freshness_analyze_list_ans.total_number)
}

// repeated .ODP_main_frame.user_freshness_info info = 2;
inline int user_freshness_analyze_list_ans::info_size() const {
  return info_.size();
}
inline void user_freshness_analyze_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_freshness_info& user_freshness_analyze_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_freshness_info* user_freshness_analyze_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_freshness_info* user_freshness_analyze_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_freshness_analyze_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >&
user_freshness_analyze_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_freshness_analyze_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_freshness_info >*
user_freshness_analyze_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_freshness_analyze_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool user_freshness_analyze_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_freshness_analyze_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_freshness_analyze_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_freshness_analyze_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& user_freshness_analyze_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_freshness_analyze_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* user_freshness_analyze_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_freshness_analyze_list_ans.error)
  return error_;
}
inline ::common::errorinfo* user_freshness_analyze_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void user_freshness_analyze_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_freshness_analyze_list_ans.error)
}

// -------------------------------------------------------------------

// user_retain_analyze_ask

// optional bytes start_date = 1;
inline bool user_retain_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_retain_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_retain_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_retain_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& user_retain_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ask.start_date)
  return *start_date_;
}
inline void user_retain_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_analyze_ask.start_date)
}
inline void user_retain_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_retain_analyze_ask.start_date)
}
inline void user_retain_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_retain_analyze_ask.start_date)
}
inline ::std::string* user_retain_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* user_retain_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_retain_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool user_retain_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_retain_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_retain_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_retain_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& user_retain_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ask.end_date)
  return *end_date_;
}
inline void user_retain_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_analyze_ask.end_date)
}
inline void user_retain_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_retain_analyze_ask.end_date)
}
inline void user_retain_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_retain_analyze_ask.end_date)
}
inline ::std::string* user_retain_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* user_retain_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_retain_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool user_retain_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_retain_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_retain_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_retain_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& user_retain_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ask.os_version)
  return *os_version_;
}
inline void user_retain_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_analyze_ask.os_version)
}
inline void user_retain_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_retain_analyze_ask.os_version)
}
inline void user_retain_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_retain_analyze_ask.os_version)
}
inline ::std::string* user_retain_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* user_retain_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_retain_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool user_retain_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_retain_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_retain_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_retain_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 user_retain_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ask.request_type)
  return request_type_;
}
inline void user_retain_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_retain_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool user_retain_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_retain_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_retain_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_retain_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& user_retain_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* user_retain_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* user_retain_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void user_retain_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// user_retain_analyze_ans

// repeated .ODP_main_frame.user_retain_info info = 1;
inline int user_retain_analyze_ans::info_size() const {
  return info_.size();
}
inline void user_retain_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::user_retain_info& user_retain_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::user_retain_info* user_retain_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::user_retain_info* user_retain_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_retain_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_retain_info >&
user_retain_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_retain_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_retain_info >*
user_retain_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_retain_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool user_retain_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_retain_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_retain_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_retain_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& user_retain_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_retain_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* user_retain_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_retain_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* user_retain_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void user_retain_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_retain_analyze_ans.error)
}

// -------------------------------------------------------------------

// use_time_analyze_ask

// optional bytes start_date = 1;
inline bool use_time_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_time_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_time_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_time_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& use_time_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ask.start_date)
  return *start_date_;
}
inline void use_time_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_analyze_ask.start_date)
}
inline void use_time_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_time_analyze_ask.start_date)
}
inline void use_time_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_time_analyze_ask.start_date)
}
inline ::std::string* use_time_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* use_time_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_time_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_time_analyze_ask.start_date)
}

// optional bytes os_version = 2;
inline bool use_time_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_time_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_time_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_time_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& use_time_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ask.os_version)
  return *os_version_;
}
inline void use_time_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_analyze_ask.os_version)
}
inline void use_time_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_time_analyze_ask.os_version)
}
inline void use_time_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_time_analyze_ask.os_version)
}
inline ::std::string* use_time_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* use_time_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_time_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_time_analyze_ask.os_version)
}

// optional int32 request_type = 3;
inline bool use_time_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_time_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_time_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_time_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 use_time_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ask.request_type)
  return request_type_;
}
inline void use_time_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_time_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 4;
inline bool use_time_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void use_time_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void use_time_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void use_time_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& use_time_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* use_time_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* use_time_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void use_time_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_time_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// use_time_analyze_ans

// repeated .ODP_main_frame.use_time_info info = 1;
inline int use_time_analyze_ans::info_size() const {
  return info_.size();
}
inline void use_time_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::use_time_info& use_time_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::use_time_info* use_time_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::use_time_info* use_time_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.use_time_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_time_info >&
use_time_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.use_time_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_time_info >*
use_time_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.use_time_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool use_time_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_time_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_time_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_time_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& use_time_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_time_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* use_time_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_time_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* use_time_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void use_time_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_time_analyze_ans.error)
}

// -------------------------------------------------------------------

// use_count_analyze_ask

// optional bytes start_date = 1;
inline bool use_count_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_count_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_count_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_count_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& use_count_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ask.start_date)
  return *start_date_;
}
inline void use_count_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_analyze_ask.start_date)
}
inline void use_count_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_count_analyze_ask.start_date)
}
inline void use_count_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_count_analyze_ask.start_date)
}
inline ::std::string* use_count_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* use_count_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_count_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_count_analyze_ask.start_date)
}

// optional bytes os_version = 2;
inline bool use_count_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_count_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_count_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_count_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& use_count_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ask.os_version)
  return *os_version_;
}
inline void use_count_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_analyze_ask.os_version)
}
inline void use_count_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_count_analyze_ask.os_version)
}
inline void use_count_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_count_analyze_ask.os_version)
}
inline ::std::string* use_count_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* use_count_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_count_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_count_analyze_ask.os_version)
}

// optional int32 request_type = 3;
inline bool use_count_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_count_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_count_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_count_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 use_count_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ask.request_type)
  return request_type_;
}
inline void use_count_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_count_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 4;
inline bool use_count_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void use_count_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void use_count_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void use_count_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& use_count_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* use_count_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* use_count_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void use_count_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_count_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// use_count_analyze_ans

// repeated .ODP_main_frame.use_count_info info = 1;
inline int use_count_analyze_ans::info_size() const {
  return info_.size();
}
inline void use_count_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::use_count_info& use_count_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::use_count_info* use_count_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::use_count_info* use_count_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.use_count_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_count_info >&
use_count_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.use_count_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_count_info >*
use_count_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.use_count_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool use_count_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_count_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_count_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_count_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& use_count_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_count_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* use_count_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_count_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* use_count_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void use_count_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_count_analyze_ans.error)
}

// -------------------------------------------------------------------

// use_interval_analyze_ask

// optional bytes end_date = 1;
inline bool use_interval_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void use_interval_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void use_interval_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void use_interval_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& use_interval_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_analyze_ask.end_date)
  return *end_date_;
}
inline void use_interval_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_interval_analyze_ask.end_date)
}
inline void use_interval_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_interval_analyze_ask.end_date)
}
inline void use_interval_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_interval_analyze_ask.end_date)
}
inline ::std::string* use_interval_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* use_interval_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_interval_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_interval_analyze_ask.end_date)
}

// optional bytes os_version = 2;
inline bool use_interval_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_interval_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_interval_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_interval_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& use_interval_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_analyze_ask.os_version)
  return *os_version_;
}
inline void use_interval_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.use_interval_analyze_ask.os_version)
}
inline void use_interval_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.use_interval_analyze_ask.os_version)
}
inline void use_interval_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.use_interval_analyze_ask.os_version)
}
inline ::std::string* use_interval_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* use_interval_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void use_interval_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_interval_analyze_ask.os_version)
}

// optional .common.common_ask_header ask_header = 3;
inline bool use_interval_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void use_interval_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void use_interval_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void use_interval_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& use_interval_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* use_interval_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* use_interval_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void use_interval_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_interval_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// use_interval_analyze_ans

// repeated .ODP_main_frame.use_interval_info info = 1;
inline int use_interval_analyze_ans::info_size() const {
  return info_.size();
}
inline void use_interval_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::use_interval_info& use_interval_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::use_interval_info* use_interval_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::use_interval_info* use_interval_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.use_interval_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_interval_info >&
use_interval_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.use_interval_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::use_interval_info >*
use_interval_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.use_interval_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool use_interval_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void use_interval_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void use_interval_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void use_interval_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& use_interval_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.use_interval_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* use_interval_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.use_interval_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* use_interval_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void use_interval_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.use_interval_analyze_ans.error)
}

// -------------------------------------------------------------------

// download_src_analyze_ask

// optional bytes start_date = 1;
inline bool download_src_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void download_src_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void download_src_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void download_src_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& download_src_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ask.start_date)
  return *start_date_;
}
inline void download_src_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_ask.start_date)
}
inline void download_src_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_ask.start_date)
}
inline void download_src_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_ask.start_date)
}
inline ::std::string* download_src_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* download_src_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool download_src_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void download_src_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void download_src_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void download_src_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& download_src_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ask.end_date)
  return *end_date_;
}
inline void download_src_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_ask.end_date)
}
inline void download_src_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_ask.end_date)
}
inline void download_src_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_ask.end_date)
}
inline ::std::string* download_src_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* download_src_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool download_src_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void download_src_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void download_src_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void download_src_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& download_src_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ask.os_version)
  return *os_version_;
}
inline void download_src_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_ask.os_version)
}
inline void download_src_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_ask.os_version)
}
inline void download_src_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_ask.os_version)
}
inline ::std::string* download_src_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* download_src_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_ask.os_version)
}

// optional int32 request_type = 4;
inline bool download_src_analyze_ask::has_request_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void download_src_analyze_ask::set_has_request_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void download_src_analyze_ask::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void download_src_analyze_ask::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::google::protobuf::int32 download_src_analyze_ask::request_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ask.request_type)
  return request_type_;
}
inline void download_src_analyze_ask::set_request_type(::google::protobuf::int32 value) {
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_ask.request_type)
}

// optional .common.common_ask_header ask_header = 5;
inline bool download_src_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void download_src_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void download_src_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void download_src_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& download_src_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* download_src_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* download_src_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void download_src_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// download_src_analyze_ans

// repeated .ODP_main_frame.download_src_user_acount_info info = 1;
inline int download_src_analyze_ans::info_size() const {
  return info_.size();
}
inline void download_src_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::download_src_user_acount_info& download_src_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::download_src_user_acount_info* download_src_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::download_src_user_acount_info* download_src_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.download_src_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_user_acount_info >&
download_src_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.download_src_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_user_acount_info >*
download_src_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.download_src_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool download_src_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void download_src_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void download_src_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void download_src_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& download_src_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* download_src_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* download_src_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void download_src_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_ans.error)
}

// -------------------------------------------------------------------

// download_src_analyze_detail_ask

// optional bytes start_date = 1;
inline bool download_src_analyze_detail_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void download_src_analyze_detail_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void download_src_analyze_detail_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& download_src_analyze_detail_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.start_date)
  return *start_date_;
}
inline void download_src_analyze_detail_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ask.start_date)
}
inline void download_src_analyze_detail_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_detail_ask.start_date)
}
inline void download_src_analyze_detail_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_detail_ask.start_date)
}
inline ::std::string* download_src_analyze_detail_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ask.start_date)
  return start_date_;
}
inline ::std::string* download_src_analyze_detail_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_detail_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_detail_ask.start_date)
}

// optional bytes end_date = 2;
inline bool download_src_analyze_detail_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void download_src_analyze_detail_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void download_src_analyze_detail_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& download_src_analyze_detail_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.end_date)
  return *end_date_;
}
inline void download_src_analyze_detail_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ask.end_date)
}
inline void download_src_analyze_detail_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_detail_ask.end_date)
}
inline void download_src_analyze_detail_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_detail_ask.end_date)
}
inline ::std::string* download_src_analyze_detail_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ask.end_date)
  return end_date_;
}
inline ::std::string* download_src_analyze_detail_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_detail_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_detail_ask.end_date)
}

// optional bytes os_version = 3;
inline bool download_src_analyze_detail_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void download_src_analyze_detail_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void download_src_analyze_detail_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& download_src_analyze_detail_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.os_version)
  return *os_version_;
}
inline void download_src_analyze_detail_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ask.os_version)
}
inline void download_src_analyze_detail_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.download_src_analyze_detail_ask.os_version)
}
inline void download_src_analyze_detail_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.download_src_analyze_detail_ask.os_version)
}
inline ::std::string* download_src_analyze_detail_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ask.os_version)
  return os_version_;
}
inline ::std::string* download_src_analyze_detail_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void download_src_analyze_detail_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_detail_ask.os_version)
}

// optional int32 page_num = 4;
inline bool download_src_analyze_detail_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void download_src_analyze_detail_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void download_src_analyze_detail_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 download_src_analyze_detail_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.page_num)
  return page_num_;
}
inline void download_src_analyze_detail_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ask.page_num)
}

// optional int32 cur_page = 5;
inline bool download_src_analyze_detail_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void download_src_analyze_detail_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void download_src_analyze_detail_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 download_src_analyze_detail_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.cur_page)
  return cur_page_;
}
inline void download_src_analyze_detail_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 6;
inline bool download_src_analyze_detail_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void download_src_analyze_detail_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void download_src_analyze_detail_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void download_src_analyze_detail_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& download_src_analyze_detail_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* download_src_analyze_detail_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* download_src_analyze_detail_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void download_src_analyze_detail_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_detail_ask.ask_header)
}

// -------------------------------------------------------------------

// download_src_analyze_detail_ans

// optional int32 total_number = 1;
inline bool download_src_analyze_detail_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void download_src_analyze_detail_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void download_src_analyze_detail_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void download_src_analyze_detail_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 download_src_analyze_detail_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ans.total_number)
  return total_number_;
}
inline void download_src_analyze_detail_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.download_src_analyze_detail_ans.total_number)
}

// repeated .ODP_main_frame.download_src_detail info = 2;
inline int download_src_analyze_detail_ans::info_size() const {
  return info_.size();
}
inline void download_src_analyze_detail_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::download_src_detail& download_src_analyze_detail_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::download_src_detail* download_src_analyze_detail_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::download_src_detail* download_src_analyze_detail_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.download_src_analyze_detail_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_detail >&
download_src_analyze_detail_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.download_src_analyze_detail_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::download_src_detail >*
download_src_analyze_detail_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.download_src_analyze_detail_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool download_src_analyze_detail_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void download_src_analyze_detail_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void download_src_analyze_detail_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void download_src_analyze_detail_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& download_src_analyze_detail_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.download_src_analyze_detail_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* download_src_analyze_detail_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.download_src_analyze_detail_ans.error)
  return error_;
}
inline ::common::errorinfo* download_src_analyze_detail_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void download_src_analyze_detail_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.download_src_analyze_detail_ans.error)
}

// -------------------------------------------------------------------

// third_party_login_analyze_ask

// optional bytes start_date = 1;
inline bool third_party_login_analyze_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void third_party_login_analyze_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void third_party_login_analyze_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void third_party_login_analyze_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& third_party_login_analyze_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ask.start_date)
  return *start_date_;
}
inline void third_party_login_analyze_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_ask.start_date)
}
inline void third_party_login_analyze_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_ask.start_date)
}
inline void third_party_login_analyze_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_ask.start_date)
}
inline ::std::string* third_party_login_analyze_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ask.start_date)
  return start_date_;
}
inline ::std::string* third_party_login_analyze_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_ask.start_date)
}

// optional bytes end_date = 2;
inline bool third_party_login_analyze_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void third_party_login_analyze_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void third_party_login_analyze_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void third_party_login_analyze_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& third_party_login_analyze_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ask.end_date)
  return *end_date_;
}
inline void third_party_login_analyze_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_ask.end_date)
}
inline void third_party_login_analyze_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_ask.end_date)
}
inline void third_party_login_analyze_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_ask.end_date)
}
inline ::std::string* third_party_login_analyze_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ask.end_date)
  return end_date_;
}
inline ::std::string* third_party_login_analyze_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_ask.end_date)
}

// optional bytes os_version = 3;
inline bool third_party_login_analyze_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void third_party_login_analyze_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void third_party_login_analyze_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void third_party_login_analyze_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& third_party_login_analyze_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ask.os_version)
  return *os_version_;
}
inline void third_party_login_analyze_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_ask.os_version)
}
inline void third_party_login_analyze_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_ask.os_version)
}
inline void third_party_login_analyze_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_ask.os_version)
}
inline ::std::string* third_party_login_analyze_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ask.os_version)
  return os_version_;
}
inline ::std::string* third_party_login_analyze_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_ask.os_version)
}

// optional .common.common_ask_header ask_header = 4;
inline bool third_party_login_analyze_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void third_party_login_analyze_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void third_party_login_analyze_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void third_party_login_analyze_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& third_party_login_analyze_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* third_party_login_analyze_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* third_party_login_analyze_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void third_party_login_analyze_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_ask.ask_header)
}

// -------------------------------------------------------------------

// third_party_login_analyze_ans

// repeated .ODP_main_frame.third_party_login_info info = 1;
inline int third_party_login_analyze_ans::info_size() const {
  return info_.size();
}
inline void third_party_login_analyze_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::third_party_login_info& third_party_login_analyze_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::third_party_login_info* third_party_login_analyze_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::third_party_login_info* third_party_login_analyze_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.third_party_login_analyze_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >&
third_party_login_analyze_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.third_party_login_analyze_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >*
third_party_login_analyze_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.third_party_login_analyze_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 2;
inline bool third_party_login_analyze_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void third_party_login_analyze_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void third_party_login_analyze_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void third_party_login_analyze_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& third_party_login_analyze_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* third_party_login_analyze_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_ans.error)
  return error_;
}
inline ::common::errorinfo* third_party_login_analyze_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void third_party_login_analyze_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_ans.error)
}

// -------------------------------------------------------------------

// third_party_login_analyze_list_ask

// optional bytes start_date = 1;
inline bool third_party_login_analyze_list_ask::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void third_party_login_analyze_list_ask::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void third_party_login_analyze_list_ask::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& third_party_login_analyze_list_ask::start_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
  return *start_date_;
}
inline void third_party_login_analyze_list_ask::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
}
inline void third_party_login_analyze_list_ask::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
}
inline void third_party_login_analyze_list_ask::set_start_date(const void* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
}
inline ::std::string* third_party_login_analyze_list_ask::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
  return start_date_;
}
inline ::std::string* third_party_login_analyze_list_ask::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_list_ask::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_list_ask.start_date)
}

// optional bytes end_date = 2;
inline bool third_party_login_analyze_list_ask::has_end_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_end_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void third_party_login_analyze_list_ask::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void third_party_login_analyze_list_ask::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& third_party_login_analyze_list_ask::end_date() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
  return *end_date_;
}
inline void third_party_login_analyze_list_ask::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
}
inline void third_party_login_analyze_list_ask::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
}
inline void third_party_login_analyze_list_ask::set_end_date(const void* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
}
inline ::std::string* third_party_login_analyze_list_ask::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
  return end_date_;
}
inline ::std::string* third_party_login_analyze_list_ask::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_list_ask::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_list_ask.end_date)
}

// optional bytes os_version = 3;
inline bool third_party_login_analyze_list_ask::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_os_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void third_party_login_analyze_list_ask::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void third_party_login_analyze_list_ask::clear_os_version() {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_->clear();
  }
  clear_has_os_version();
}
inline const ::std::string& third_party_login_analyze_list_ask::os_version() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
  return *os_version_;
}
inline void third_party_login_analyze_list_ask::set_os_version(const ::std::string& value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
}
inline void third_party_login_analyze_list_ask::set_os_version(const char* value) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
}
inline void third_party_login_analyze_list_ask::set_os_version(const void* value, size_t size) {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  os_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
}
inline ::std::string* third_party_login_analyze_list_ask::mutable_os_version() {
  set_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
  return os_version_;
}
inline ::std::string* third_party_login_analyze_list_ask::release_os_version() {
  clear_has_os_version();
  if (os_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_version_;
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void third_party_login_analyze_list_ask::set_allocated_os_version(::std::string* os_version) {
  if (os_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_version_;
  }
  if (os_version) {
    set_has_os_version();
    os_version_ = os_version;
  } else {
    clear_has_os_version();
    os_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_list_ask.os_version)
}

// optional int32 page_num = 4;
inline bool third_party_login_analyze_list_ask::has_page_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_page_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void third_party_login_analyze_list_ask::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void third_party_login_analyze_list_ask::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 third_party_login_analyze_list_ask::page_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.page_num)
  return page_num_;
}
inline void third_party_login_analyze_list_ask::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ask.page_num)
}

// optional int32 cur_page = 5;
inline bool third_party_login_analyze_list_ask::has_cur_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_cur_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void third_party_login_analyze_list_ask::clear_has_cur_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void third_party_login_analyze_list_ask::clear_cur_page() {
  cur_page_ = 0;
  clear_has_cur_page();
}
inline ::google::protobuf::int32 third_party_login_analyze_list_ask::cur_page() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.cur_page)
  return cur_page_;
}
inline void third_party_login_analyze_list_ask::set_cur_page(::google::protobuf::int32 value) {
  set_has_cur_page();
  cur_page_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ask.cur_page)
}

// optional .common.common_ask_header ask_header = 6;
inline bool third_party_login_analyze_list_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void third_party_login_analyze_list_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void third_party_login_analyze_list_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void third_party_login_analyze_list_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& third_party_login_analyze_list_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* third_party_login_analyze_list_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* third_party_login_analyze_list_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void third_party_login_analyze_list_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_list_ask.ask_header)
}

// -------------------------------------------------------------------

// third_party_login_analyze_list_ans

// optional int32 total_number = 1;
inline bool third_party_login_analyze_list_ans::has_total_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void third_party_login_analyze_list_ans::set_has_total_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void third_party_login_analyze_list_ans::clear_has_total_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void third_party_login_analyze_list_ans::clear_total_number() {
  total_number_ = 0;
  clear_has_total_number();
}
inline ::google::protobuf::int32 third_party_login_analyze_list_ans::total_number() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ans.total_number)
  return total_number_;
}
inline void third_party_login_analyze_list_ans::set_total_number(::google::protobuf::int32 value) {
  set_has_total_number();
  total_number_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.third_party_login_analyze_list_ans.total_number)
}

// repeated .ODP_main_frame.third_party_login_info info = 2;
inline int third_party_login_analyze_list_ans::info_size() const {
  return info_.size();
}
inline void third_party_login_analyze_list_ans::clear_info() {
  info_.Clear();
}
inline const ::ODP_main_frame::third_party_login_info& third_party_login_analyze_list_ans::info(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ans.info)
  return info_.Get(index);
}
inline ::ODP_main_frame::third_party_login_info* third_party_login_analyze_list_ans::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ans.info)
  return info_.Mutable(index);
}
inline ::ODP_main_frame::third_party_login_info* third_party_login_analyze_list_ans::add_info() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.third_party_login_analyze_list_ans.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >&
third_party_login_analyze_list_ans::info() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.third_party_login_analyze_list_ans.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::third_party_login_info >*
third_party_login_analyze_list_ans::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.third_party_login_analyze_list_ans.info)
  return &info_;
}

// optional .common.errorinfo error = 3;
inline bool third_party_login_analyze_list_ans::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void third_party_login_analyze_list_ans::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void third_party_login_analyze_list_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void third_party_login_analyze_list_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& third_party_login_analyze_list_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.third_party_login_analyze_list_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* third_party_login_analyze_list_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.third_party_login_analyze_list_ans.error)
  return error_;
}
inline ::common::errorinfo* third_party_login_analyze_list_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void third_party_login_analyze_list_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.third_party_login_analyze_list_ans.error)
}

// -------------------------------------------------------------------

// operation_report_ask

// optional .common.common_ask_header ask_header = 1;
inline bool operation_report_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operation_report_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operation_report_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operation_report_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& operation_report_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.operation_report_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* operation_report_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.operation_report_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* operation_report_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void operation_report_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.operation_report_ask.ask_header)
}

// -------------------------------------------------------------------

// operation_report_info

// optional bytes report_item = 1;
inline bool operation_report_info::has_report_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void operation_report_info::set_has_report_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void operation_report_info::clear_has_report_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void operation_report_info::clear_report_item() {
  if (report_item_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    report_item_->clear();
  }
  clear_has_report_item();
}
inline const ::std::string& operation_report_info::report_item() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.operation_report_info.report_item)
  return *report_item_;
}
inline void operation_report_info::set_report_item(const ::std::string& value) {
  set_has_report_item();
  if (report_item_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    report_item_ = new ::std::string;
  }
  report_item_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.operation_report_info.report_item)
}
inline void operation_report_info::set_report_item(const char* value) {
  set_has_report_item();
  if (report_item_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    report_item_ = new ::std::string;
  }
  report_item_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.operation_report_info.report_item)
}
inline void operation_report_info::set_report_item(const void* value, size_t size) {
  set_has_report_item();
  if (report_item_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    report_item_ = new ::std::string;
  }
  report_item_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.operation_report_info.report_item)
}
inline ::std::string* operation_report_info::mutable_report_item() {
  set_has_report_item();
  if (report_item_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    report_item_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.operation_report_info.report_item)
  return report_item_;
}
inline ::std::string* operation_report_info::release_report_item() {
  clear_has_report_item();
  if (report_item_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = report_item_;
    report_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void operation_report_info::set_allocated_report_item(::std::string* report_item) {
  if (report_item_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete report_item_;
  }
  if (report_item) {
    set_has_report_item();
    report_item_ = report_item;
  } else {
    clear_has_report_item();
    report_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.operation_report_info.report_item)
}

// optional int32 total_num = 2;
inline bool operation_report_info::has_total_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operation_report_info::set_has_total_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operation_report_info::clear_has_total_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operation_report_info::clear_total_num() {
  total_num_ = 0;
  clear_has_total_num();
}
inline ::google::protobuf::int32 operation_report_info::total_num() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.operation_report_info.total_num)
  return total_num_;
}
inline void operation_report_info::set_total_num(::google::protobuf::int32 value) {
  set_has_total_num();
  total_num_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.operation_report_info.total_num)
}

// -------------------------------------------------------------------

// operation_report_ans

// repeated .ODP_main_frame.operation_report_info list = 1;
inline int operation_report_ans::list_size() const {
  return list_.size();
}
inline void operation_report_ans::clear_list() {
  list_.Clear();
}
inline const ::ODP_main_frame::operation_report_info& operation_report_ans::list(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.operation_report_ans.list)
  return list_.Get(index);
}
inline ::ODP_main_frame::operation_report_info* operation_report_ans::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.operation_report_ans.list)
  return list_.Mutable(index);
}
inline ::ODP_main_frame::operation_report_info* operation_report_ans::add_list() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.operation_report_ans.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::operation_report_info >&
operation_report_ans::list() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.operation_report_ans.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::operation_report_info >*
operation_report_ans::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.operation_report_ans.list)
  return &list_;
}

// optional .common.errorinfo error = 2;
inline bool operation_report_ans::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void operation_report_ans::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void operation_report_ans::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void operation_report_ans::clear_error() {
  if (error_ != NULL) error_->::common::errorinfo::Clear();
  clear_has_error();
}
inline const ::common::errorinfo& operation_report_ans::error() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.operation_report_ans.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::common::errorinfo* operation_report_ans::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::common::errorinfo;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.operation_report_ans.error)
  return error_;
}
inline ::common::errorinfo* operation_report_ans::release_error() {
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline void operation_report_ans::set_allocated_error(::common::errorinfo* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.operation_report_ans.error)
}

// -------------------------------------------------------------------

// doc_row

// repeated bytes value = 1;
inline int doc_row::value_size() const {
  return value_.size();
}
inline void doc_row::clear_value() {
  value_.Clear();
}
inline const ::std::string& doc_row::value(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.doc_row.value)
  return value_.Get(index);
}
inline ::std::string* doc_row::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.doc_row.value)
  return value_.Mutable(index);
}
inline void doc_row::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ODP_main_frame.doc_row.value)
  value_.Mutable(index)->assign(value);
}
inline void doc_row::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.doc_row.value)
}
inline void doc_row::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.doc_row.value)
}
inline ::std::string* doc_row::add_value() {
  return value_.Add();
}
inline void doc_row::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ODP_main_frame.doc_row.value)
}
inline void doc_row::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ODP_main_frame.doc_row.value)
}
inline void doc_row::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ODP_main_frame.doc_row.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
doc_row::value() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.doc_row.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
doc_row::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.doc_row.value)
  return &value_;
}

// -------------------------------------------------------------------

// user_certification_list_row

// optional bytes name = 1;
inline bool user_certification_list_row::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_certification_list_row::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_certification_list_row::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_certification_list_row::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& user_certification_list_row::name() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.name)
  return *name_;
}
inline void user_certification_list_row::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.name)
}
inline void user_certification_list_row::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_certification_list_row.name)
}
inline void user_certification_list_row::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_certification_list_row.name)
}
inline ::std::string* user_certification_list_row::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_list_row.name)
  return name_;
}
inline ::std::string* user_certification_list_row::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_certification_list_row::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_list_row.name)
}

// optional bytes page2 = 2;
inline bool user_certification_list_row::has_page2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_certification_list_row::set_has_page2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_certification_list_row::clear_has_page2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_certification_list_row::clear_page2() {
  if (page2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page2_->clear();
  }
  clear_has_page2();
}
inline const ::std::string& user_certification_list_row::page2() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.page2)
  return *page2_;
}
inline void user_certification_list_row::set_page2(const ::std::string& value) {
  set_has_page2();
  if (page2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page2_ = new ::std::string;
  }
  page2_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.page2)
}
inline void user_certification_list_row::set_page2(const char* value) {
  set_has_page2();
  if (page2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page2_ = new ::std::string;
  }
  page2_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_certification_list_row.page2)
}
inline void user_certification_list_row::set_page2(const void* value, size_t size) {
  set_has_page2();
  if (page2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page2_ = new ::std::string;
  }
  page2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_certification_list_row.page2)
}
inline ::std::string* user_certification_list_row::mutable_page2() {
  set_has_page2();
  if (page2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_list_row.page2)
  return page2_;
}
inline ::std::string* user_certification_list_row::release_page2() {
  clear_has_page2();
  if (page2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = page2_;
    page2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_certification_list_row::set_allocated_page2(::std::string* page2) {
  if (page2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete page2_;
  }
  if (page2) {
    set_has_page2();
    page2_ = page2;
  } else {
    clear_has_page2();
    page2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_list_row.page2)
}

// optional bytes page3 = 3;
inline bool user_certification_list_row::has_page3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_certification_list_row::set_has_page3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_certification_list_row::clear_has_page3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_certification_list_row::clear_page3() {
  if (page3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page3_->clear();
  }
  clear_has_page3();
}
inline const ::std::string& user_certification_list_row::page3() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.page3)
  return *page3_;
}
inline void user_certification_list_row::set_page3(const ::std::string& value) {
  set_has_page3();
  if (page3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page3_ = new ::std::string;
  }
  page3_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.page3)
}
inline void user_certification_list_row::set_page3(const char* value) {
  set_has_page3();
  if (page3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page3_ = new ::std::string;
  }
  page3_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_certification_list_row.page3)
}
inline void user_certification_list_row::set_page3(const void* value, size_t size) {
  set_has_page3();
  if (page3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page3_ = new ::std::string;
  }
  page3_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_certification_list_row.page3)
}
inline ::std::string* user_certification_list_row::mutable_page3() {
  set_has_page3();
  if (page3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page3_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_list_row.page3)
  return page3_;
}
inline ::std::string* user_certification_list_row::release_page3() {
  clear_has_page3();
  if (page3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = page3_;
    page3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_certification_list_row::set_allocated_page3(::std::string* page3) {
  if (page3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete page3_;
  }
  if (page3) {
    set_has_page3();
    page3_ = page3;
  } else {
    clear_has_page3();
    page3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_list_row.page3)
}

// optional int32 access_count = 4;
inline bool user_certification_list_row::has_access_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_certification_list_row::set_has_access_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_certification_list_row::clear_has_access_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_certification_list_row::clear_access_count() {
  access_count_ = 0;
  clear_has_access_count();
}
inline ::google::protobuf::int32 user_certification_list_row::access_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.access_count)
  return access_count_;
}
inline void user_certification_list_row::set_access_count(::google::protobuf::int32 value) {
  set_has_access_count();
  access_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.access_count)
}

// optional int32 submit_count = 5;
inline bool user_certification_list_row::has_submit_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_certification_list_row::set_has_submit_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_certification_list_row::clear_has_submit_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_certification_list_row::clear_submit_count() {
  submit_count_ = 0;
  clear_has_submit_count();
}
inline ::google::protobuf::int32 user_certification_list_row::submit_count() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.submit_count)
  return submit_count_;
}
inline void user_certification_list_row::set_submit_count(::google::protobuf::int32 value) {
  set_has_submit_count();
  submit_count_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.submit_count)
}

// optional float percent1 = 6;
inline bool user_certification_list_row::has_percent1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_certification_list_row::set_has_percent1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_certification_list_row::clear_has_percent1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_certification_list_row::clear_percent1() {
  percent1_ = 0;
  clear_has_percent1();
}
inline float user_certification_list_row::percent1() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.percent1)
  return percent1_;
}
inline void user_certification_list_row::set_percent1(float value) {
  set_has_percent1();
  percent1_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.percent1)
}

// optional float percent2 = 7;
inline bool user_certification_list_row::has_percent2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_certification_list_row::set_has_percent2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_certification_list_row::clear_has_percent2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_certification_list_row::clear_percent2() {
  percent2_ = 0;
  clear_has_percent2();
}
inline float user_certification_list_row::percent2() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.percent2)
  return percent2_;
}
inline void user_certification_list_row::set_percent2(float value) {
  set_has_percent2();
  percent2_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.percent2)
}

// optional float percent3 = 8;
inline bool user_certification_list_row::has_percent3() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_certification_list_row::set_has_percent3() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_certification_list_row::clear_has_percent3() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_certification_list_row::clear_percent3() {
  percent3_ = 0;
  clear_has_percent3();
}
inline float user_certification_list_row::percent3() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.percent3)
  return percent3_;
}
inline void user_certification_list_row::set_percent3(float value) {
  set_has_percent3();
  percent3_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.percent3)
}

// optional float percent4 = 9;
inline bool user_certification_list_row::has_percent4() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_certification_list_row::set_has_percent4() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_certification_list_row::clear_has_percent4() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_certification_list_row::clear_percent4() {
  percent4_ = 0;
  clear_has_percent4();
}
inline float user_certification_list_row::percent4() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_list_row.percent4)
  return percent4_;
}
inline void user_certification_list_row::set_percent4(float value) {
  set_has_percent4();
  percent4_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_list_row.percent4)
}

// -------------------------------------------------------------------

// user_certification_ask

// optional .common.common_ask_header ask_header = 1;
inline bool user_certification_ask::has_ask_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_certification_ask::set_has_ask_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_certification_ask::clear_has_ask_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_certification_ask::clear_ask_header() {
  if (ask_header_ != NULL) ask_header_->::common::common_ask_header::Clear();
  clear_has_ask_header();
}
inline const ::common::common_ask_header& user_certification_ask::ask_header() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ask.ask_header)
  return ask_header_ != NULL ? *ask_header_ : *default_instance_->ask_header_;
}
inline ::common::common_ask_header* user_certification_ask::mutable_ask_header() {
  set_has_ask_header();
  if (ask_header_ == NULL) ask_header_ = new ::common::common_ask_header;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ask.ask_header)
  return ask_header_;
}
inline ::common::common_ask_header* user_certification_ask::release_ask_header() {
  clear_has_ask_header();
  ::common::common_ask_header* temp = ask_header_;
  ask_header_ = NULL;
  return temp;
}
inline void user_certification_ask::set_allocated_ask_header(::common::common_ask_header* ask_header) {
  delete ask_header_;
  ask_header_ = ask_header;
  if (ask_header) {
    set_has_ask_header();
  } else {
    clear_has_ask_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_ask.ask_header)
}

// optional int32 certification_type = 2;
inline bool user_certification_ask::has_certification_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_certification_ask::set_has_certification_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_certification_ask::clear_has_certification_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_certification_ask::clear_certification_type() {
  certification_type_ = 0;
  clear_has_certification_type();
}
inline ::google::protobuf::int32 user_certification_ask::certification_type() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ask.certification_type)
  return certification_type_;
}
inline void user_certification_ask::set_certification_type(::google::protobuf::int32 value) {
  set_has_certification_type();
  certification_type_ = value;
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_ask.certification_type)
}

// optional bytes begin_time = 3;
inline bool user_certification_ask::has_begin_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_certification_ask::set_has_begin_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_certification_ask::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_certification_ask::clear_begin_time() {
  if (begin_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    begin_time_->clear();
  }
  clear_has_begin_time();
}
inline const ::std::string& user_certification_ask::begin_time() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ask.begin_time)
  return *begin_time_;
}
inline void user_certification_ask::set_begin_time(const ::std::string& value) {
  set_has_begin_time();
  if (begin_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    begin_time_ = new ::std::string;
  }
  begin_time_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_ask.begin_time)
}
inline void user_certification_ask::set_begin_time(const char* value) {
  set_has_begin_time();
  if (begin_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    begin_time_ = new ::std::string;
  }
  begin_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_certification_ask.begin_time)
}
inline void user_certification_ask::set_begin_time(const void* value, size_t size) {
  set_has_begin_time();
  if (begin_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    begin_time_ = new ::std::string;
  }
  begin_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_certification_ask.begin_time)
}
inline ::std::string* user_certification_ask::mutable_begin_time() {
  set_has_begin_time();
  if (begin_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    begin_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ask.begin_time)
  return begin_time_;
}
inline ::std::string* user_certification_ask::release_begin_time() {
  clear_has_begin_time();
  if (begin_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = begin_time_;
    begin_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_certification_ask::set_allocated_begin_time(::std::string* begin_time) {
  if (begin_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete begin_time_;
  }
  if (begin_time) {
    set_has_begin_time();
    begin_time_ = begin_time;
  } else {
    clear_has_begin_time();
    begin_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_ask.begin_time)
}

// optional bytes end_time = 4;
inline bool user_certification_ask::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_certification_ask::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_certification_ask::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_certification_ask::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& user_certification_ask::end_time() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ask.end_time)
  return *end_time_;
}
inline void user_certification_ask::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set:ODP_main_frame.user_certification_ask.end_time)
}
inline void user_certification_ask::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:ODP_main_frame.user_certification_ask.end_time)
}
inline void user_certification_ask::set_end_time(const void* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ODP_main_frame.user_certification_ask.end_time)
}
inline ::std::string* user_certification_ask::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ask.end_time)
  return end_time_;
}
inline ::std::string* user_certification_ask::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_certification_ask::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_ask.end_time)
}

// -------------------------------------------------------------------

// user_certification_ans

// repeated .ODP_main_frame.doc_row row = 1;
inline int user_certification_ans::row_size() const {
  return row_.size();
}
inline void user_certification_ans::clear_row() {
  row_.Clear();
}
inline const ::ODP_main_frame::doc_row& user_certification_ans::row(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ans.row)
  return row_.Get(index);
}
inline ::ODP_main_frame::doc_row* user_certification_ans::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ans.row)
  return row_.Mutable(index);
}
inline ::ODP_main_frame::doc_row* user_certification_ans::add_row() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_certification_ans.row)
  return row_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::doc_row >&
user_certification_ans::row() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_certification_ans.row)
  return row_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::doc_row >*
user_certification_ans::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_certification_ans.row)
  return &row_;
}

// repeated .ODP_main_frame.user_certification_list_row list = 2;
inline int user_certification_ans::list_size() const {
  return list_.size();
}
inline void user_certification_ans::clear_list() {
  list_.Clear();
}
inline const ::ODP_main_frame::user_certification_list_row& user_certification_ans::list(int index) const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ans.list)
  return list_.Get(index);
}
inline ::ODP_main_frame::user_certification_list_row* user_certification_ans::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ans.list)
  return list_.Mutable(index);
}
inline ::ODP_main_frame::user_certification_list_row* user_certification_ans::add_list() {
  // @@protoc_insertion_point(field_add:ODP_main_frame.user_certification_ans.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_certification_list_row >&
user_certification_ans::list() const {
  // @@protoc_insertion_point(field_list:ODP_main_frame.user_certification_ans.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ODP_main_frame::user_certification_list_row >*
user_certification_ans::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:ODP_main_frame.user_certification_ans.list)
  return &list_;
}

// optional .common.result_info result = 3;
inline bool user_certification_ans::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_certification_ans::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_certification_ans::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_certification_ans::clear_result() {
  if (result_ != NULL) result_->::common::result_info::Clear();
  clear_has_result();
}
inline const ::common::result_info& user_certification_ans::result() const {
  // @@protoc_insertion_point(field_get:ODP_main_frame.user_certification_ans.result)
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::common::result_info* user_certification_ans::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::common::result_info;
  // @@protoc_insertion_point(field_mutable:ODP_main_frame.user_certification_ans.result)
  return result_;
}
inline ::common::result_info* user_certification_ans::release_result() {
  clear_has_result();
  ::common::result_info* temp = result_;
  result_ = NULL;
  return temp;
}
inline void user_certification_ans::set_allocated_result(::common::result_info* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
  // @@protoc_insertion_point(field_set_allocated:ODP_main_frame.user_certification_ans.result)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ODP_main_frame

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ODP_5fmain_5fframe_2eproto__INCLUDED
