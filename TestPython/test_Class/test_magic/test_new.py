#coding=utf8

"""
__new__：创建对象时调用，返回当前对象的一个实例,相当于java里面的构造器 一般是用于继承内置类的，返回值是一个对象
使用：需要控制一个新实例的创建,一般情况下不会使用，除非需要子类化不可变类型例如str/int/unicode/tuple

__init__：创建完对象后调用，对当前对象的实例的一些初始化，无返回值
使用：需要控制一个实例的初始化

可以这样理解，默认是创建（new），然后调用init(new的时候，self还不存在, init的时候self已经存在了)


__new__()是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在Python中存在于类里面的构造方法 __init__()负责将类的实例化，而在__init__()启动之
前，__new__()决定是否要使用该__init__()方法，因为__new__()可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。

如果将类比喻为工厂，那么__init__()方法则是该工厂的生产工人，__init__()方法接受的初始化参数则是生产所需原料，__init__()方法会按照方法中的语句负责将原料加工成
实例以供工厂出货。而__new__()则是生产部经理，__new__()方法可以决定是否将原料提供给该生产部工人，同时它还决定着出货产品是否为该生产部的产品，因为这名经理可以
借该工厂的名义向客户出售完全不是该工厂的产品。

__new__() 方法是在类准备将自身实例化时调用
__new__() 方法始终都是类的静态方法，即使没有被加上静态方法装饰器
"""

class A(object):
    def __init__(self):
        print "call __init__"
        self.value = 1

    def __new__(cls):
        print "call __new__"
        return super(A, cls).__new__(cls)



#a = A()
#print a.value

"""
1、如果（新式）类中没有重写__new__()方法，即在定义新式类时没有重新定义__new__()时，Python默认是调用该类的直接父类的__new__()方法来构造该类的实例，如果该类的
父类也没有重写__new__()，那么将一直按此规矩追溯至object的__new__()方法，因为object是所有新式类的基类

2、如果新式类中重写了__new__()方法，那么你可以自由选择任意一个的其他的新式类（必定要是新式类，只有新式类必定都有__new__()，因为所有新式类都是object的后代，而
经典类则没有__new__()方法）的__new__()方法来制造实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环
"""

#如果__new__()返回其他类（新式类或经典类均可）的实例，那么只会调用被返回的那个类的构造方法
class Foo(object):
    def __init__(self, *args, **kwargs):  #然后该类的__init__()方法作为构造方法会接收这个实例（即self）作为自己的第一个参数，然后依次传入__new__()方法中接收的位置参数和命名参数
        pass
    def __new__(cls, *args, **kwargs):  #新式类开始实例化时，__new__()方法会返回cls（cls指代当前类）的实例
        return object.__new__(Stranger, *args, **kwargs)

class Stranger(object):
    pass

foo = Foo()   #foo其实是Stranger类的实例
print type(foo)

"""
可以这么描述__new__()和__ini__()的区别，在新式类中__new__()才是真正的实例化方法，为类提供外壳制造出实例框架，然后调用该框架内的构造方法__init__()使其丰满。如果
以建房子做比喻，__new__()方法负责开发地皮，打下地基，并将原料存放在工地。而__init__()方法负责从工地取材料建造出地皮开发招标书中规定的大楼，__init__()负责大楼的
细节设计，建造，装修使其可交付给客户
"""


#如果__new__()没有返回cls（即当前类）的实例，那么当前类的__init__()方法是不会被调用的
class Fooer(object):
    def __init__(self, *args, **kwargs):
        print 'call __init__'

    def __new__(cls, *args, **kwargs):
        print 'call __new__'
        return


foo = Fooer()
